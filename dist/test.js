// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"../node_modules/graphlib-dot/node_modules/lodash/dist/lodash.js":[function(require,module,exports) {
var global = arguments[3];
var define;
/**
 * @license
 * Lo-Dash 2.4.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
      descriptor.value = null;
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * https://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.2';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    root._ = _;
  }
}.call(this));

},{}],"../node_modules/graphlib-dot/lib/lodash.js":[function(require,module,exports) {
/* global window */

var lodash;

if (require) {
  try {
    lodash = require("lodash");
  } catch (e) {}
}

if (!lodash) {
  lodash = window._;
}

module.exports = lodash;

},{"lodash":"../node_modules/graphlib-dot/node_modules/lodash/dist/lodash.js"}],"../node_modules/graphlib-dot/lib/dot-grammar.js":[function(require,module,exports) {
module.exports = (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart, graphStmt: peg$parsegraphStmt },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = [],
        peg$c1 = peg$FAILED,
        peg$c2 = null,
        peg$c3 = "{",
        peg$c4 = { type: "literal", value: "{", description: "\"{\"" },
        peg$c5 = "}",
        peg$c6 = { type: "literal", value: "}", description: "\"}\"" },
        peg$c7 = function(strict, type, id, stmts) {
              return {type: type, id: id, strict: strict !== null, stmts: stmts};
            },
        peg$c8 = ";",
        peg$c9 = { type: "literal", value: ";", description: "\";\"" },
        peg$c10 = function(first, rest) {
              var result = [first];
              for (var i = 0; i < rest.length; ++i) {
                result.push(rest[i][1]);
              }
              return result;
            },
        peg$c11 = function(type, attrs) {
              return { type: "attr", attrType: type, attrs: attrs || {}};
            },
        peg$c12 = "=",
        peg$c13 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c14 = function(k, v) {
              var attrs = {};
              attrs[k] = v;
              return { type: "inlineAttr", attrs: attrs };
            },
        peg$c15 = function(id, attrs) { return {type: "node", id: id, attrs: attrs || {}}; },
        peg$c16 = function(lhs, rhs, attrs) {
              var elems = [lhs];
              for (var i = 0; i < rhs.length; ++i) {
                elems.push(rhs[i]);
              }
              return { type: "edge", elems: elems, attrs: attrs || {} };
            },
        peg$c17 = function(id, stmts) {
              id = (id && id[2]) || [];
              return { type: "subgraph", id: id[0], stmts: stmts };
            },
        peg$c18 = function(first, rest) {
              var result = first;
              for (var i = 0; i < rest.length; ++i) {
                _.merge(result, rest[i][1]);
              }
              return result;
            },
        peg$c19 = "[",
        peg$c20 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c21 = "]",
        peg$c22 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c23 = function(aList) { return aList; },
        peg$c24 = ",",
        peg$c25 = { type: "literal", value: ",", description: "\",\"" },
        peg$c26 = function(first, rest) {
              var result = first;
              for (var i = 0; i < rest.length; ++i) {
                _.merge(result, rest[i][3]);
              }
              return result;
            },
        peg$c27 = "--",
        peg$c28 = { type: "literal", value: "--", description: "\"--\"" },
        peg$c29 = function() { return directed; },
        peg$c30 = void 0,
        peg$c31 = "->",
        peg$c32 = { type: "literal", value: "->", description: "\"->\"" },
        peg$c33 = function(rhs, rest) {
              var result = [rhs];
              if (rest) {
                for (var i = 0; i < rest.length; ++i) {
                  result.push(rest[i]);
                }
              }
              return result;
            },
        peg$c34 = function(k, v) {
              var result = {};
              result[k] = v[3];
              return result;
            },
        peg$c35 = function(id) { return { type: "node", id: id, attrs: {} }; },
        peg$c36 = function(id) { return id; },
        peg$c37 = ":",
        peg$c38 = { type: "literal", value: ":", description: "\":\"" },
        peg$c39 = "ne",
        peg$c40 = { type: "literal", value: "ne", description: "\"ne\"" },
        peg$c41 = "se",
        peg$c42 = { type: "literal", value: "se", description: "\"se\"" },
        peg$c43 = "sw",
        peg$c44 = { type: "literal", value: "sw", description: "\"sw\"" },
        peg$c45 = "nw",
        peg$c46 = { type: "literal", value: "nw", description: "\"nw\"" },
        peg$c47 = "n",
        peg$c48 = { type: "literal", value: "n", description: "\"n\"" },
        peg$c49 = "e",
        peg$c50 = { type: "literal", value: "e", description: "\"e\"" },
        peg$c51 = "s",
        peg$c52 = { type: "literal", value: "s", description: "\"s\"" },
        peg$c53 = "w",
        peg$c54 = { type: "literal", value: "w", description: "\"w\"" },
        peg$c55 = "c",
        peg$c56 = { type: "literal", value: "c", description: "\"c\"" },
        peg$c57 = "_",
        peg$c58 = { type: "literal", value: "_", description: "\"_\"" },
        peg$c59 = { type: "other", description: "identifier" },
        peg$c60 = /^[a-zA-Z\u0200-\u0377_]/,
        peg$c61 = { type: "class", value: "[a-zA-Z\\u0200-\\u0377_]", description: "[a-zA-Z\\u0200-\\u0377_]" },
        peg$c62 = /^[a-zA-Z\u0200-\u0377_0-9]/,
        peg$c63 = { type: "class", value: "[a-zA-Z\\u0200-\\u0377_0-9]", description: "[a-zA-Z\\u0200-\\u0377_0-9]" },
        peg$c64 = function(fst, rest) { return fst + rest.join(""); },
        peg$c65 = "-",
        peg$c66 = { type: "literal", value: "-", description: "\"-\"" },
        peg$c67 = ".",
        peg$c68 = { type: "literal", value: ".", description: "\".\"" },
        peg$c69 = /^[0-9]/,
        peg$c70 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c71 = function(sign, dot, after) {
              return (sign || "") + dot + after.join("");
            },
        peg$c72 = function(sign, before, after) {
              return (sign || "") + before.join("") + (after ? after[0] : "") + (after ? after[1].join("") : "");
            },
        peg$c73 = "\"",
        peg$c74 = { type: "literal", value: "\"", description: "\"\\\"\"" },
        peg$c75 = "\\\"",
        peg$c76 = { type: "literal", value: "\\\"", description: "\"\\\\\\\"\"" },
        peg$c77 = function() { return '"'; },
        peg$c78 = "\\",
        peg$c79 = { type: "literal", value: "\\", description: "\"\\\\\"" },
        peg$c80 = /^[^"]/,
        peg$c81 = { type: "class", value: "[^\"]", description: "[^\"]" },
        peg$c82 = function(ch) { return "\\" + ch; },
        peg$c83 = function(id) {
              return id.join("");
            },
        peg$c84 = "node",
        peg$c85 = { type: "literal", value: "node", description: "\"node\"" },
        peg$c86 = function(k) { return k.toLowerCase(); },
        peg$c87 = "edge",
        peg$c88 = { type: "literal", value: "edge", description: "\"edge\"" },
        peg$c89 = "graph",
        peg$c90 = { type: "literal", value: "graph", description: "\"graph\"" },
        peg$c91 = "digraph",
        peg$c92 = { type: "literal", value: "digraph", description: "\"digraph\"" },
        peg$c93 = "subgraph",
        peg$c94 = { type: "literal", value: "subgraph", description: "\"subgraph\"" },
        peg$c95 = "strict",
        peg$c96 = { type: "literal", value: "strict", description: "\"strict\"" },
        peg$c97 = function(graph) {
              directed = graph === "digraph";
              return graph;
            },
        peg$c98 = { type: "other", description: "whitespace" },
        peg$c99 = /^[ \t\r\n]/,
        peg$c100 = { type: "class", value: "[ \\t\\r\\n]", description: "[ \\t\\r\\n]" },
        peg$c101 = { type: "other", description: "comment" },
        peg$c102 = "//",
        peg$c103 = { type: "literal", value: "//", description: "\"//\"" },
        peg$c104 = /^[^\n]/,
        peg$c105 = { type: "class", value: "[^\\n]", description: "[^\\n]" },
        peg$c106 = "/*",
        peg$c107 = { type: "literal", value: "/*", description: "\"/*\"" },
        peg$c108 = "*/",
        peg$c109 = { type: "literal", value: "*/", description: "\"*/\"" },
        peg$c110 = { type: "any", description: "any character" },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsestart() {
      var s0, s1;

      s0 = [];
      s1 = peg$parsegraphStmt();
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parsegraphStmt();
        }
      } else {
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parsegraphStmt() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parsestrict();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$c1;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c1;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c2;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsegraphType();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parse_();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parse_();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseid();
              if (s5 === peg$FAILED) {
                s5 = peg$c2;
              }
              if (s5 !== peg$FAILED) {
                s6 = [];
                s7 = peg$parse_();
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parse_();
                }
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 123) {
                    s7 = peg$c3;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c4); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = [];
                    s9 = peg$parse_();
                    while (s9 !== peg$FAILED) {
                      s8.push(s9);
                      s9 = peg$parse_();
                    }
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsestmtList();
                      if (s9 === peg$FAILED) {
                        s9 = peg$c2;
                      }
                      if (s9 !== peg$FAILED) {
                        s10 = [];
                        s11 = peg$parse_();
                        while (s11 !== peg$FAILED) {
                          s10.push(s11);
                          s11 = peg$parse_();
                        }
                        if (s10 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 125) {
                            s11 = peg$c5;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c6); }
                          }
                          if (s11 !== peg$FAILED) {
                            s12 = [];
                            s13 = peg$parse_();
                            while (s13 !== peg$FAILED) {
                              s12.push(s13);
                              s13 = peg$parse_();
                            }
                            if (s12 !== peg$FAILED) {
                              peg$reportedPos = s0;
                              s1 = peg$c7(s2, s3, s5, s9);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c1;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c1;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c1;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c1;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parsestmtList() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      s1 = peg$parsestmt();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parse_();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parse_();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 59) {
            s3 = peg$c8;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c9); }
          }
          if (s3 === peg$FAILED) {
            s3 = peg$c2;
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$currPos;
            s6 = [];
            s7 = peg$parse_();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parse_();
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parsestmt();
              if (s7 !== peg$FAILED) {
                s8 = [];
                s9 = peg$parse_();
                while (s9 !== peg$FAILED) {
                  s8.push(s9);
                  s9 = peg$parse_();
                }
                if (s8 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 59) {
                    s9 = peg$c8;
                    peg$currPos++;
                  } else {
                    s9 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c9); }
                  }
                  if (s9 === peg$FAILED) {
                    s9 = peg$c2;
                  }
                  if (s9 !== peg$FAILED) {
                    s6 = [s6, s7, s8, s9];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c1;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c1;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c1;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$c1;
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              s6 = [];
              s7 = peg$parse_();
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$parse_();
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parsestmt();
                if (s7 !== peg$FAILED) {
                  s8 = [];
                  s9 = peg$parse_();
                  while (s9 !== peg$FAILED) {
                    s8.push(s9);
                    s9 = peg$parse_();
                  }
                  if (s8 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 59) {
                      s9 = peg$c8;
                      peg$currPos++;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c9); }
                    }
                    if (s9 === peg$FAILED) {
                      s9 = peg$c2;
                    }
                    if (s9 !== peg$FAILED) {
                      s6 = [s6, s7, s8, s9];
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$c1;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c1;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c1;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c1;
              }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c10(s1, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parsestmt() {
      var s0;

      s0 = peg$parseattrStmt();
      if (s0 === peg$FAILED) {
        s0 = peg$parseedgeStmt();
        if (s0 === peg$FAILED) {
          s0 = peg$parsesubgraphStmt();
          if (s0 === peg$FAILED) {
            s0 = peg$parseinlineAttrStmt();
            if (s0 === peg$FAILED) {
              s0 = peg$parsenodeStmt();
            }
          }
        }
      }

      return s0;
    }

    function peg$parseattrStmt() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsegraph();
      if (s1 === peg$FAILED) {
        s1 = peg$parsenode();
        if (s1 === peg$FAILED) {
          s1 = peg$parseedge();
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parse_();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parse_();
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseattrList();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c11(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parseinlineAttrStmt() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseid();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parse_();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parse_();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c12;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c13); }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parse_();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parse_();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseid();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c14(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parsenodeStmt() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsenodeId();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parse_();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parse_();
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseattrList();
          if (s3 === peg$FAILED) {
            s3 = peg$c2;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c15(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parseedgeStmt() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parsenodeIdOrSubgraph();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parse_();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parse_();
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseedgeRHS();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parse_();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parse_();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseattrList();
              if (s5 === peg$FAILED) {
                s5 = peg$c2;
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c16(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parsesubgraphStmt() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parsesubgraph();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parse_();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parse_();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$currPos;
          s5 = peg$parseid();
          if (s5 !== peg$FAILED) {
            s6 = [];
            s7 = peg$parse_();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parse_();
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$c1;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$c1;
          }
          if (s4 === peg$FAILED) {
            s4 = peg$c2;
          }
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$c1;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c1;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c1;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c3;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c4); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parse_();
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsestmtList();
            if (s4 === peg$FAILED) {
              s4 = peg$c2;
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parse_();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parse_();
              }
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s6 = peg$c5;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c6); }
                }
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c17(s1, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parseattrList() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseattrListBlock();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = [];
        s5 = peg$parse_();
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$parse_();
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseattrListBlock();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c1;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c1;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseattrListBlock();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c1;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c1;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c18(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parseattrListBlock() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c19;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c20); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parse_();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parse_();
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseaList();
          if (s3 === peg$FAILED) {
            s3 = peg$c2;
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parse_();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parse_();
            }
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s5 = peg$c21;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c22); }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c23(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parseaList() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseidDef();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = [];
        s5 = peg$parse_();
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$parse_();
        }
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c24;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c25); }
          }
          if (s5 === peg$FAILED) {
            s5 = peg$c2;
          }
          if (s5 !== peg$FAILED) {
            s6 = [];
            s7 = peg$parse_();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parse_();
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parseidDef();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c1;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c1;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c1;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c1;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c24;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c25); }
            }
            if (s5 === peg$FAILED) {
              s5 = peg$c2;
            }
            if (s5 !== peg$FAILED) {
              s6 = [];
              s7 = peg$parse_();
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$parse_();
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parseidDef();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c1;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c1;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c1;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c1;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c26(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parseedgeRHS() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c27) {
        s2 = peg$c27;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c28); }
      }
      if (s2 !== peg$FAILED) {
        peg$reportedPos = peg$currPos;
        s3 = peg$c29();
        if (s3) {
          s3 = peg$c1;
        } else {
          s3 = peg$c30;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c1;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c1;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c31) {
          s2 = peg$c31;
          peg$currPos += 2;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c32); }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = peg$currPos;
          s3 = peg$c29();
          if (s3) {
            s3 = peg$c30;
          } else {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$c1;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c1;
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parse_();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parse_();
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsenodeIdOrSubgraph();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parse_();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parse_();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseedgeRHS();
              if (s5 === peg$FAILED) {
                s5 = peg$c2;
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c33(s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parseidDef() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parseid();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = [];
        s4 = peg$parse_();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parse_();
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s4 = peg$c12;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c13); }
          }
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parse_();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parse_();
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseid();
              if (s6 !== peg$FAILED) {
                s3 = [s3, s4, s5, s6];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c1;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c1;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c1;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c1;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c2;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c34(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parsenodeIdOrSubgraph() {
      var s0, s1;

      s0 = peg$parsesubgraphStmt();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsenodeId();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c35(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parsenodeId() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseid();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parse_();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parse_();
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseport();
          if (s3 === peg$FAILED) {
            s3 = peg$c2;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c36(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parseport() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 58) {
        s1 = peg$c37;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c38); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parse_();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parse_();
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseid();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parse_();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parse_();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 58) {
                s6 = peg$c37;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c38); }
              }
              if (s6 !== peg$FAILED) {
                s7 = [];
                s8 = peg$parse_();
                while (s8 !== peg$FAILED) {
                  s7.push(s8);
                  s8 = peg$parse_();
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parsecompassPt();
                  if (s8 !== peg$FAILED) {
                    s6 = [s6, s7, s8];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c1;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c1;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c1;
              }
              if (s5 === peg$FAILED) {
                s5 = peg$c2;
              }
              if (s5 !== peg$FAILED) {
                s1 = [s1, s2, s3, s4, s5];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parsecompassPt() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c39) {
        s0 = peg$c39;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c40); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c41) {
          s0 = peg$c41;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c42); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c43) {
            s0 = peg$c43;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c44); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c45) {
              s0 = peg$c45;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c46); }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 110) {
                s0 = peg$c47;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c48); }
              }
              if (s0 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 101) {
                  s0 = peg$c49;
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c50); }
                }
                if (s0 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 115) {
                    s0 = peg$c51;
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c52); }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 119) {
                      s0 = peg$c53;
                      peg$currPos++;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c54); }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 99) {
                        s0 = peg$c55;
                        peg$currPos++;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c56); }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 95) {
                          s0 = peg$c57;
                          peg$currPos++;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c58); }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseid() {
      var s0, s1, s2, s3, s4, s5, s6;

      peg$silentFails++;
      s0 = peg$currPos;
      if (peg$c60.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c61); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c62.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c63); }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c62.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c63); }
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c64(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c65;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c66); }
        }
        if (s1 === peg$FAILED) {
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s2 = peg$c67;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c68); }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            if (peg$c69.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c70); }
            }
            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                if (peg$c69.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c70); }
                }
              }
            } else {
              s3 = peg$c1;
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c71(s1, s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c65;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c66); }
          }
          if (s1 === peg$FAILED) {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c69.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c70); }
            }
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (peg$c69.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c70); }
                }
              }
            } else {
              s2 = peg$c1;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c67;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c68); }
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                if (peg$c69.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c70); }
                }
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  if (peg$c69.test(input.charAt(peg$currPos))) {
                    s6 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c70); }
                  }
                }
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c1;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c1;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$c2;
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c72(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 34) {
              s1 = peg$c73;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c74); }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c75) {
                s4 = peg$c75;
                peg$currPos += 2;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c76); }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s3;
                s4 = peg$c77();
              }
              s3 = s4;
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 92) {
                  s4 = peg$c78;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c79); }
                }
                if (s4 !== peg$FAILED) {
                  if (peg$c80.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c81); }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s3;
                    s4 = peg$c82(s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c1;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$c1;
                }
                if (s3 === peg$FAILED) {
                  if (peg$c80.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c81); }
                  }
                }
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c75) {
                  s4 = peg$c75;
                  peg$currPos += 2;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c76); }
                }
                if (s4 !== peg$FAILED) {
                  peg$reportedPos = s3;
                  s4 = peg$c77();
                }
                s3 = s4;
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 92) {
                    s4 = peg$c78;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c79); }
                  }
                  if (s4 !== peg$FAILED) {
                    if (peg$c80.test(input.charAt(peg$currPos))) {
                      s5 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c81); }
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s3;
                      s4 = peg$c82(s5);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$c1;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c1;
                  }
                  if (s3 === peg$FAILED) {
                    if (peg$c80.test(input.charAt(peg$currPos))) {
                      s3 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s3 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c81); }
                    }
                  }
                }
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 34) {
                  s3 = peg$c73;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c74); }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c83(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c59); }
      }

      return s0;
    }

    function peg$parsenode() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c84) {
        s1 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c85); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c86(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseedge() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c87) {
        s1 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c88); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c86(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsegraph() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c89) {
        s1 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c90); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c86(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsedigraph() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c91) {
        s1 = input.substr(peg$currPos, 7);
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c92); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c86(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsesubgraph() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8).toLowerCase() === peg$c93) {
        s1 = input.substr(peg$currPos, 8);
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c94); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c86(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsestrict() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c95) {
        s1 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c96); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c86(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsegraphType() {
      var s0, s1;

      s0 = peg$parsegraph();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsedigraph();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c97(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parsewhitespace() {
      var s0, s1;

      peg$silentFails++;
      s0 = [];
      if (peg$c99.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c100); }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$c99.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c100); }
          }
        }
      } else {
        s0 = peg$c1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c98); }
      }

      return s0;
    }

    function peg$parsecomment() {
      var s0, s1, s2, s3, s4, s5;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c102) {
        s1 = peg$c102;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c103); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c104.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c105); }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c104.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c105); }
          }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c106) {
          s1 = peg$c106;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c107); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          if (input.substr(peg$currPos, 2) === peg$c108) {
            s5 = peg$c108;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c109); }
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c30;
          } else {
            peg$currPos = s4;
            s4 = peg$c1;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c110); }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c1;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c1;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            if (input.substr(peg$currPos, 2) === peg$c108) {
              s5 = peg$c108;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c109); }
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = peg$c30;
            } else {
              peg$currPos = s4;
              s4 = peg$c1;
            }
            if (s4 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c110); }
              }
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c1;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c1;
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c108) {
              s3 = peg$c108;
              peg$currPos += 2;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c109); }
            }
            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c101); }
      }

      return s0;
    }

    function peg$parse_() {
      var s0;

      s0 = peg$parsewhitespace();
      if (s0 === peg$FAILED) {
        s0 = peg$parsecomment();
      }

      return s0;
    }


      var _ = require("./lodash");
      var directed;


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})();

},{"./lodash":"../node_modules/graphlib-dot/lib/lodash.js"}],"../node_modules/graphlib-dot/node_modules/graphlib/node_modules/lodash/index.js":[function(require,module,exports) {
var global = arguments[3];
var define;
/**
 * @license
 * lodash 3.10.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -d -o ./index.js`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '3.10.1';

  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      BIND_KEY_FLAG = 2,
      CURRY_BOUND_FLAG = 4,
      CURRY_FLAG = 8,
      CURRY_RIGHT_FLAG = 16,
      PARTIAL_FLAG = 32,
      PARTIAL_RIGHT_FLAG = 64,
      ARY_FLAG = 128,
      REARG_FLAG = 256;

  /** Used as default options for `_.trunc`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect when a function becomes hot. */
  var HOT_COUNT = 150,
      HOT_SPAN = 16;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2;

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
      reUnescapedHtml = /[&<>"'`]/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

  /**
   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
   */
  var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
      reHasRegExpChars = RegExp(reRegExpChars.source);

  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
  var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect hexadecimal string values. */
  var reHasHexPrefix = /^0[xX]/;

  /** Used to detect host constructors (Safari > 5). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^\d+$/;

  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to match words to create compound words. */
  var reWords = (function() {
    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
  }());

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
  cloneableTags[dateTag] = cloneableTags[float32Tag] =
  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[stringTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[mapTag] = cloneableTags[setTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map latin-1 supplementary letters to basic latin letters. */
  var deburredLetters = {
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&#96;': '`'
  };

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used to escape characters for inclusion in compiled regexes. */
  var regexpEscapes = {
    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

  /** Detect free variable `self`. */
  var freeSelf = objectTypes[typeof self] && self && self.Object && self;

  /** Detect free variable `window`. */
  var freeWindow = objectTypes[typeof window] && window && window.Object && window;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /**
   * Used as a reference to the global object.
   *
   * The `this` value is used if it's the global object to avoid Greasemonkey's
   * restricted `window` object, otherwise the `window` object is used.
   */
  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `compareAscending` which compares values and
   * sorts them in ascending order without guaranteeing a stable sort.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function baseCompareAscending(value, other) {
    if (value !== other) {
      var valIsNull = value === null,
          valIsUndef = value === undefined,
          valIsReflexive = value === value;

      var othIsNull = other === null,
          othIsUndef = other === undefined,
          othIsReflexive = other === other;

      if ((value > other && !othIsNull) || !valIsReflexive ||
          (valIsNull && !othIsUndef && othIsReflexive) ||
          (valIsUndef && othIsReflexive)) {
        return 1;
      }
      if ((value < other && !valIsNull) || !othIsReflexive ||
          (othIsNull && !valIsUndef && valIsReflexive) ||
          (othIsUndef && valIsReflexive)) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {Function} predicate The function invoked per iteration.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromRight) {
    var length = array.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without support for binary searches.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return indexOfNaN(array, fromIndex);
    }
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isFunction` without support for environments
   * with incorrect `typeof` results.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   */
  function baseIsFunction(value) {
    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
    return typeof value == 'function' || false;
  }

  /**
   * Converts `value` to a string if it's not one. An empty string is returned
   * for `null` or `undefined` values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    return value == null ? '' : (value + '');
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the first character not found in `chars`.
   */
  function charsLeftIndex(string, chars) {
    var index = -1,
        length = string.length;

    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the last character not found in `chars`.
   */
  function charsRightIndex(string, chars) {
    var index = string.length;

    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.sortBy` to compare transformed elements of a collection and stable
   * sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareAscending(object, other) {
    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
  }

  /**
   * Used by `_.sortByOrder` to compare multiple properties of a value to another
   * and stable sort them.
   *
   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
   * a value is sorted in ascending order if its corresponding order is "asc", and
   * descending if "desc".
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {boolean[]} orders The order to sort by for each property.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        var order = orders[index];
        return result * ((order === 'asc' || order === true) ? 1 : -1);
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  function deburrLetter(letter) {
    return deburredLetters[letter];
  }

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeHtmlChar(chr) {
    return htmlEscapes[chr];
  }

  /**
   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @param {string} leadingChar The capture group for a leading character.
   * @param {string} whitespaceChar The capture group for a whitespace character.
   * @returns {string} Returns the escaped character.
   */
  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
    if (leadingChar) {
      chr = regexpEscapes[chr];
    } else if (whitespaceChar) {
      chr = stringEscapes[chr];
    }
    return '\\' + chr;
  }

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the index at which the first occurrence of `NaN` is found in `array`.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
   */
  function indexOfNaN(array, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 0 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      var other = array[index];
      if (other !== other) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
   * character code is whitespace.
   *
   * @private
   * @param {number} charCode The character code to inspect.
   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
   */
  function isSpace(charCode) {
    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      if (array[index] === placeholder) {
        array[index] = PLACEHOLDER;
        result[++resIndex] = index;
      }
    }
    return result;
  }

  /**
   * An implementation of `_.uniq` optimized for sorted arrays without support
   * for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The function invoked per iteration.
   * @returns {Array} Returns the new duplicate-value-free array.
   */
  function sortedUniq(array, iteratee) {
    var seen,
        index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value, index, array) : value;

      if (!index || seen !== computed) {
        seen = computed;
        result[++resIndex] = value;
      }
    }
    return result;
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the first non-whitespace character.
   */
  function trimmedLeftIndex(string) {
    var index = -1,
        length = string.length;

    while (++index < length && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedRightIndex(string) {
    var index = string.length;

    while (index-- && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  function unescapeHtmlChar(chr) {
    return htmlUnescapes[chr];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the given `context` object.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // using `context` to mock `Date#getTime` use in `_.now`
   * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
   *
   * // or creating a suped-up `defer` in Node.js
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See https://es5.github.io/#x11.1.5 for more details.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for native method references. */
    var arrayProto = Array.prototype,
        objectProto = Object.prototype,
        stringProto = String.prototype;

    /** Used to resolve the decompiled source of functions. */
    var fnToString = Function.prototype.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objToString = objectProto.toString;

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Native method references. */
    var ArrayBuffer = context.ArrayBuffer,
        clearTimeout = context.clearTimeout,
        parseFloat = context.parseFloat,
        pow = Math.pow,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        Set = getNative(context, 'Set'),
        setTimeout = context.setTimeout,
        splice = arrayProto.splice,
        Uint8Array = context.Uint8Array,
        WeakMap = getNative(context, 'WeakMap');

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeCreate = getNative(Object, 'create'),
        nativeFloor = Math.floor,
        nativeIsArray = getNative(Array, 'isArray'),
        nativeIsFinite = context.isFinite,
        nativeKeys = getNative(Object, 'keys'),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = getNative(Date, 'now'),
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used as references for `-Infinity` and `Infinity`. */
    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

    /**
     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
     * of an array-like value.
     */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
     * Methods that operate on and return arrays, collections, and functions can
     * be chained together. Methods that retrieve a single value or may return a
     * primitive value will automatically end the chain returning the unwrapped
     * value. Explicit chaining may be enabled using `_.chain`. The execution of
     * chained methods is lazy, that is, execution is deferred until `_#value`
     * is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
     * fusion is an optimization strategy which merge iteratee calls; this can help
     * to avoid the creation of intermediate data structures and greatly reduce the
     * number of iteratee executions.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
     * `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
     * and `where`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
     * `unescape`, `uniqueId`, `value`, and `words`
     *
     * The wrapper method `sample` will return a wrapped value when `n` is provided,
     * otherwise an unwrapped value is returned.
     *
     * @name _
     * @constructor
     * @category Chain
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(total, n) {
     *   return total + n;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(n) {
     *   return n * n;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The function whose prototype all chaining wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
     */
    function LodashWrapper(value, chainAll, actions) {
      this.__wrapped__ = value;
      this.__actions__ = actions || [];
      this.__chain__ = !!chainAll;
    }

    /**
     * An object environment feature flags.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = POSITIVE_INFINITY;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = arrayCopy(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = arrayCopy(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = arrayCopy(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
        return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a cache object to store key/value pairs.
     *
     * @private
     * @static
     * @name Cache
     * @memberOf _.memoize
     */
    function MapCache() {
      this.__data__ = {};
    }

    /**
     * Removes `key` and its value from the cache.
     *
     * @private
     * @name delete
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
     */
    function mapDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }

    /**
     * Gets the cached value for `key`.
     *
     * @private
     * @name get
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the cached value.
     */
    function mapGet(key) {
      return key == '__proto__' ? undefined : this.__data__[key];
    }

    /**
     * Checks if a cached value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
    }

    /**
     * Sets `value` to `key` of the cache.
     *
     * @private
     * @name set
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to cache.
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache object.
     */
    function mapSet(key, value) {
      if (key != '__proto__') {
        this.__data__[key] = value;
      }
      return this;
    }

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates a cache object to store unique values.
     *
     * @private
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var length = values ? values.length : 0;

      this.data = { 'hash': nativeCreate(null), 'set': new Set };
      while (length--) {
        this.push(values[length]);
      }
    }

    /**
     * Checks if `value` is in `cache` mimicking the return signature of
     * `_.indexOf` by returning `0` if the value is found, else `-1`.
     *
     * @private
     * @param {Object} cache The cache to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns `0` if `value` is found, else `-1`.
     */
    function cacheIndexOf(cache, value) {
      var data = cache.data,
          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

      return result ? 0 : -1;
    }

    /**
     * Adds `value` to the cache.
     *
     * @private
     * @name push
     * @memberOf SetCache
     * @param {*} value The value to cache.
     */
    function cachePush(value) {
      var data = this.data;
      if (typeof value == 'string' || isObject(value)) {
        data.set.add(value);
      } else {
        data.hash[value] = true;
      }
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a new array joining `array` with `other`.
     *
     * @private
     * @param {Array} array The array to join.
     * @param {Array} other The other array to join.
     * @returns {Array} Returns the new concatenated array.
     */
    function arrayConcat(array, other) {
      var index = -1,
          length = array.length,
          othIndex = -1,
          othLength = other.length,
          result = Array(length + othLength);

      while (++index < length) {
        result[index] = array[index];
      }
      while (++othIndex < othLength) {
        result[index++] = other[othIndex];
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function arrayCopy(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.forEach` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.forEachRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEachRight(array, iteratee) {
      var length = array.length;

      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.every` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */
    function arrayEvery(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
     * with one argument: (value).
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function arrayExtremum(array, iteratee, comparator, exValue) {
      var index = -1,
          length = array.length,
          computed = exValue,
          result = computed;

      while (++index < length) {
        var value = array[index],
            current = +iteratee(value);

        if (comparator(current, computed)) {
          computed = current;
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.filter` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.map` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the first element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initFromArray) {
      var index = -1,
          length = array.length;

      if (initFromArray && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.reduceRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the last element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
      var length = array.length;
      if (initFromArray && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.some` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * A specialized version of `_.sum` for arrays without support for callback
     * shorthands and `this` binding..
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function arraySum(array, iteratee) {
      var length = array.length,
          result = 0;

      while (length--) {
        result += +iteratee(array[length]) || 0;
      }
      return result;
    }

    /**
     * Used by `_.defaults` to customize its `_.assign` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : objectValue;
    }

    /**
     * Used by `_.template` to customize its `_.assign` use.
     *
     * **Note:** This function is like `assignDefaults` except that it ignores
     * inherited property values when checking if a property is `undefined`.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @param {string} key The key associated with the object and source values.
     * @param {Object} object The destination object.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignOwnDefaults(objectValue, sourceValue, key, object) {
      return (objectValue === undefined || !hasOwnProperty.call(object, key))
        ? sourceValue
        : objectValue;
    }

    /**
     * A specialized version of `_.assign` for customizing assigned values without
     * support for argument juggling, multiple sources, and `this` binding `customizer`
     * functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     */
    function assignWith(object, source, customizer) {
      var index = -1,
          props = keys(source),
          length = props.length;

      while (++index < length) {
        var key = props[index],
            value = object[key],
            result = customizer(value, source[key], key, object, source);

        if ((result === result ? (result !== value) : (value === value)) ||
            (value === undefined && !(key in object))) {
          object[key] = result;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.assign` without support for argument juggling,
     * multiple sources, and `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return source == null
        ? object
        : baseCopy(source, keys(source), object);
    }

    /**
     * The base implementation of `_.at` without support for string collections
     * and individual key arguments.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {number[]|string[]} props The property names or indexes of elements to pick.
     * @returns {Array} Returns the new array of picked elements.
     */
    function baseAt(collection, props) {
      var index = -1,
          isNil = collection == null,
          isArr = !isNil && isArrayLike(collection),
          length = isArr ? collection.length : 0,
          propsLength = props.length,
          result = Array(propsLength);

      while(++index < propsLength) {
        var key = props[index];
        if (isArr) {
          result[index] = isIndex(key, length) ? collection[key] : undefined;
        } else {
          result[index] = isNil ? undefined : collection[key];
        }
      }
      return result;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property names to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @returns {Object} Returns `object`.
     */
    function baseCopy(source, props, object) {
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];
        object[key] = source[key];
      }
      return object;
    }

    /**
     * The base implementation of `_.callback` which supports specifying the
     * number of arguments to provide to `func`.
     *
     * @private
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function baseCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (type == 'function') {
        return thisArg === undefined
          ? func
          : bindCallback(func, thisArg, argCount);
      }
      if (func == null) {
        return identity;
      }
      if (type == 'object') {
        return baseMatches(func);
      }
      return thisArg === undefined
        ? property(func)
        : baseMatchesProperty(func, thisArg);
    }

    /**
     * The base implementation of `_.clone` without support for argument juggling
     * and `this` binding `customizer` functions.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The object `value` belongs to.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return arrayCopy(value, result);
        }
      } else {
        var tag = objToString.call(value),
            isFunc = tag == funcTag;

        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return baseAssign(result, value);
          }
        } else {
          return cloneableTags[tag]
            ? initCloneByTag(value, tag, isDeep)
            : (object ? value : {});
        }
      }
      // Check for circular references and return its corresponding clone.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      // Add the source value to the stack of traversed objects and associate it with its clone.
      stackA.push(value);
      stackB.push(result);

      // Recursively populate clone (susceptible to call stack limits).
      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
      });
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(prototype) {
        if (isObject(prototype)) {
          object.prototype = prototype;
          var result = new object;
          object.prototype = undefined;
        }
        return result || {};
      };
    }());

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts an index
     * of where to slice the arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Object} args The arguments provide to `func`.
     * @returns {number} Returns the timer id.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of `_.difference` which accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values) {
      var length = array ? array.length : 0,
          result = [];

      if (!length) {
        return result;
      }
      var index = -1,
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
          valuesLength = values.length;

      if (cache) {
        indexOf = cacheIndexOf;
        isCommon = false;
        values = cache;
      }
      outer:
      while (++index < length) {
        var value = array[index];

        if (isCommon && value === value) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === value) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (indexOf(values, value, 0) < 0) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * Gets the extremum value of `collection` invoking `iteratee` for each value
     * in `collection` to generate the criterion by which the value is ranked.
     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(collection, iteratee, comparator, exValue) {
      var computed = exValue,
          result = computed;

      baseEach(collection, function(value, index, collection) {
        var current = +iteratee(value, index, collection);
        if (comparator(current, computed) || (current === exValue && current === result)) {
          computed = current;
          result = value;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : (end >>> 0);
      start >>>= 0;

      while (start < length) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
     * without support for callback shorthands and `this` binding, which iterates
     * over `collection` using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @param {boolean} [retKey] Specify returning the key of the found element
     *  instead of the element itself.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFind(collection, predicate, eachFunc, retKey) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = retKey ? key : value;
          return false;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with added support for restricting
     * flattening and specifying the start index.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, isDeep, isStrict, result) {
      result || (result = []);

      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index];
        if (isObjectLike(value) && isArrayLike(value) &&
            (isStrict || isArray(value) || isArguments(value))) {
          if (isDeep) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, isDeep, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForIn` and `baseForOwn` which iterates
     * over `object` properties returned by `keysFunc` invoking `iteratee` for
     * each property. Iteratee functions may exit iteration early by explicitly
     * returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forIn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForIn(object, iteratee) {
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * The base implementation of `_.forOwn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from those provided.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the new array of filtered property names.
     */
    function baseFunctions(object, props) {
      var index = -1,
          length = props.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var key = props[index];
        if (isFunction(object[key])) {
          result[++resIndex] = key;
        }
      }
      return result;
    }

    /**
     * The base implementation of `get` without support for string paths
     * and default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path of the property to get.
     * @param {string} [pathKey] The key representation of path.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path, pathKey) {
      if (object == null) {
        return;
      }
      if (pathKey !== undefined && pathKey in toObject(object)) {
        path = [pathKey];
      }
      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[path[index++]];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `_.isEqual` without support for `this` binding
     * `customizer` functions.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag,
          othTag = arrayTag;

      if (!objIsArr) {
        objTag = objToString.call(object);
        if (objTag == argsTag) {
          objTag = objectTag;
        } else if (objTag != objectTag) {
          objIsArr = isTypedArray(object);
        }
      }
      if (!othIsArr) {
        othTag = objToString.call(other);
        if (othTag == argsTag) {
          othTag = objectTag;
        } else if (othTag != objectTag) {
          othIsArr = isTypedArray(other);
        }
      }
      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && !(objIsArr || objIsObj)) {
        return equalByTag(object, other, objTag);
      }
      if (!isLoose) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
        }
      }
      if (!isSameTag) {
        return false;
      }
      // Assume cyclic values are equal.
      // For more information on detecting circular references see https://es5.github.io/#JO.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == object) {
          return stackB[length] == other;
        }
      }
      // Add `object` and `other` to the stack of traversed objects.
      stackA.push(object);
      stackB.push(other);

      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

      stackA.pop();
      stackB.pop();

      return result;
    }

    /**
     * The base implementation of `_.isMatch` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} matchData The propery names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = toObject(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var result = customizer ? customizer(objValue, srcValue, key) : undefined;
          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.map` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which does not clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        var key = matchData[0][0],
            value = matchData[0][1];

        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === value && (value !== undefined || (key in toObject(object)));
        };
      }
      return function(object) {
        return baseIsMatch(object, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to compare.
     * @returns {Function} Returns the new function.
     */
    function baseMatchesProperty(path, srcValue) {
      var isArr = isArray(path),
          isCommon = isKey(path) && isStrictComparable(srcValue),
          pathKey = (path + '');

      path = toPath(path);
      return function(object) {
        if (object == null) {
          return false;
        }
        var key = pathKey;
        object = toObject(object);
        if ((isArr || !isCommon) && !(key in object)) {
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          if (object == null) {
            return false;
          }
          key = last(path);
          object = toObject(object);
        }
        return object[key] === srcValue
          ? (srcValue !== undefined || (key in object))
          : baseIsEqual(srcValue, object[key], undefined, true);
      };
    }

    /**
     * The base implementation of `_.merge` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {Object} Returns `object`.
     */
    function baseMerge(object, source, customizer, stackA, stackB) {
      if (!isObject(object)) {
        return object;
      }
      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
          props = isSrcArr ? undefined : keys(source);

      arrayEach(props || source, function(srcValue, key) {
        if (props) {
          key = srcValue;
          srcValue = source[key];
        }
        if (isObjectLike(srcValue)) {
          stackA || (stackA = []);
          stackB || (stackB = []);
          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
        }
        else {
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;

          if (isCommon) {
            result = srcValue;
          }
          if ((result !== undefined || (isSrcArr && !(key in object))) &&
              (isCommon || (result === result ? (result !== value) : (value === value)))) {
            object[key] = result;
          }
        }
      });
      return object;
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
      var length = stackA.length,
          srcValue = source[key];

      while (length--) {
        if (stackA[length] == srcValue) {
          object[key] = stackB[length];
          return;
        }
      }
      var value = object[key],
          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
          isCommon = result === undefined;

      if (isCommon) {
        result = srcValue;
        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
          result = isArray(value)
            ? value
            : (isArrayLike(value) ? arrayCopy(value) : []);
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          result = isArguments(value)
            ? toPlainObject(value)
            : (isPlainObject(value) ? value : {});
        }
        else {
          isCommon = false;
        }
      }
      // Add the source value to the stack of traversed objects and associate
      // it with its merged value.
      stackA.push(srcValue);
      stackB.push(result);

      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
      } else if (result === result ? (result !== value) : (value === value)) {
        object[key] = result;
      }
    }

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     */
    function basePropertyDeep(path) {
      var pathKey = (path + '');
      path = toPath(path);
      return function(object) {
        return baseGet(object, path, pathKey);
      };
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * index arguments and capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0;
      while (length--) {
        var index = indexes[length];
        if (index != previous && isIndex(index)) {
          var previous = index;
          splice.call(array, index, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for argument juggling
     * and returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns the random number.
     */
    function baseRandom(min, max) {
      return min + nativeFloor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight` without support
     * for callback shorthands and `this` binding, which iterates over `collection`
     * using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initFromCollection Specify using the first or last element
     *  of `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initFromCollection
          ? (initFromCollection = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `setData` without support for hot loop detection.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortBy` which uses `comparer` to define
     * the sort order of `array` and replaces criteria objects with their
     * corresponding values.
     *
     * @private
     * @param {Array} array The array to sort.
     * @param {Function} comparer The function to define sort order.
     * @returns {Array} Returns `array`.
     */
    function baseSortBy(array, comparer) {
      var length = array.length;

      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }

    /**
     * The base implementation of `_.sortByOrder` without param guards.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseSortByOrder(collection, iteratees, orders) {
      var callback = getCallback(),
          index = -1;

      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });

      var result = baseMap(collection, function(value) {
        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.sum` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function baseSum(collection, iteratee) {
      var result = 0;
      baseEach(collection, function(value, index, collection) {
        result += +iteratee(value, index, collection) || 0;
      });
      return result;
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The function invoked per iteration.
     * @returns {Array} Returns the new duplicate-value-free array.
     */
    function baseUniq(array, iteratee) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array.length,
          isCommon = indexOf == baseIndexOf,
          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
          seen = isLarge ? createCache() : null,
          result = [];

      if (seen) {
        indexOf = cacheIndexOf;
        isCommon = false;
      } else {
        isLarge = false;
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value, index, array) : value;

        if (isCommon && value === value) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (indexOf(seen, computed, 0) < 0) {
          if (iteratee || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      var index = -1,
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /**
     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
     * and `_.takeWhile` without support for callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to peform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      var index = -1,
          length = actions.length;

      while (++index < length) {
        var action = actions[index];
        result = action.func.apply(action.thisArg, arrayPush([result], action.args));
      }
      return result;
    }

    /**
     * Performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndex(array, value, retHighest) {
      var low = 0,
          high = array ? array.length : low;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return binaryIndexBy(array, value, identity, retHighest);
    }

    /**
     * This function is like `binaryIndex` except that it invokes `iteratee` for
     * `value` and each element of `array` to compute their sort ranking. The
     * iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array ? array.length : 0,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsUndef = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            isDef = computed !== undefined,
            isReflexive = computed === computed;

        if (valIsNaN) {
          var setLow = isReflexive || retHighest;
        } else if (valIsNull) {
          setLow = isReflexive && isDef && (retHighest || computed != null);
        } else if (valIsUndef) {
          setLow = isReflexive && (retHighest || isDef);
        } else if (computed == null) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * A specialized version of `baseCallback` which only supports `this` binding
     * and specifying the number of arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function bindCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      if (thisArg === undefined) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
        case 5: return function(value, other, key, object, source) {
          return func.call(thisArg, value, other, key, object, source);
        };
      }
      return function() {
        return func.apply(thisArg, arguments);
      };
    }

    /**
     * Creates a clone of the given array buffer.
     *
     * @private
     * @param {ArrayBuffer} buffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function bufferClone(buffer) {
      var result = new ArrayBuffer(buffer.byteLength),
          view = new Uint8Array(result);

      view.set(new Uint8Array(buffer));
      return result;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders) {
      var holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          leftIndex = -1,
          leftLength = partials.length,
          result = Array(leftLength + argsLength);

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
      while (argsLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders) {
      var holdersIndex = -1,
          holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          rightIndex = -1,
          rightLength = partials.length,
          result = Array(argsLength + rightLength);

      while (++argsIndex < argsLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        result[offset + holders[holdersIndex]] = args[argsIndex++];
      }
      return result;
    }

    /**
     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
     *
     * @private
     * @param {Function} setter The function to set keys and values of the accumulator object.
     * @param {Function} [initializer] The function to initialize the accumulator object.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee, thisArg) {
        var result = initializer ? initializer() : {};
        iteratee = getCallback(iteratee, thisArg, 3);

        if (isArray(collection)) {
          var index = -1,
              length = collection.length;

          while (++index < length) {
            var value = collection[index];
            setter(result, value, iteratee(value, index, collection), collection);
          }
        } else {
          baseEach(collection, function(value, key, collection) {
            setter(result, value, iteratee(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return restParam(function(object, sources) {
        var index = -1,
            length = object == null ? 0 : sources.length,
            customizer = length > 2 ? sources[length - 2] : undefined,
            guard = length > 2 ? sources[2] : undefined,
            thisArg = length > 1 ? sources[length - 1] : undefined;

        if (typeof customizer == 'function') {
          customizer = bindCallback(customizer, thisArg, 5);
          length -= 2;
        } else {
          customizer = typeof thisArg == 'function' ? thisArg : undefined;
          length -= (customizer ? 1 : 0);
        }
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        var length = collection ? getLength(collection) : 0;
        if (!isLength(length)) {
          return eachFunc(collection, iteratee);
        }
        var index = fromRight ? length : -1,
            iterable = toObject(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var iterable = toObject(object),
            props = keysFunc(object),
            length = props.length,
            index = fromRight ? length : -1;

        while ((fromRight ? index-- : ++index < length)) {
          var key = props[index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with the `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new bound function.
     */
    function createBindWrapper(func, thisArg) {
      var Ctor = createCtorWrapper(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(thisArg, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a `Set` cache object to optimize linear searches of large arrays.
     *
     * @private
     * @param {Array} [values] The values to cache.
     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
     */
    function createCache(values) {
      return (nativeCreate && Set) ? new SetCache(values) : null;
    }

    /**
     * Creates a function that produces compound words out of the words in a
     * given string.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        var index = -1,
            array = words(deburr(string)),
            length = array.length,
            result = '';

        while (++index < length) {
          result = callback(result, array[index], index);
        }
        return result;
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtorWrapper(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors.
        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a `_.curry` or `_.curryRight` function.
     *
     * @private
     * @param {boolean} flag The curry bit flag.
     * @returns {Function} Returns the new curry function.
     */
    function createCurry(flag) {
      function curryFunc(func, arity, guard) {
        if (guard && isIterateeCall(func, arity, guard)) {
          arity = undefined;
        }
        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
        result.placeholder = curryFunc.placeholder;
        return result;
      }
      return curryFunc;
    }

    /**
     * Creates a `_.defaults` or `_.defaultsDeep` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Function} Returns the new defaults function.
     */
    function createDefaults(assigner, customizer) {
      return restParam(function(args) {
        var object = args[0];
        if (object == null) {
          return object;
        }
        args.push(customizer);
        return assigner.apply(undefined, args);
      });
    }

    /**
     * Creates a `_.max` or `_.min` function.
     *
     * @private
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {Function} Returns the new extremum function.
     */
    function createExtremum(comparator, exValue) {
      return function(collection, iteratee, thisArg) {
        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
          iteratee = undefined;
        }
        iteratee = getCallback(iteratee, thisArg, 3);
        if (iteratee.length == 1) {
          collection = isArray(collection) ? collection : toIterable(collection);
          var result = arrayExtremum(collection, iteratee, comparator, exValue);
          if (!(collection.length && result === exValue)) {
            return result;
          }
        }
        return baseExtremum(collection, iteratee, comparator, exValue);
      };
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFind(eachFunc, fromRight) {
      return function(collection, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        if (isArray(collection)) {
          var index = baseFindIndex(collection, predicate, fromRight);
          return index > -1 ? collection[index] : undefined;
        }
        return baseFind(collection, predicate, eachFunc);
      };
    }

    /**
     * Creates a `_.findIndex` or `_.findLastIndex` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFindIndex(fromRight) {
      return function(array, predicate, thisArg) {
        if (!(array && array.length)) {
          return -1;
        }
        predicate = getCallback(predicate, thisArg, 3);
        return baseFindIndex(array, predicate, fromRight);
      };
    }

    /**
     * Creates a `_.findKey` or `_.findLastKey` function.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new find function.
     */
    function createFindKey(objectFunc) {
      return function(object, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        return baseFind(object, predicate, objectFunc, true);
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return function() {
        var wrapper,
            length = arguments.length,
            index = fromRight ? length : -1,
            leftIndex = 0,
            funcs = Array(length);

        while ((fromRight ? index-- : ++index < length)) {
          var func = funcs[leftIndex++] = arguments[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
            wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? -1 : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      };
    }

    /**
     * Creates a function for `_.forEach` or `_.forEachRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createForEach(arrayFunc, eachFunc) {
      return function(collection, iteratee, thisArg) {
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee)
          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
      };
    }

    /**
     * Creates a function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForIn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee, keysIn);
      };
    }

    /**
     * Creates a function for `_.forOwn` or `_.forOwnRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForOwn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee);
      };
    }

    /**
     * Creates a function for `_.mapKeys` or `_.mapValues`.
     *
     * @private
     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
     * @returns {Function} Returns the new map function.
     */
    function createObjectMapper(isMapKeys) {
      return function(object, iteratee, thisArg) {
        var result = {};
        iteratee = getCallback(iteratee, thisArg, 3);

        baseForOwn(object, function(value, key, object) {
          var mapped = iteratee(value, key, object);
          key = isMapKeys ? mapped : key;
          value = isMapKeys ? value : mapped;
          result[key] = value;
        });
        return result;
      };
    }

    /**
     * Creates a function for `_.padLeft` or `_.padRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify padding from the right.
     * @returns {Function} Returns the new pad function.
     */
    function createPadDir(fromRight) {
      return function(string, length, chars) {
        string = baseToString(string);
        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
      };
    }

    /**
     * Creates a `_.partial` or `_.partialRight` function.
     *
     * @private
     * @param {boolean} flag The partial bit flag.
     * @returns {Function} Returns the new partial function.
     */
    function createPartial(flag) {
      var partialFunc = restParam(function(func, partials) {
        var holders = replaceHolders(partials, partialFunc.placeholder);
        return createWrapper(func, flag, undefined, partials, holders);
      });
      return partialFunc;
    }

    /**
     * Creates a function for `_.reduce` or `_.reduceRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createReduce(arrayFunc, eachFunc) {
      return function(collection, iteratee, accumulator, thisArg) {
        var initFromArray = arguments.length < 3;
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee, accumulator, initFromArray)
          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with optional `this`
     * binding of, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & ARY_FLAG,
          isBind = bitmask & BIND_FLAG,
          isBindKey = bitmask & BIND_KEY_FLAG,
          isCurry = bitmask & CURRY_FLAG,
          isCurryBound = bitmask & CURRY_BOUND_FLAG,
          isCurryRight = bitmask & CURRY_RIGHT_FLAG,
          Ctor = isBindKey ? undefined : createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it to other functions.
        var length = arguments.length,
            index = length,
            args = Array(length);

        while (index--) {
          args[index] = arguments[index];
        }
        if (partials) {
          args = composeArgs(args, partials, holders);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight);
        }
        if (isCurry || isCurryRight) {
          var placeholder = wrapper.placeholder,
              argsHolders = replaceHolders(args, placeholder);

          length -= argsHolders.length;
          if (length < arity) {
            var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                newArity = nativeMax(arity - length, 0),
                newsHolders = isCurry ? argsHolders : undefined,
                newHoldersRight = isCurry ? undefined : argsHolders,
                newPartials = isCurry ? args : undefined,
                newPartialsRight = isCurry ? undefined : args;

            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

            if (!isCurryBound) {
              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
            }
            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                result = createHybridWrapper.apply(undefined, newData);

            if (isLaziable(func)) {
              setData(result, newData);
            }
            result.placeholder = placeholder;
            return result;
          }
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        if (argPos) {
          args = reorder(args, argPos);
        }
        if (isAry && ary < args.length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtorWrapper(func);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates the padding required for `string` based on the given `length`.
     * The `chars` string is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the pad for `string`.
     */
    function createPadding(string, length, chars) {
      var strLength = string.length;
      length = +length;

      if (strLength >= length || !nativeIsFinite(length)) {
        return '';
      }
      var padLength = length - strLength;
      chars = chars == null ? ' ' : (chars + '');
      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
    }

    /**
     * Creates a function that wraps `func` and invokes it with the optional `this`
     * binding of `thisArg` and the `partials` prepended to those provided to
     * the wrapper.
     *
     * @private
     * @param {Function} func The function to partially apply arguments to.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to the new function.
     * @returns {Function} Returns the new bound function.
     */
    function createPartialWrapper(func, bitmask, thisArg, partials) {
      var isBind = bitmask & BIND_FLAG,
          Ctor = createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it `func`.
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength);

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        precision = precision === undefined ? 0 : (+precision || 0);
        if (precision) {
          precision = pow(10, precision);
          return func(number * precision) / precision;
        }
        return func(number);
      };
    }

    /**
     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
     *
     * @private
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {Function} Returns the new index function.
     */
    function createSortedIndex(retHighest) {
      return function(array, value, iteratee, thisArg) {
        var callback = getCallback(iteratee);
        return (iteratee == null && callback === baseCallback)
          ? binaryIndex(array, value, retHighest)
          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      length -= (holders ? holders.length : 0);
      if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func),
          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

      if (data) {
        mergeData(newData, data);
        bitmask = newData[1];
        arity = newData[9];
      }
      newData[9] = arity == null
        ? (isBindKey ? 0 : func.length)
        : (nativeMax(arity - length, 0) || 0);

      if (bitmask == BIND_FLAG) {
        var result = createBindWrapper(newData[0], newData[2]);
      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
        result = createPartialWrapper.apply(undefined, newData);
      } else {
        result = createHybridWrapper.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setter(result, newData);
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing arrays.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var index = -1,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
        return false;
      }
      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index],
            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

        if (result !== undefined) {
          if (result) {
            continue;
          }
          return false;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (isLoose) {
          if (!arraySome(other, function(othValue) {
                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
              })) {
            return false;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag) {
      switch (tag) {
        case boolTag:
        case dateTag:
          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
          return +object == +other;

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case numberTag:
          // Treat `NaN` vs. `NaN` as equal.
          return (object != +object)
            ? other != +other
            : object == +other;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings primitives and string
          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
          return object == (other + '');
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isLoose) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var skipCtor = isLoose;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key],
            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

        // Recursively compare objects (susceptible to call stack limits).
        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
          return false;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (!skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Gets the appropriate "callback" function. If the `_.callback` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseCallback` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function} Returns the chosen function or its result.
     */
    function getCallback(func, thisArg, argCount) {
      var result = lodash.callback || callback;
      result = result === callback ? baseCallback : result;
      return argCount ? result(func, thisArg, argCount) : result;
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = func.name,
          array = realNames[result],
          length = array ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseIndexOf` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function|number} Returns the chosen function or its result.
     */
    function getIndexOf(collection, target, fromIndex) {
      var result = lodash.indexOf || indexOf;
      result = result === indexOf ? baseIndexOf : result;
      return collection ? result(collection, target, fromIndex) : result;
    }

    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
     * that affects Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');

    /**
     * Gets the propery names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = pairs(object),
          length = result.length;

      while (length--) {
        result[length][2] = isStrictComparable(result[length][1]);
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = object == null ? undefined : object[key];
      return isNative(value) ? value : undefined;
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add array properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      var Ctor = object.constructor;
      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
        Ctor = Object;
      }
      return new Ctor;
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return bufferClone(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          var buffer = object.buffer;
          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          var result = new Ctor(object.source, reFlags.exec(object));
          result.lastIndex = object.lastIndex;
      }
      return result;
    }

    /**
     * Invokes the method at `path` on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function invokePath(object, path, args) {
      if (object != null && !isKey(path, object)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        path = last(path);
      }
      var func = object == null ? object : object[path];
      return func == null ? undefined : func.apply(object, args);
    }

    /**
     * Checks if `value` is array-like.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value));
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }

    /**
     * Checks if the provided arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)) {
        var other = object[index];
        return value === value ? (value === other) : (other !== other);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      var type = typeof value;
      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
        return true;
      }
      if (isArray(value)) {
        return false;
      }
      var result = !reIsDeepProp.test(value);
      return result || (object != null && value in toObject(object));
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func);
      if (!(funcName in LazyWrapper.prototype)) {
        return false;
      }
      var other = lodash[funcName];
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     */
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers required to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
     * augment function arguments, making the order in which they are executed important,
     * preventing the merging of metadata. However, we make an exception for a safe
     * common case where curried functions have `_.ary` and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < ARY_FLAG;

      var isCombo =
        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = arrayCopy(value);
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function mergeDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties specified
     * by `props`.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property names to pick.
     * @returns {Object} Returns the new object.
     */
    function pickByArray(object, props) {
      object = toObject(object);

      var index = -1,
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        if (key in object) {
          result[key] = object[key];
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties `predicate`
     * returns truthy for.
     *
     * @private
     * @param {Object} object The source object.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Object} Returns the new object.
     */
    function pickByCallback(object, predicate) {
      var result = {};
      baseForIn(object, function(value, key, object) {
        if (predicate(value, key, object)) {
          result[key] = value;
        }
      });
      return result;
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = arrayCopy(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity function
     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = (function() {
      var count = 0,
          lastCalled = 0;

      return function(key, value) {
        var stamp = now(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return key;
          }
        } else {
          count = 0;
        }
        return baseSetData(key, value);
      };
    }());

    /**
     * A fallback implementation of `Object.keys` which creates an array of the
     * own enumerable property names of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function shimKeys(object) {
      var props = keysIn(object),
          propsLength = props.length,
          length = propsLength && object.length;

      var allowIndexes = !!length && isLength(length) &&
        (isArray(object) || isArguments(object));

      var index = -1,
          result = [];

      while (++index < propsLength) {
        var key = props[index];
        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to an array-like object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array|Object} Returns the array-like object.
     */
    function toIterable(value) {
      if (value == null) {
        return [];
      }
      if (!isArrayLike(value)) {
        return values(value);
      }
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to an object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Object} Returns the object.
     */
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to property path array if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array} Returns the property path array.
     */
    function toPath(value) {
      if (isArray(value)) {
        return value;
      }
      var result = [];
      baseToString(value).replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      return wrapper instanceof LazyWrapper
        ? wrapper.clone()
        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `collection` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new array containing chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size == null) {
        size = 1;
      } else {
        size = nativeMax(nativeFloor(size) || 1, 1);
      }
      var index = 0,
          length = array ? array.length : 0,
          resIndex = -1,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[++resIndex] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * Creates an array of unique `array` values not included in the other
     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3], [4, 2]);
     * // => [1, 3]
     */
    var difference = restParam(function(array, values) {
      return (isObjectLike(array) && isArrayLike(array))
        ? baseDifference(array, baseFlatten(values, false, true))
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that match the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [1]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
     * // => ['barney']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropWhile(users, 'active', false), 'user');
     * // => ['pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8], '*', 1, 2);
     * // => [4, '*', 8]
     */
    function fill(array, value, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(chr) {
     *   return chr.user == 'barney';
     * });
     * // => 0
     *
     * // using the `_.matches` callback shorthand
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findIndex(users, 'active', false);
     * // => 0
     *
     * // using the `_.property` callback shorthand
     * _.findIndex(users, 'active');
     * // => 2
     */
    var findIndex = createFindIndex();

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(chr) {
     *   return chr.user == 'pebbles';
     * });
     * // => 2
     *
     * // using the `_.matches` callback shorthand
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastIndex(users, 'active', false);
     * // => 2
     *
     * // using the `_.property` callback shorthand
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    var findLastIndex = createFindIndex(true);

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias head
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([]);
     * // => undefined
     */
    function first(array) {
      return array ? array[0] : undefined;
    }

    /**
     * Flattens a nested array. If `isDeep` is `true` the array is recursively
     * flattened, otherwise it is only flattened a single level.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, 3, [4]]]);
     * // => [1, 2, 3, [4]]
     *
     * // using `isDeep`
     * _.flatten([1, [2, 3, [4]]], true);
     * // => [1, 2, 3, 4]
     */
    function flatten(array, isDeep, guard) {
      var length = array ? array.length : 0;
      if (guard && isIterateeCall(array, isDeep, guard)) {
        isDeep = false;
      }
      return length ? baseFlatten(array, isDeep) : [];
    }

    /**
     * Recursively flattens a nested array.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to recursively flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, 3, [4]]]);
     * // => [1, 2, 3, 4]
     */
    function flattenDeep(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, true) : [];
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
     * performs a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // using `fromIndex`
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     *
     * // performing a binary search
     * _.indexOf([1, 1, 2, 2], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
      } else if (fromIndex) {
        var index = binaryIndex(array, value);
        if (index < length &&
            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
          return index;
        }
        return -1;
      }
      return baseIndexOf(array, value, fromIndex || 0);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      return dropRight(array, 1);
    }

    /**
     * Creates an array of unique values that are included in all of the provided
     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of shared values.
     * @example
     * _.intersection([1, 2], [4, 2], [2, 1]);
     * // => [2]
     */
    var intersection = restParam(function(arrays) {
      var othLength = arrays.length,
          othIndex = othLength,
          caches = Array(length),
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          result = [];

      while (othIndex--) {
        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
      }
      var array = arrays[0],
          index = -1,
          length = array ? array.length : 0,
          seen = caches[0];

      outer:
      while (++index < length) {
        value = array[index];
        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
          var othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(value);
          }
          result.push(value);
        }
      }
      return result;
    });

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
     *  or `true` to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // using `fromIndex`
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     *
     * // performing a binary search
     * _.lastIndexOf([1, 1, 2, 2], 2, true);
     * // => 3
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      var index = length;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
      } else if (fromIndex) {
        index = binaryIndex(array, value, true) - 1;
        var other = array[index];
        if (value === value ? (value === other) : (other !== other)) {
          return index;
        }
        return -1;
      }
      if (value !== value) {
        return indexOfNaN(array, index, true);
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     *
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull() {
      var args = arguments,
          array = args[0];

      if (!(array && array.length)) {
        return array;
      }
      var index = 0,
          indexOf = getIndexOf(),
          length = args.length;

      while (++index < length) {
        var fromIndex = 0,
            value = args[index];

        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * Removes elements from `array` corresponding to the given indexes and returns
     * an array of the removed elements. Indexes may be specified as an array of
     * indexes or as individual arguments.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [5, 10, 15, 20];
     * var evens = _.pullAt(array, 1, 3);
     *
     * console.log(array);
     * // => [5, 15]
     *
     * console.log(evens);
     * // => [10, 20]
     */
    var pullAt = restParam(function(array, indexes) {
      indexes = baseFlatten(indexes);

      var result = baseAt(array, indexes);
      basePullAt(array, indexes.sort(baseCompareAscending));
      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate, thisArg) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias tail
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     */
    function rest(array) {
      return drop(array, 1);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of `Array#slice` to support node
     * lists in IE < 9 and to ensure dense arrays are returned.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value` should
     * be inserted into `array` in order to maintain its sort order. If an iteratee
     * function is provided it is invoked for `value` and each element of `array`
     * to compute their sort ranking. The iteratee is bound to `thisArg` and
     * invoked with one argument; (value).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     *
     * _.sortedIndex([4, 4, 5, 5], 5);
     * // => 2
     *
     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
     *
     * // using an iteratee function
     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
     *   return this.data[word];
     * }, dict);
     * // => 1
     *
     * // using the `_.property` callback shorthand
     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 1
     */
    var sortedIndex = createSortedIndex();

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 4, 5, 5], 5);
     * // => 4
     */
    var sortedLastIndex = createSortedIndex(true);

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
     * and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [2, 3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
     * // => []
     */
    function takeRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [1, 2]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false},
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeWhile(users, 'active', false), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeWhile(users, 'active'), 'user');
     * // => []
     */
    function takeWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all of the provided arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([1, 2], [4, 2], [2, 1]);
     * // => [1, 2, 4]
     */
    var union = restParam(function(arrays) {
      return baseUniq(baseFlatten(arrays, false, true));
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurence of each element
     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
     * for sorted arrays. If an iteratee function is provided it is invoked for
     * each element in the array to generate the criterion by which uniqueness
     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, array).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {boolean} [isSorted] Specify the array is sorted.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new duplicate-value-free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     *
     * // using `isSorted`
     * _.uniq([1, 1, 2], true);
     * // => [1, 2]
     *
     * // using an iteratee function
     * _.uniq([1, 2.5, 1.5, 2], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => [1, 2.5]
     *
     * // using the `_.property` callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (isSorted != null && typeof isSorted != 'boolean') {
        thisArg = iteratee;
        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
        isSorted = false;
      }
      var callback = getCallback();
      if (!(iteratee == null && callback === baseCallback)) {
        iteratee = callback(iteratee, thisArg, 3);
      }
      return (isSorted && getIndexOf() == baseIndexOf)
        ? sortedUniq(array, iteratee)
        : baseUniq(array, iteratee);
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     *
     * _.unzip(zipped);
     * // => [['fred', 'barney'], [30, 40], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var index = -1,
          length = 0;

      array = arrayFilter(array, function(group) {
        if (isArrayLike(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      var result = Array(length);
      while (++index < length) {
        result[index] = arrayMap(array, baseProperty(index));
      }
      return result;
    }

    /**
     * This method is like `_.unzip` except that it accepts an iteratee to specify
     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee] The function to combine regrouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      iteratee = bindCallback(iteratee, thisArg, 4);
      return arrayMap(result, function(group) {
        return arrayReduce(group, iteratee, undefined, true);
      });
    }

    /**
     * Creates an array excluding all provided values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to filter.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    var without = restParam(function(array, values) {
      return isArrayLike(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the provided arrays.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of values.
     * @example
     *
     * _.xor([1, 2], [4, 2]);
     * // => [1, 4]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArrayLike(array)) {
          var result = result
            ? arrayPush(baseDifference(result, array), baseDifference(array, result))
            : array;
        }
      }
      return result ? baseUniq(result) : [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second elements
     * of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    var zip = restParam(unzip);

    /**
     * The inverse of `_.pairs`; this method returns an object composed from arrays
     * of property names and values. Provide either a single two dimensional array,
     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
     * and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Array
     * @param {Array} props The property names.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject([['fred', 30], ['barney', 40]]);
     * // => { 'fred': 30, 'barney': 40 }
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(props, values) {
      var index = -1,
          length = props ? props.length : 0,
          result = {};

      if (length && !values && !isArray(props[0])) {
        values = [];
      }
      while (++index < length) {
        var key = props[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /**
     * This method is like `_.zip` except that it accepts an iteratee to specify
     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee] The function to combine grouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
     * // => [111, 222]
     */
    var zipWith = restParam(function(arrays) {
      var length = arrays.length,
          iteratee = length > 2 ? arrays[length - 2] : undefined,
          thisArg = length > 1 ? arrays[length - 1] : undefined;

      if (length > 2 && typeof iteratee == 'function') {
        length -= 2;
      } else {
        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
        thisArg = undefined;
      }
      arrays.length = length;
      return unzipWith(arrays, iteratee, thisArg);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps `value` with explicit method
     * chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(users)
     *   .sortBy('age')
     *   .map(function(chr) {
     *     return chr.user + ' is ' + chr.age;
     *   })
     *   .first()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor is
     * bound to `thisArg` and invoked with one argument; (value). The purpose of
     * this method is to "tap into" a method chain in order to perform operations
     * on intermediate results within the chain.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor, thisArg) {
      interceptor.call(thisArg, value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor, thisArg) {
      return interceptor.call(thisArg, value);
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(users).first();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(users).chain()
     *   .first()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chained sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Creates a new array joining a wrapped array with any additional arrays
     * and/or values.
     *
     * @name concat
     * @memberOf _
     * @category Chain
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var wrapped = _(array).concat(2, [3], [[4]]);
     *
     * console.log(wrapped.value());
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    var wrapperConcat = restParam(function(values) {
      values = baseFlatten(values);
      return this.thru(function(array) {
        return arrayConcat(isArray(array) ? array : [toObject(array)], values);
      });
    });

    /**
     * Creates a clone of the chained sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).map(function(value) {
     *   return Math.pow(value, 2);
     * });
     *
     * var other = [3, 4];
     * var otherWrapped = wrapped.plant(other);
     *
     * otherWrapped.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * Reverses the wrapped array so the first element becomes the last, the
     * second element becomes the second to last, and so on.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;

      var interceptor = function(value) {
        return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
      };
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(interceptor);
    }

    /**
     * Produces the result of coercing the unwrapped value to a string.
     *
     * @name toString
     * @memberOf _
     * @category Chain
     * @returns {string} Returns the coerced string value.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return (this.value() + '');
    }

    /**
     * Executes the chained sequence to extract the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @alias run, toJSON, valueOf
     * @category Chain
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements corresponding to the given keys, or indexes,
     * of `collection`. Keys may be specified as individual arguments or as arrays
     * of keys.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [props] The property names
     *  or indexes of elements to pick, specified individually or in arrays.
     * @returns {Array} Returns the new array of picked elements.
     * @example
     *
     * _.at(['a', 'b', 'c'], [0, 2]);
     * // => ['a', 'c']
     *
     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
     * // => ['barney', 'pebbles']
     */
    var at = restParam(function(collection, props) {
      return baseAt(collection, baseFlatten(props));
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the number of times the key was returned by `iteratee`.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * The predicate is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'active': false },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.every(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.filter([4, 5, 6], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [4, 6]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.filter(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.filter(users, 'active'), 'user');
     * // => ['barney']
     */
    function filter(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.result(_.find(users, function(chr) {
     *   return chr.age < 40;
     * }), 'user');
     * // => 'barney'
     *
     * // using the `_.matches` callback shorthand
     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.result(_.find(users, 'active', false), 'user');
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.result(_.find(users, 'active'), 'user');
     * // => 'barney'
     */
    var find = createFind(baseEach);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(baseEachRight, true);

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning the first element that has equivalent property
     * values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
     * // => 'barney'
     *
     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
     * // => 'fred'
     */
    function findWhere(collection, source) {
      return find(collection, baseMatches(source));
    }

    /**
     * Iterates over elements of `collection` invoking `iteratee` for each element.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection). Iteratee functions may exit iteration early
     * by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length" property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEach(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from left to right and returns the array
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
     *   console.log(n, key);
     * });
     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
     */
    var forEach = createForEach(arrayEach, baseEach);

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEachRight(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from right to left and returns the array
     */
    var forEachRight = createForEach(arrayEachRight, baseEachRight);

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using the `_.property` callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });

    /**
     * Checks if `value` is in `collection` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
     * from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @alias contains, include
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {*} target The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.includes('pebbles', 'eb');
     * // => true
     */
    function includes(collection, target, fromIndex, guard) {
      var length = collection ? getLength(collection) : 0;
      if (!isLength(length)) {
        collection = values(collection);
        length = collection.length;
      }
      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
        fromIndex = 0;
      } else {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      }
      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
        : (!!length && getIndexOf(collection, target, fromIndex) > -1);
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the last element responsible for generating the key. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keyData = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keyData, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return String.fromCharCode(object.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return this.fromCharCode(object.code);
     * }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `methodName` is a function it is
     * invoked for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invoke = restParam(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          isProp = isKey(path),
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
      });
      return result;
    });

    /**
     * Creates an array of values by running each element in `collection` through
     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
     * `sum`, `uniq`, and `words`
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function timesThree(n) {
     *   return n * 3;
     * }
     *
     * _.map([1, 2], timesThree);
     * // => [3, 6]
     *
     * _.map({ 'a': 1, 'b': 2 }, timesThree);
     * // => [3, 6] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee, thisArg) {
      var func = isArray(collection) ? arrayMap : baseMap;
      iteratee = getCallback(iteratee, thisArg, 3);
      return func(collection, iteratee);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, while the second of which
     * contains elements `predicate` returns falsey for. The predicate is bound
     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * _.partition([1, 2, 3], function(n) {
     *   return n % 2;
     * });
     * // => [[1, 3], [2]]
     *
     * _.partition([1.2, 2.3, 3.4], function(n) {
     *   return this.floor(n) % 2;
     * }, Math);
     * // => [[1.2, 3.4], [2.3]]
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * var mapper = function(array) {
     *   return _.pluck(array, 'user');
     * };
     *
     * // using the `_.matches` callback shorthand
     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
     * // => [['pebbles'], ['barney', 'fred']]
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.map(_.partition(users, 'active', false), mapper);
     * // => [['barney', 'pebbles'], ['fred']]
     *
     * // using the `_.property` callback shorthand
     * _.map(_.partition(users, 'active'), mapper);
     * // => [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Gets the property value of `path` from all elements in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|string} path The path of the property to pluck.
     * @returns {Array} Returns the property values.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(users, 'user');
     * // => ['barney', 'fred']
     *
     * var userIndex = _.indexBy(users, 'user');
     * _.pluck(userIndex, 'age');
     * // => [36, 40] (iteration order is not guaranteed)
     */
    function pluck(collection, path) {
      return map(collection, property(path));
    }

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` through `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not provided the first element of `collection` is used as the initial
     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
     * and `sortByOrder`
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.reduce([1, 2], function(total, n) {
     *   return total + n;
     * });
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
     */
    var reduce = createReduce(arrayReduce, baseEach);

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    var reduceRight = createReduce(arrayReduceRight, baseEachRight);

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.reject([1, 2, 3, 4], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [1, 3]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.reject(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.reject(users, 'active'), 'user');
     * // => ['barney']
     */
    function reject(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, function(value, index, collection) {
        return !predicate(value, index, collection);
      });
    }

    /**
     * Gets a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {*} Returns the random sample(s).
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
        collection = toIterable(collection);
        var length = collection.length;
        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
      }
      var index = -1,
          result = toArray(collection),
          length = result.length,
          lastIndex = length - 1;

      n = nativeMin(n < 0 ? 0 : (+n || 0), length);
      while (++index < n) {
        var rand = baseRandom(index, lastIndex),
            value = result[rand];

        result[rand] = result[index];
        result[index] = value;
      }
      result.length = n;
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      return sample(collection, POSITIVE_INFINITY);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the size of `collection`.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? getLength(collection) : 0;
      return isLength(length) ? length : keys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * The function returns as soon as it finds a passing value and does not iterate
     * over the entire collection. The predicate is bound to `thisArg` and invoked
     * with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.some(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, thisArg) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through `iteratee`. This method performs
     * a stable sort, that is, it preserves the original sort order of equal elements.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return Math.sin(n);
     * });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return this.sin(n);
     * }, Math);
     * // => [3, 1, 2]
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'pebbles' },
     *   { 'user': 'barney' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.sortBy(users, 'user'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function sortBy(collection, iteratee, thisArg) {
      if (collection == null) {
        return [];
      }
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      var index = -1;
      iteratee = getCallback(iteratee, thisArg, 3);

      var result = baseMap(collection, function(value, key, collection) {
        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
      });
      return baseSortBy(result, compareAscending);
    }

    /**
     * This method is like `_.sortBy` except that it can sort by multiple iteratees
     * or property names.
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
     *  The iteratees to sort by, specified as individual values or arrays of values.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
     *
     * _.map(_.sortByAll(users, 'user', function(chr) {
     *   return Math.floor(chr.age / 10);
     * }), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    var sortByAll = restParam(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var guard = iteratees[2];
      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
        iteratees.length = 1;
      }
      return baseSortByOrder(collection, baseFlatten(iteratees), []);
    });

    /**
     * This method is like `_.sortByAll` except that it allows specifying the
     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
     * values are sorted in ascending order. Otherwise, a value is sorted in
     * ascending order if its corresponding order is "asc", and descending if "desc".
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // sort by `user` in ascending order and by `age` in descending order
     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    function sortByOrder(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (guard && isIterateeCall(iteratees, orders, guard)) {
        orders = undefined;
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseSortByOrder(collection, iteratees, orders);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning an array of all elements that have equivalent
     * property values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
     * // => ['barney']
     *
     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
     * // => ['fred']
     */
    function where(collection, source) {
      return filter(collection, baseMatches(source));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Date
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => logs the number of milliseconds it took for the deferred function to be invoked
     */
    var now = nativeNow || function() {
      return new Date().getTime();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it is called `n` or more times.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'done saving!' after the two async saves have completed
     */
    function after(n, func) {
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      n = nativeIsFinite(n = +n) ? n : 0;
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that accepts up to `n` arguments ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      if (guard && isIterateeCall(func, n, guard)) {
        n = undefined;
      }
      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it is called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery('#add').on('click', _.before(5, addContactToList));
     * // => allows adding up to 4 contacts to the list
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and prepends any additional `_.bind` arguments to those provided to the
     * bound function.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind` this method does not set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // using placeholders
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = restParam(function(func, thisArg, partials) {
      var bitmask = BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bind.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all enumerable function
     * properties, own and inherited, of `object` are bound.
     *
     * **Note:** This method does not set the "length" property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} [methodNames] The object method names to bind,
     *  specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs' when the element is clicked
     */
    var bindAll = restParam(function(object, methodNames) {
      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

      var index = -1,
          length = methodNames.length;

      while (++index < length) {
        var key = methodNames[index];
        object[key] = createWrapper(object[key], BIND_FLAG, object);
      }
      return object;
    });

    /**
     * Creates a function that invokes the method at `object[key]` and prepends
     * any additional `_.bindKey` arguments to those provided to the bound function.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist.
     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // using placeholders
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = restParam(function(object, key, partials) {
      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bindKey.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts one or more arguments of `func` that when
     * called either invokes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` may be specified
     * if `func.length` is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    var curry = createCurry(CURRY_FLAG);

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    var curryRight = createCurry(CURRY_RIGHT_FLAG);

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed invocations. Provide an options object to indicate that `func`
     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
     * Subsequent calls to the debounced function return the result of the last
     * `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify invoking on the leading
     *  edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
     *  delayed before it is invoked.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // ensure `batchLog` is invoked once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }));
     *
     * // cancel a debounced call
     * var todoChanges = _.debounce(batchLog, 1000);
     * Object.observe(models.todo, todoChanges);
     *
     * Object.observe(models, function(changes) {
     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
     *     todoChanges.cancel();
     *   }
     * }, ['delete']);
     *
     * // ...at some point `models.todo` is changed
     * models.todo.completed = true;
     *
     * // ...before 1 second has passed `models.todo` is deleted
     * // which cancels the debounced `todoChanges` call
     * delete models.todo;
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = wait < 0 ? 0 : (+wait || 0);
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = !!options.leading;
        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function cancel() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        lastCalled = 0;
        maxTimeoutId = timeoutId = trailingCall = undefined;
      }

      function complete(isCalled, id) {
        if (id) {
          clearTimeout(id);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (isCalled) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = undefined;
          }
        }
      }

      function delayed() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0 || remaining > wait) {
          complete(trailingCall, maxTimeoutId);
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      }

      function maxDelayed() {
        complete(trailing, timeoutId);
      }

      function debounced() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0 || remaining > maxWait;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = undefined;
        }
        return result;
      }
      debounced.cancel = cancel;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    var defer = restParam(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => logs 'later' after one second
     */
    var delay = restParam(function(func, wait, args) {
      return baseDelay(func, wait, args);
    });

    /**
     * Creates a function that returns the result of invoking the provided
     * functions with the `this` binding of the created function, where each
     * successive invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow(_.add, square);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the provided functions from right to left.
     *
     * @static
     * @memberOf _
     * @alias backflow, compose
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight(square, _.add);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is coerced to a string and used as the
     * cache key. The `func` is invoked with the `this` binding of the memoized
     * function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var upperCase = _.memoize(function(string) {
     *   return string.toUpperCase();
     * });
     *
     * upperCase('fred');
     * // => 'FRED'
     *
     * // modifying the result cache
     * upperCase.cache.set('fred', 'BARNEY');
     * upperCase('fred');
     * // => 'BARNEY'
     *
     * // replacing `_.memoize.Cache`
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'barney' };
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'fred' }
     *
     * _.memoize.Cache = WeakMap;
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'barney' }
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new memoize.Cache;
      return memoized;
    }

    /**
     * Creates a function that runs each argument through a corresponding
     * transform function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms] The functions to transform
     * arguments, specified as individual functions or arrays of functions.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var modded = _.modArgs(function(x, y) {
     *   return [x, y];
     * }, square, doubled);
     *
     * modded(1, 2);
     * // => [1, 4]
     *
     * modded(5, 10);
     * // => [25, 20]
     */
    var modArgs = restParam(function(func, transforms) {
      transforms = baseFlatten(transforms);
      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = transforms.length;
      return restParam(function(args) {
        var index = nativeMin(args.length, length);
        while (index--) {
          args[index] = transforms[index](args[index]);
        }
        return func.apply(this, args);
      });
    });

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        return !predicate.apply(this, arguments);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first call. The `func` is invoked
     * with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` invokes `createApplication` once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with `partial` arguments prepended
     * to those provided to the new function. This method is like `_.bind` except
     * it does **not** alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // using placeholders
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = createPartial(PARTIAL_FLAG);

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to those provided to the new function.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // using placeholders
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified indexes where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     *
     * var map = _.rearg(_.map, [1, 0]);
     * map(function(n) {
     *   return n * 3;
     * }, [1, 2, 3]);
     * // => [3, 6, 9]
     */
    var rearg = restParam(function(func, indexes) {
      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as an array.
     *
     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.restParam(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function restParam(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            rest = Array(length);

        while (++index < length) {
          rest[index] = args[start + index];
        }
        switch (start) {
          case 0: return func.call(this, rest);
          case 1: return func.call(this, args[0], rest);
          case 2: return func.call(this, args[0], args[1], rest);
        }
        var otherArgs = Array(start + 1);
        index = -1;
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = rest;
        return func.apply(this, otherArgs);
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the created
     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
     *
     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * // with a Promise
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function(array) {
        return func.apply(this, array);
      };
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed invocations. Provide an options object to indicate
     * that `func` should be invoked on the leading and/or trailing edge of the
     * `wait` timeout. Subsequent calls to the throttled function return the
     * result of the last `func` call.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify invoking on the leading
     *  edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     *
     * // cancel a trailing throttled call
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Any additional arguments provided to the function are
     * appended to those provided to the wrapper function. The wrapper is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      wrapper = wrapper == null ? identity : wrapper;
      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
     * otherwise they are assigned by reference. If `customizer` is provided it is
     * invoked to produce the cloned values. If `customizer` returns `undefined`
     * cloning is handled by the method instead. The `customizer` is bound to
     * `thisArg` and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var shallow = _.clone(users);
     * shallow[0] === users[0];
     * // => true
     *
     * var deep = _.clone(users, true);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.clone(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, customizer, thisArg) {
      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
        isDeep = false;
      }
      else if (typeof isDeep == 'function') {
        thisArg = customizer;
        customizer = isDeep;
        isDeep = false;
      }
      return typeof customizer == 'function'
        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
        : baseClone(value, isDeep);
    }

    /**
     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
     * to produce the cloned values. If `customizer` returns `undefined` cloning
     * is handled by the method instead. The `customizer` is bound to `thisArg`
     * and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var deep = _.cloneDeep(users);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.cloneDeep(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 20
     */
    function cloneDeep(value, customizer, thisArg) {
      return typeof customizer == 'function'
        ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
        : baseClone(value, true);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    function gt(value, other) {
      return value > other;
    }

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    function gte(value, other) {
      return value >= other;
    }

    /**
     * Checks if `value` is classified as an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return isObjectLike(value) && isArrayLike(value) &&
        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(function() { return arguments; }());
     * // => false
     */
    var isArray = nativeIsArray || function(value) {
      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
    };

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
    }

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    function isDate(value) {
      return isObjectLike(value) && objToString.call(value) == dateTag;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
    }

    /**
     * Checks if `value` is empty. A value is considered empty unless it is an
     * `arguments` object, array, string, or jQuery-like collection with a length
     * greater than `0` or an object with own enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
          (isObjectLike(value) && isFunction(value.splice)))) {
        return !value.length;
      }
      return !keys(value).length;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent. If `customizer` is provided it is invoked to compare values.
     * If `customizer` returns `undefined` comparisons are handled by the method
     * instead. The `customizer` is bound to `thisArg` and invoked with three
     * arguments: (value, other [, index|key]).
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. Functions and DOM nodes
     * are **not** supported. Provide a customizer function to extend support
     * for comparing other values.
     *
     * @static
     * @memberOf _
     * @alias eq
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * object == other;
     * // => false
     *
     * _.isEqual(object, other);
     * // => true
     *
     * // using a customizer callback
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqual(array, other, function(value, other) {
     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
     *     return true;
     *   }
     * });
     * // => true
     */
    function isEqual(value, other, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(10);
     * // => true
     *
     * _.isFinite('10');
     * // => false
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite(Object(10));
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in older versions of Chrome and Safari which return 'function' for regexes
      // and Safari 8 equivalents which return 'object' for typed array constructors.
      return isObject(value) && objToString.call(value) == funcTag;
    }

    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // Avoid a V8 JIT bug in Chrome 19-20.
      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }

    /**
     * Performs a deep comparison between `object` and `source` to determine if
     * `object` contains equivalent property values. If `customizer` is provided
     * it is invoked to compare values. If `customizer` returns `undefined`
     * comparisons are handled by the method instead. The `customizer` is bound
     * to `thisArg` and invoked with three arguments: (value, other, index|key).
     *
     * **Note:** This method supports comparing properties of arrays, booleans,
     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
     * and DOM nodes are **not** supported. Provide a customizer function to extend
     * support for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.isMatch(object, { 'age': 40 });
     * // => true
     *
     * _.isMatch(object, { 'age': 36 });
     * // => false
     *
     * // using a customizer callback
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatch(object, source, function(value, other) {
     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
     * });
     * // => true
     */
    function isMatch(object, source, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      return baseIsMatch(object, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
     * which returns `true` for `undefined` and other non-numeric values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (isFunction(value)) {
        return reIsNative.test(fnToString.call(value));
      }
      return isObjectLike(value) && reIsHostCtor.test(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
     * as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isNumber(8.4);
     * // => true
     *
     * _.isNumber(NaN);
     * // => true
     *
     * _.isNumber('8.4');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * **Note:** This method assumes objects created by the `Object` constructor
     * have no inherited enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      var Ctor;

      // Exit early for non `Object` objects.
      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
        return false;
      }
      // IE < 9 iterates inherited properties before own properties. If the first
      // iterated property is an object's own property then there are no inherited
      // enumerable properties.
      var result;
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      baseForIn(value, function(subValue, key) {
        result = key;
      });
      return result === undefined || hasOwnProperty.call(value, result);
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    function isRegExp(value) {
      return isObject(value) && objToString.call(value) == regexpTag;
    }

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    function lt(value, other) {
      return value < other;
    }

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    function lte(value, other) {
      return value <= other;
    }

    /**
     * Converts `value` to an array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * (function() {
     *   return _.toArray(arguments).slice(1);
     * }(1, 2, 3));
     * // => [2, 3]
     */
    function toArray(value) {
      var length = value ? getLength(value) : 0;
      if (!isLength(length)) {
        return values(value);
      }
      if (!length) {
        return [];
      }
      return arrayCopy(value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable
     * properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return baseCopy(value, keysIn(value));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * overwrite property assignments of previous sources. If `customizer` is
     * provided it is invoked to produce the merged values of the destination and
     * source properties. If `customizer` returns `undefined` merging is handled
     * by the method instead. The `customizer` is bound to `thisArg` and invoked
     * with five arguments: (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
     *
     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
     *
     * _.merge(users, ages);
     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
     *
     * // using a customizer callback
     * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(object, other, function(a, b) {
     *   if (_.isArray(a)) {
     *     return a.concat(b);
     *   }
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
     */
    var merge = createAssigner(baseMerge);

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources overwrite property assignments of previous sources.
     * If `customizer` is provided it is invoked to produce the assigned values.
     * The `customizer` is bound to `thisArg` and invoked with five arguments:
     * (objectValue, sourceValue, key, object, source).
     *
     * **Note:** This method mutates `object` and is based on
     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
     *
     * @static
     * @memberOf _
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using a customizer callback
     * var defaults = _.partialRight(_.assign, function(value, other) {
     *   return _.isUndefined(value) ? other : value;
     * });
     *
     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var assign = createAssigner(function(object, source, customizer) {
      return customizer
        ? assignWith(object, source, customizer)
        : baseAssign(object, source);
    });

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties, guard) {
      var result = baseCreate(prototype);
      if (guard && isIterateeCall(prototype, properties, guard)) {
        properties = undefined;
      }
      return properties ? baseAssign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var defaults = createDefaults(assign, assignDefaults);

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
     * // => { 'user': { 'name': 'barney', 'age': 36 } }
     *
     */
    var defaultsDeep = createDefaults(merge, mergeDefaults);

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // using the `_.matches` callback shorthand
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    var findKey = createFindKey(baseForOwn);

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles` assuming `_.findKey` returns `barney`
     *
     * // using the `_.matches` callback shorthand
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    var findLastKey = createFindKey(baseForOwnRight);

    /**
     * Iterates over own and inherited enumerable properties of an object invoking
     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
     */
    var forIn = createForIn(baseFor);

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
     */
    var forInRight = createForIn(baseForRight);

    /**
     * Iterates over own enumerable properties of an object invoking `iteratee`
     * for each property. The `iteratee` is bound to `thisArg` and invoked with
     * three arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a' and 'b' (iteration order is not guaranteed)
     */
    var forOwn = createForOwn(baseForOwn);

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
     */
    var forOwnRight = createForOwn(baseForOwnRight);

    /**
     * Creates an array of function property names from all enumerable properties,
     * own and inherited, of `object`.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of property names.
     * @example
     *
     * _.functions(_);
     * // => ['after', 'ary', 'assign', ...]
     */
    function functions(object) {
      return baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the property value at `path` of `object`. If the resolved value is
     * `undefined` the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': { 'c': 3 } } };
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b.c');
     * // => true
     *
     * _.has(object, ['a', 'b', 'c']);
     * // => true
     */
    function has(object, path) {
      if (object == null) {
        return false;
      }
      var result = hasOwnProperty.call(object, path);
      if (!result && !isKey(path)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        if (object == null) {
          return false;
        }
        path = last(path);
        result = hasOwnProperty.call(object, path);
      }
      return result || (isLength(object.length) && isIndex(path, object.length) &&
        (isArray(object) || isArguments(object)));
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite property
     * assignments of previous values unless `multiValue` is `true`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to invert.
     * @param {boolean} [multiValue] Allow multiple values per key.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     *
     * // with `multiValue`
     * _.invert(object, true);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function invert(object, multiValue, guard) {
      if (guard && isIterateeCall(object, multiValue, guard)) {
        multiValue = undefined;
      }
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index],
            value = object[key];

        if (multiValue) {
          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }
        else {
          result[value] = key;
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      var Ctor = object == null ? undefined : object.constructor;
      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
          (typeof object != 'function' && isArrayLike(object))) {
        return shimKeys(object);
      }
      return isObject(object) ? nativeKeys(object) : [];
    };

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      if (object == null) {
        return [];
      }
      if (!isObject(object)) {
        object = Object(object);
      }
      var length = object.length;
      length = (length && isLength(length) &&
        (isArray(object) || isArguments(object)) && length) || 0;

      var Ctor = object.constructor,
          index = -1,
          isProto = typeof Ctor == 'function' && Ctor.prototype === object,
          result = Array(length),
          skipIndexes = length > 0;

      while (++index < length) {
        result[index] = (index + '');
      }
      for (var key in object) {
        if (!(skipIndexes && isIndex(key, length)) &&
            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * property of `object` through `iteratee`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    var mapKeys = createObjectMapper(true);

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through `iteratee`. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, key, object).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
     *   return n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * // using the `_.property` callback shorthand
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    var mapValues = createObjectMapper();

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable properties of `object` that are not omitted.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to omit, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.omit(object, 'age');
     * // => { 'user': 'fred' }
     *
     * _.omit(object, _.isNumber);
     * // => { 'user': 'fred' }
     */
    var omit = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      if (typeof props[0] != 'function') {
        var props = arrayMap(baseFlatten(props), String);
        return pickByArray(object, baseDifference(keysIn(object), props));
      }
      var predicate = bindCallback(props[0], props[1], 3);
      return pickByCallback(object, function(value, key, object) {
        return !predicate(value, key, object);
      });
    });

    /**
     * Creates a two dimensional array of the key-value pairs for `object`,
     * e.g. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
     */
    function pairs(object) {
      object = toObject(object);

      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates an object composed of the picked `object` properties. Property
     * names may be specified as individual arguments or as arrays of property
     * names. If `predicate` is provided it is invoked for each property of `object`
     * picking the properties `predicate` returns truthy for. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.pick(object, 'user');
     * // => { 'user': 'fred' }
     *
     * _.pick(object, _.isString);
     * // => { 'user': 'fred' }
     */
    var pick = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      return typeof props[0] == 'function'
        ? pickByCallback(object, bindCallback(props[0], props[1], 3))
        : pickByArray(object, baseFlatten(props));
    });

    /**
     * This method is like `_.get` except that if the resolved value is a function
     * it is invoked with the `this` binding of its parent object and its result
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a.b.c', 'default');
     * // => 'default'
     *
     * _.result(object, 'a.b.c', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      var result = object == null ? undefined : object[path];
      if (result === undefined) {
        if (object != null && !isKey(path, object)) {
          path = toPath(path);
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          result = object == null ? undefined : object[last(path)];
        }
        result = result === undefined ? defaultValue : result;
      }
      return isFunction(result) ? result.call(object) : result;
    }

    /**
     * Sets the property value of `path` on `object`. If a portion of `path`
     * does not exist it is created.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to augment.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, 'x[0].y.z', 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      if (object == null) {
        return object;
      }
      var pathKey = (path + '');
      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = path[index];
        if (isObject(nested)) {
          if (index == lastIndex) {
            nested[key] = value;
          } else if (nested[key] == null) {
            nested[key] = isIndex(path[index + 1]) ? [] : {};
          }
        }
        nested = nested[key];
      }
      return object;
    }

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own enumerable
     * properties through `iteratee`, with each invocation potentially mutating
     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
     * with four arguments: (accumulator, value, key, object). Iteratee functions
     * may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * });
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     */
    function transform(object, iteratee, accumulator, thisArg) {
      var isArr = isArray(object) || isTypedArray(object);
      iteratee = getCallback(iteratee, thisArg, 4);

      if (accumulator == null) {
        if (isArr || isObject(object)) {
          var Ctor = object.constructor;
          if (isArr) {
            accumulator = isArray(object) ? new Ctor : [];
          } else {
            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
          }
        } else {
          accumulator = {};
        }
      }
      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Creates an array of the own enumerable property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable property values
     * of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Checks if `n` is between `start` and up to but not including, `end`. If
     * `end` is not specified it is set to `start` with `start` then set to `0`.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} n The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     */
    function inRange(value, start, end) {
      start = +start || 0;
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      return value >= nativeMin(start, end) && value < nativeMax(start, end);
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number is returned.
     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
     * number is returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      if (floating && isIterateeCall(min, max, floating)) {
        max = floating = undefined;
      }
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (noMax && typeof min == 'boolean') {
          floating = min;
          min = 1;
        }
        else if (typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
        noMax = false;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar');
     * // => 'fooBar'
     *
     * _.camelCase('__foo_bar__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
    });

    /**
     * Capitalizes the first character of `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('fred');
     * // => 'Fred'
     */
    function capitalize(string) {
      string = baseToString(string);
      return string && (string.charAt(0).toUpperCase() + string.slice(1));
    }

    /**
     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = baseToString(string);
      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search from.
     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = baseToString(string);
      target = (target + '');

      var length = string.length;
      position = position === undefined
        ? length
        : nativeMin(position < 0 ? 0 : (+position || 0), length);

      position -= target.length;
      return position >= 0 && string.indexOf(target, position) == position;
    }

    /**
     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
     * their corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional characters
     * use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value.
     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * Backticks are escaped because in Internet Explorer < 9, they can break out
     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
     * for more details.
     *
     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
     * to reduce XSS vectors.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
      string = baseToString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
     */
    function escapeRegExp(string) {
      string = baseToString(string);
      return (string && reHasRegExpChars.test(string))
        ? string.replace(reRegExpChars, escapeRegExpChar)
        : (string || '(?:)');
    }

    /**
     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__foo_bar__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = baseToString(string);
      length = +length;

      var strLength = string.length;
      if (strLength >= length || !nativeIsFinite(length)) {
        return string;
      }
      var mid = (length - strLength) / 2,
          leftLength = nativeFloor(mid),
          rightLength = nativeCeil(mid);

      chars = createPadding('', rightLength, chars);
      return chars.slice(0, leftLength) + string + chars;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padLeft('abc', 6);
     * // => '   abc'
     *
     * _.padLeft('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padLeft('abc', 3);
     * // => 'abc'
     */
    var padLeft = createPadDir();

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padRight('abc', 6);
     * // => 'abc   '
     *
     * _.padRight('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padRight('abc', 3);
     * // => 'abc'
     */
    var padRight = createPadDir(true);

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
     * in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
     * of `parseInt`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
      // Chrome fails to trim leading <BOM> whitespace characters.
      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      string = trim(string);
      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=0] The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n) {
      var result = '';
      string = baseToString(string);
      n = +n;
      if (n < 1 || !string || !nativeIsFinite(n)) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        string += string;
      } while (n);

      return result;
    }

    /**
     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--foo-bar');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__foo_bar__');
     * // => 'Foo Bar'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = baseToString(string);
      position = position == null
        ? 0
        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

      return string.lastIndexOf(target, position) == position;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is provided it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [options.variable] The data object variable name.
     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // using the HTML "escape" delimiter to escape data property values
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // using custom template delimiters
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using backslashes to treat delimiters as plain text
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // using the `imports` option to import `jQuery` as `jq`
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, otherOptions) {
      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
        options = otherOptions = undefined;
      }
      string = baseToString(string);
      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
      }
      chars = (chars + '');
      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimLeft('  abc  ');
     * // => 'abc  '
     *
     * _.trimLeft('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimLeft(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string));
      }
      return string.slice(charsLeftIndex(string, (chars + '')));
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimRight('  abc  ');
     * // => '  abc'
     *
     * _.trimRight('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimRight(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(0, trimmedRightIndex(string) + 1);
      }
      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object|number} [options] The options object or maximum string length.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.trunc('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', 24);
     * // => 'hi-diddly-ho there, n...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function trunc(string, options, guard) {
      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (options != null) {
        if (isObject(options)) {
          var separator = 'separator' in options ? options.separator : separator;
          length = 'length' in options ? (+options.length || 0) : length;
          omission = 'omission' in options ? baseToString(options.omission) : omission;
        } else {
          length = +options || 0;
        }
      }
      string = baseToString(string);
      if (length >= string.length) {
        return string;
      }
      var end = length - omission.length;
      if (end < 1) {
        return omission;
      }
      var result = string.slice(0, end);
      if (separator == null) {
        return result + omission;
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              newEnd,
              substring = string.slice(0, end);

          if (!separator.global) {
            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            newEnd = match.index;
          }
          result = result.slice(0, newEnd == null ? end : newEnd);
        }
      } else if (string.indexOf(separator, end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
     * corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
     * entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = baseToString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      if (guard && isIterateeCall(string, pattern, guard)) {
        pattern = undefined;
      }
      string = baseToString(string);
      return string.match(pattern || reWords) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function} func The function to attempt.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // avoid throwing errors for invalid selectors
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = restParam(function(func, args) {
      try {
        return func.apply(undefined, args);
      } catch(e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and arguments of the created function. If `func` is a property name the
     * created callback returns the property value for a given element. If `func`
     * is an object the created callback returns `true` for elements that contain
     * the equivalent object properties, otherwise it returns `false`.
     *
     * @static
     * @memberOf _
     * @alias iteratee
     * @category Utility
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
     *   if (!match) {
     *     return callback(func, thisArg);
     *   }
     *   return function(object) {
     *     return match[2] == 'gt'
     *       ? object[match[1]] > match[3]
     *       : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(users, 'age__gt36');
     * // => [{ 'user': 'fred', 'age': 40 }]
     */
    function callback(func, thisArg, guard) {
      if (guard && isIterateeCall(func, thisArg, guard)) {
        thisArg = undefined;
      }
      return isObjectLike(func)
        ? matches(func)
        : baseCallback(func, thisArg);
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var getter = _.constant(object);
     *
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that performs a deep comparison between a given object
     * and `source`, returning `true` if the given object has equivalent property
     * values, else `false`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, true));
    }

    /**
     * Creates a function that compares the property value of `path` on a given
     * object to `value`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * _.find(users, _.matchesProperty('user', 'fred'));
     * // => { 'user': 'fred' }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, true));
    }

    /**
     * Creates a function that invokes the method at `path` on a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': _.constant(2) } } },
     *   { 'a': { 'b': { 'c': _.constant(1) } } }
     * ];
     *
     * _.map(objects, _.method('a.b.c'));
     * // => [2, 1]
     *
     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    var method = restParam(function(path, args) {
      return function(object) {
        return invokePath(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path on `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = restParam(function(object, args) {
      return function(path) {
        return invokePath(object, path, args);
      };
    });

    /**
     * Adds all own enumerable function properties of a source object to the
     * destination object. If `object` is a function then methods are added to
     * its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added
     *  are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      if (options == null) {
        var isObj = isObject(source),
            props = isObj ? keys(source) : undefined,
            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

        if (!(methodNames ? methodNames.length : isObj)) {
          methodNames = false;
          options = source;
          source = object;
          object = this;
        }
      }
      if (!methodNames) {
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = true,
          index = -1,
          isFunc = isFunction(object),
          length = methodNames.length;

      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      while (++index < length) {
        var methodName = methodNames[index],
            func = source[methodName];

        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = (function(func) {
            return function() {
              var chainAll = this.__chain__;
              if (chain || chainAll) {
                var result = object(this.__wrapped__),
                    actions = result.__actions__ = arrayCopy(this.__actions__);

                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                result.__chain__ = chainAll;
                return result;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }(func));
        }
      }
      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      root._ = oldDash;
      return this;
    }

    /**
     * A no-operation function that returns `undefined` regardless of the
     * arguments it receives.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that returns the property value at `path` on a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': 2 } } },
     *   { 'a': { 'b': { 'c': 1 } } }
     * ];
     *
     * _.map(objects, _.property('a.b.c'));
     * // => [2, 1]
     *
     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the property value at a given path on `object`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return baseGet(object, toPath(path), path + '');
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. If `end` is not specified it is
     * set to `start` with `start` then set to `0`. If `end` is less than `start`
     * a zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the new array of numbers.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      if (step && isIterateeCall(start, end, step)) {
        end = step = undefined;
      }
      start = +start || 0;
      step = step == null ? 1 : (+step || 0);

      if (end == null) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Invokes the iteratee function `n` times, returning an array of the results
     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
     * one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) {
     *   mage.castSpell(n);
     * });
     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
     *
     * _.times(3, function(n) {
     *   this.cast(n);
     * }, mage);
     * // => also invokes `mage.castSpell(n)` three times
     */
    function times(n, iteratee, thisArg) {
      n = nativeFloor(n);

      // Exit early to avoid a JSC JIT bug in Safari 8
      // where `Array(0)` is treated as `Array(1)`.
      if (n < 1 || !nativeIsFinite(n)) {
        return [];
      }
      var index = -1,
          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

      iteratee = bindCallback(iteratee, thisArg, 1);
      while (++index < n) {
        if (index < MAX_ARRAY_LENGTH) {
          result[index] = iteratee(index);
        } else {
          iteratee(index);
        }
      }
      return result;
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return baseToString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} augend The first number to add.
     * @param {number} addend The second number to add.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    function add(augend, addend) {
      return (+augend || 0) + (+addend || 0);
    }

    /**
     * Calculates `n` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Calculates `n` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Gets the maximum value of `collection`. If `collection` is empty or falsey
     * `-Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => -Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.max(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using the `_.property` callback shorthand
     * _.max(users, 'age');
     * // => { 'user': 'fred', 'age': 40 }
     */
    var max = createExtremum(gt, NEGATIVE_INFINITY);

    /**
     * Gets the minimum value of `collection`. If `collection` is empty or falsey
     * `Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.min(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // using the `_.property` callback shorthand
     * _.min(users, 'age');
     * // => { 'user': 'barney', 'age': 36 }
     */
    var min = createExtremum(lt, POSITIVE_INFINITY);

    /**
     * Calculates `n` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Gets the sum of the values in `collection`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 6]);
     * // => 10
     *
     * _.sum({ 'a': 4, 'b': 6 });
     * // => 10
     *
     * var objects = [
     *   { 'n': 4 },
     *   { 'n': 6 }
     * ];
     *
     * _.sum(objects, function(object) {
     *   return object.n;
     * });
     * // => 10
     *
     * // using the `_.property` callback shorthand
     * _.sum(objects, 'n');
     * // => 10
     */
    function sum(collection, iteratee, thisArg) {
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      iteratee = getCallback(iteratee, thisArg, 3);
      return iteratee.length == 1
        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
        : baseSum(collection, iteratee);
    }

    /*------------------------------------------------------------------------*/

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    // Add functions to the `Map` cache.
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;

    // Add functions to the `Set` cache.
    SetCache.prototype.push = cachePush;

    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;

    // Add functions that return wrapped values when chaining.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.callback = callback;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.modArgs = modArgs;
    lodash.negate = negate;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.restParam = restParam;
    lodash.set = set;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortByAll = sortByAll;
    lodash.sortByOrder = sortByOrder;
    lodash.spread = spread;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.backflow = flowRight;
    lodash.collect = map;
    lodash.compose = flowRight;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.iteratee = callback;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;

    // Add functions to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add functions that return unwrapped values when chaining.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.deburr = deburr;
    lodash.endsWith = endsWith;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.findWhere = findWhere;
    lodash.first = first;
    lodash.floor = floor;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isMatch = isMatch;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.min = min;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padLeft = padLeft;
    lodash.padRight = padRight;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.sum = sum;
    lodash.template = template;
    lodash.trim = trim;
    lodash.trimLeft = trimLeft;
    lodash.trimRight = trimRight;
    lodash.trunc = trunc;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.words = words;

    // Add aliases.
    lodash.all = every;
    lodash.any = some;
    lodash.contains = includes;
    lodash.eq = isEqual;
    lodash.detect = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.head = first;
    lodash.include = includes;
    lodash.inject = reduce;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }()), false);

    /*------------------------------------------------------------------------*/

    // Add functions capable of returning wrapped and unwrapped values when chaining.
    lodash.sample = sample;

    lodash.prototype.sample = function(n) {
      if (!this.__chain__ && n == null) {
        return sample(this.value());
      }
      return this.thru(function(value) {
        return sample(value, n);
      });
    };

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        var filtered = this.__filtered__;
        if (filtered && !index) {
          return new LazyWrapper(this);
        }
        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

        var result = this.clone();
        if (filtered) {
          result.__takeCount__ = nativeMin(result.__takeCount__, n);
        } else {
          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type != LAZY_MAP_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
        var result = this.clone();
        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.first` and `_.last`.
    arrayEach(['first', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
    arrayEach(['initial', 'rest'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
    arrayEach(['pluck', 'where'], function(methodName, index) {
      var operationName = index ? 'filter' : 'map',
          createCallback = index ? baseMatches : property;

      LazyWrapper.prototype[methodName] = function(value) {
        return this[operationName](createCallback(value));
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.reject = function(predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 1);
      return this.filter(function(value) {
        return !predicate(value);
      });
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = start == null ? 0 : (+start || 0);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = (+end || 0);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
      return this.reverse().takeWhile(predicate, thisArg).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(POSITIVE_INFINITY);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
          retUnwrapped = /^(?:first|last)$/.test(methodName),
          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var args = retUnwrapped ? [1] : arguments,
            chainAll = this.__chain__,
            value = this.__wrapped__,
            isHybrid = !!this.__actions__.length,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var interceptor = function(value) {
          return (retUnwrapped && chainAll)
            ? lodashFunc(value, 1)[0]
            : lodashFunc.apply(undefined, arrayPush([value], args));
        };

        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
            onlyLazy = isLazy && !isHybrid;

        if (retUnwrapped && !chainAll) {
          if (onlyLazy) {
            value = value.clone();
            value.__actions__.push(action);
            return func.call(value);
          }
          return lodashFunc.call(undefined, this.value())[0];
        }
        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push(action);
          return new LodashWrapper(result, chainAll);
        }
        return this.thru(interceptor);
      };
    });

    // Add `Array` and `String` methods to `lodash.prototype`.
    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          return func.apply(this.value(), args);
        }
        return this[chainName](function(value) {
          return func.apply(value, args);
        });
      };
    });

    // Map minified function names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name,
            names = realNames[key] || (realNames[key] = []);

        names.push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];

    // Add functions to the lazy wrapper.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chaining functions to the `lodash` wrapper.
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.concat = wrapperConcat;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add function aliases to the `lodash` wrapper.
    lodash.prototype.collect = lodash.prototype.map;
    lodash.prototype.head = lodash.prototype.first;
    lodash.prototype.select = lodash.prototype.filter;
    lodash.prototype.tail = lodash.prototype.rest;

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose lodash to the global object when an AMD loader is present to avoid
    // errors in cases where lodash is loaded by a script tag and not intended
    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
    // more details.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
    // Export for Node.js or RingoJS.
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // Export for Rhino with CommonJS support.
    else {
      freeExports._ = _;
    }
  }
  else {
    // Export for a browser or Rhino.
    root._ = _;
  }
}.call(this));

},{}],"../node_modules/graphlib-dot/node_modules/graphlib/lib/lodash.js":[function(require,module,exports) {
/* global window */

var lodash;

if (typeof require === "function") {
  try {
    lodash = require("lodash");
  } catch (e) {}
}

if (!lodash) {
  lodash = window._;
}

module.exports = lodash;

},{"lodash":"../node_modules/graphlib-dot/node_modules/graphlib/node_modules/lodash/index.js"}],"../node_modules/graphlib-dot/node_modules/graphlib/lib/graph.js":[function(require,module,exports) {
"use strict";

var _ = require("./lodash");

module.exports = Graph;

var DEFAULT_EDGE_NAME = "\x00",
    GRAPH_NODE = "\x00",
    EDGE_KEY_DELIM = "\x01";

// Implementation notes:
//
//  * Node id query functions should return string ids for the nodes
//  * Edge id query functions should return an "edgeObj", edge object, that is
//    composed of enough information to uniquely identify an edge: {v, w, name}.
//  * Internally we use an "edgeId", a stringified form of the edgeObj, to
//    reference edges. This is because we need a performant way to look these
//    edges up and, object properties, which have string keys, are the closest
//    we're going to get to a performant hashtable in JavaScript.

function Graph(opts) {
  this._isDirected = _.has(opts, "directed") ? opts.directed : true;
  this._isMultigraph = _.has(opts, "multigraph") ? opts.multigraph : false;
  this._isCompound = _.has(opts, "compound") ? opts.compound : false;

  // Label for the graph itself
  this._label = undefined;

  // Defaults to be set when creating a new node
  this._defaultNodeLabelFn = _.constant(undefined);

  // Defaults to be set when creating a new edge
  this._defaultEdgeLabelFn = _.constant(undefined);

  // v -> label
  this._nodes = {};

  if (this._isCompound) {
    // v -> parent
    this._parent = {};

    // v -> children
    this._children = {};
    this._children[GRAPH_NODE] = {};
  }

  // v -> edgeObj
  this._in = {};

  // u -> v -> Number
  this._preds = {};

  // v -> edgeObj
  this._out = {};

  // v -> w -> Number
  this._sucs = {};

  // e -> edgeObj
  this._edgeObjs = {};

  // e -> label
  this._edgeLabels = {};
}

/* Number of nodes in the graph. Should only be changed by the implementation. */
Graph.prototype._nodeCount = 0;

/* Number of edges in the graph. Should only be changed by the implementation. */
Graph.prototype._edgeCount = 0;


/* === Graph functions ========= */

Graph.prototype.isDirected = function() {
  return this._isDirected;
};

Graph.prototype.isMultigraph = function() {
  return this._isMultigraph;
};

Graph.prototype.isCompound = function() {
  return this._isCompound;
};

Graph.prototype.setGraph = function(label) {
  this._label = label;
  return this;
};

Graph.prototype.graph = function() {
  return this._label;
};


/* === Node functions ========== */

Graph.prototype.setDefaultNodeLabel = function(newDefault) {
  if (!_.isFunction(newDefault)) {
    newDefault = _.constant(newDefault);
  }
  this._defaultNodeLabelFn = newDefault;
  return this;
};

Graph.prototype.nodeCount = function() {
  return this._nodeCount;
};

Graph.prototype.nodes = function() {
  return _.keys(this._nodes);
};

Graph.prototype.sources = function() {
  return _.filter(this.nodes(), function(v) {
    return _.isEmpty(this._in[v]);
  }, this);
};

Graph.prototype.sinks = function() {
  return _.filter(this.nodes(), function(v) {
    return _.isEmpty(this._out[v]);
  }, this);
};

Graph.prototype.setNodes = function(vs, value) {
  var args = arguments;
  _.each(vs, function(v) {
    if (args.length > 1) {
      this.setNode(v, value);
    } else {
      this.setNode(v);
    }
  }, this);
  return this;
};

Graph.prototype.setNode = function(v, value) {
  if (_.has(this._nodes, v)) {
    if (arguments.length > 1) {
      this._nodes[v] = value;
    }
    return this;
  }

  this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
  if (this._isCompound) {
    this._parent[v] = GRAPH_NODE;
    this._children[v] = {};
    this._children[GRAPH_NODE][v] = true;
  }
  this._in[v] = {};
  this._preds[v] = {};
  this._out[v] = {};
  this._sucs[v] = {};
  ++this._nodeCount;
  return this;
};

Graph.prototype.node = function(v) {
  return this._nodes[v];
};

Graph.prototype.hasNode = function(v) {
  return _.has(this._nodes, v);
};

Graph.prototype.removeNode =  function(v) {
  var self = this;
  if (_.has(this._nodes, v)) {
    var removeEdge = function(e) { self.removeEdge(self._edgeObjs[e]); };
    delete this._nodes[v];
    if (this._isCompound) {
      this._removeFromParentsChildList(v);
      delete this._parent[v];
      _.each(this.children(v), function(child) {
        this.setParent(child);
      }, this);
      delete this._children[v];
    }
    _.each(_.keys(this._in[v]), removeEdge);
    delete this._in[v];
    delete this._preds[v];
    _.each(_.keys(this._out[v]), removeEdge);
    delete this._out[v];
    delete this._sucs[v];
    --this._nodeCount;
  }
  return this;
};

Graph.prototype.setParent = function(v, parent) {
  if (!this._isCompound) {
    throw new Error("Cannot set parent in a non-compound graph");
  }

  if (_.isUndefined(parent)) {
    parent = GRAPH_NODE;
  } else {
    // Coerce parent to string
    parent += "";
    for (var ancestor = parent;
         !_.isUndefined(ancestor);
         ancestor = this.parent(ancestor)) {
      if (ancestor === v) {
        throw new Error("Setting " + parent+ " as parent of " + v +
                        " would create create a cycle");
      }
    }

    this.setNode(parent);
  }

  this.setNode(v);
  this._removeFromParentsChildList(v);
  this._parent[v] = parent;
  this._children[parent][v] = true;
  return this;
};

Graph.prototype._removeFromParentsChildList = function(v) {
  delete this._children[this._parent[v]][v];
};

Graph.prototype.parent = function(v) {
  if (this._isCompound) {
    var parent = this._parent[v];
    if (parent !== GRAPH_NODE) {
      return parent;
    }
  }
};

Graph.prototype.children = function(v) {
  if (_.isUndefined(v)) {
    v = GRAPH_NODE;
  }

  if (this._isCompound) {
    var children = this._children[v];
    if (children) {
      return _.keys(children);
    }
  } else if (v === GRAPH_NODE) {
    return this.nodes();
  } else if (this.hasNode(v)) {
    return [];
  }
};

Graph.prototype.predecessors = function(v) {
  var predsV = this._preds[v];
  if (predsV) {
    return _.keys(predsV);
  }
};

Graph.prototype.successors = function(v) {
  var sucsV = this._sucs[v];
  if (sucsV) {
    return _.keys(sucsV);
  }
};

Graph.prototype.neighbors = function(v) {
  var preds = this.predecessors(v);
  if (preds) {
    return _.union(preds, this.successors(v));
  }
};

Graph.prototype.filterNodes = function(filter) {
  var copy = new this.constructor({
    directed: this._isDirected,
    multigraph: this._isMultigraph,
    compound: this._isCompound
  });

  copy.setGraph(this.graph());

  _.each(this._nodes, function(value, v) {
    if (filter(v)) {
      copy.setNode(v, value);
    }
  }, this);

  _.each(this._edgeObjs, function(e) {
    if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
      copy.setEdge(e, this.edge(e));
    }
  }, this);

  var self = this;
  var parents = {};
  function findParent(v) {
    var parent = self.parent(v);
    if (parent === undefined || copy.hasNode(parent)) {
      parents[v] = parent;
      return parent;
    } else if (parent in parents) {
      return parents[parent];
    } else {
      return findParent(parent);
    }
  }

  if (this._isCompound) {
    _.each(copy.nodes(), function(v) {
      copy.setParent(v, findParent(v));
    });
  }

  return copy;
};

/* === Edge functions ========== */

Graph.prototype.setDefaultEdgeLabel = function(newDefault) {
  if (!_.isFunction(newDefault)) {
    newDefault = _.constant(newDefault);
  }
  this._defaultEdgeLabelFn = newDefault;
  return this;
};

Graph.prototype.edgeCount = function() {
  return this._edgeCount;
};

Graph.prototype.edges = function() {
  return _.values(this._edgeObjs);
};

Graph.prototype.setPath = function(vs, value) {
  var self = this,
      args = arguments;
  _.reduce(vs, function(v, w) {
    if (args.length > 1) {
      self.setEdge(v, w, value);
    } else {
      self.setEdge(v, w);
    }
    return w;
  });
  return this;
};

/*
 * setEdge(v, w, [value, [name]])
 * setEdge({ v, w, [name] }, [value])
 */
Graph.prototype.setEdge = function() {
  var v, w, name, value,
      valueSpecified = false,
      arg0 = arguments[0];

  if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
    v = arg0.v;
    w = arg0.w;
    name = arg0.name;
    if (arguments.length === 2) {
      value = arguments[1];
      valueSpecified = true;
    }
  } else {
    v = arg0;
    w = arguments[1];
    name = arguments[3];
    if (arguments.length > 2) {
      value = arguments[2];
      valueSpecified = true;
    }
  }

  v = "" + v;
  w = "" + w;
  if (!_.isUndefined(name)) {
    name = "" + name;
  }

  var e = edgeArgsToId(this._isDirected, v, w, name);
  if (_.has(this._edgeLabels, e)) {
    if (valueSpecified) {
      this._edgeLabels[e] = value;
    }
    return this;
  }

  if (!_.isUndefined(name) && !this._isMultigraph) {
    throw new Error("Cannot set a named edge when isMultigraph = false");
  }

  // It didn't exist, so we need to create it.
  // First ensure the nodes exist.
  this.setNode(v);
  this.setNode(w);

  this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);

  var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);
  // Ensure we add undirected edges in a consistent way.
  v = edgeObj.v;
  w = edgeObj.w;

  Object.freeze(edgeObj);
  this._edgeObjs[e] = edgeObj;
  incrementOrInitEntry(this._preds[w], v);
  incrementOrInitEntry(this._sucs[v], w);
  this._in[w][e] = edgeObj;
  this._out[v][e] = edgeObj;
  this._edgeCount++;
  return this;
};

Graph.prototype.edge = function(v, w, name) {
  var e = (arguments.length === 1
            ? edgeObjToId(this._isDirected, arguments[0])
            : edgeArgsToId(this._isDirected, v, w, name));
  return this._edgeLabels[e];
};

Graph.prototype.hasEdge = function(v, w, name) {
  var e = (arguments.length === 1
            ? edgeObjToId(this._isDirected, arguments[0])
            : edgeArgsToId(this._isDirected, v, w, name));
  return _.has(this._edgeLabels, e);
};

Graph.prototype.removeEdge = function(v, w, name) {
  var e = (arguments.length === 1
            ? edgeObjToId(this._isDirected, arguments[0])
            : edgeArgsToId(this._isDirected, v, w, name)),
      edge = this._edgeObjs[e];
  if (edge) {
    v = edge.v;
    w = edge.w;
    delete this._edgeLabels[e];
    delete this._edgeObjs[e];
    decrementOrRemoveEntry(this._preds[w], v);
    decrementOrRemoveEntry(this._sucs[v], w);
    delete this._in[w][e];
    delete this._out[v][e];
    this._edgeCount--;
  }
  return this;
};

Graph.prototype.inEdges = function(v, u) {
  var inV = this._in[v];
  if (inV) {
    var edges = _.values(inV);
    if (!u) {
      return edges;
    }
    return _.filter(edges, function(edge) { return edge.v === u; });
  }
};

Graph.prototype.outEdges = function(v, w) {
  var outV = this._out[v];
  if (outV) {
    var edges = _.values(outV);
    if (!w) {
      return edges;
    }
    return _.filter(edges, function(edge) { return edge.w === w; });
  }
};

Graph.prototype.nodeEdges = function(v, w) {
  var inEdges = this.inEdges(v, w);
  if (inEdges) {
    return inEdges.concat(this.outEdges(v, w));
  }
};

function incrementOrInitEntry(map, k) {
  if (map[k]) {
    map[k]++;
  } else {
    map[k] = 1;
  }
}

function decrementOrRemoveEntry(map, k) {
  if (!--map[k]) { delete map[k]; }
}

function edgeArgsToId(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;
  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM +
             (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
}

function edgeArgsToObj(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;
  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  var edgeObj =  { v: v, w: w };
  if (name) {
    edgeObj.name = name;
  }
  return edgeObj;
}

function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}

},{"./lodash":"../node_modules/graphlib-dot/node_modules/graphlib/lib/lodash.js"}],"../node_modules/graphlib-dot/node_modules/graphlib/lib/version.js":[function(require,module,exports) {
module.exports = '1.0.7';

},{}],"../node_modules/graphlib-dot/node_modules/graphlib/lib/index.js":[function(require,module,exports) {
// Includes only the "core" of graphlib
module.exports = {
  Graph: require("./graph"),
  version: require("./version")
};

},{"./graph":"../node_modules/graphlib-dot/node_modules/graphlib/lib/graph.js","./version":"../node_modules/graphlib-dot/node_modules/graphlib/lib/version.js"}],"../node_modules/graphlib-dot/node_modules/graphlib/lib/json.js":[function(require,module,exports) {
var _ = require("./lodash"),
    Graph = require("./graph");

module.exports = {
  write: write,
  read: read
};

function write(g) {
  var json = {
    options: {
      directed: g.isDirected(),
      multigraph: g.isMultigraph(),
      compound: g.isCompound()
    },
    nodes: writeNodes(g),
    edges: writeEdges(g)
  };
  if (!_.isUndefined(g.graph())) {
    json.value = _.clone(g.graph());
  }
  return json;
}

function writeNodes(g) {
  return _.map(g.nodes(), function(v) {
    var nodeValue = g.node(v),
        parent = g.parent(v),
        node = { v: v };
    if (!_.isUndefined(nodeValue)) {
      node.value = nodeValue;
    }
    if (!_.isUndefined(parent)) {
      node.parent = parent;
    }
    return node;
  });
}

function writeEdges(g) {
  return _.map(g.edges(), function(e) {
    var edgeValue = g.edge(e),
        edge = { v: e.v, w: e.w };
    if (!_.isUndefined(e.name)) {
      edge.name = e.name;
    }
    if (!_.isUndefined(edgeValue)) {
      edge.value = edgeValue;
    }
    return edge;
  });
}

function read(json) {
  var g = new Graph(json.options).setGraph(json.value);
  _.each(json.nodes, function(entry) {
    g.setNode(entry.v, entry.value);
    if (entry.parent) {
      g.setParent(entry.v, entry.parent);
    }
  });
  _.each(json.edges, function(entry) {
    g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
  });
  return g;
}

},{"./lodash":"../node_modules/graphlib-dot/node_modules/graphlib/lib/lodash.js","./graph":"../node_modules/graphlib-dot/node_modules/graphlib/lib/graph.js"}],"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/components.js":[function(require,module,exports) {
var _ = require("../lodash");

module.exports = components;

function components(g) {
  var visited = {},
      cmpts = [],
      cmpt;

  function dfs(v) {
    if (_.has(visited, v)) return;
    visited[v] = true;
    cmpt.push(v);
    _.each(g.successors(v), dfs);
    _.each(g.predecessors(v), dfs);
  }

  _.each(g.nodes(), function(v) {
    cmpt = [];
    dfs(v);
    if (cmpt.length) {
      cmpts.push(cmpt);
    }
  });

  return cmpts;
}

},{"../lodash":"../node_modules/graphlib-dot/node_modules/graphlib/lib/lodash.js"}],"../node_modules/graphlib-dot/node_modules/graphlib/lib/data/priority-queue.js":[function(require,module,exports) {
var _ = require("../lodash");

module.exports = PriorityQueue;

/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., "Introduction to Algorithms". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */
function PriorityQueue() {
  this._arr = [];
  this._keyIndices = {};
}

/**
 * Returns the number of elements in the queue. Takes `O(1)` time.
 */
PriorityQueue.prototype.size = function() {
  return this._arr.length;
};

/**
 * Returns the keys that are in the queue. Takes `O(n)` time.
 */
PriorityQueue.prototype.keys = function() {
  return this._arr.map(function(x) { return x.key; });
};

/**
 * Returns `true` if **key** is in the queue and `false` if not.
 */
PriorityQueue.prototype.has = function(key) {
  return _.has(this._keyIndices, key);
};

/**
 * Returns the priority for **key**. If **key** is not present in the queue
 * then this function returns `undefined`. Takes `O(1)` time.
 *
 * @param {Object} key
 */
PriorityQueue.prototype.priority = function(key) {
  var index = this._keyIndices[key];
  if (index !== undefined) {
    return this._arr[index].priority;
  }
};

/**
 * Returns the key for the minimum element in this queue. If the queue is
 * empty this function throws an Error. Takes `O(1)` time.
 */
PriorityQueue.prototype.min = function() {
  if (this.size() === 0) {
    throw new Error("Queue underflow");
  }
  return this._arr[0].key;
};

/**
 * Inserts a new key into the priority queue. If the key already exists in
 * the queue this function returns `false`; otherwise it will return `true`.
 * Takes `O(n)` time.
 *
 * @param {Object} key the key to add
 * @param {Number} priority the initial priority for the key
 */
PriorityQueue.prototype.add = function(key, priority) {
  var keyIndices = this._keyIndices;
  key = String(key);
  if (!_.has(keyIndices, key)) {
    var arr = this._arr;
    var index = arr.length;
    keyIndices[key] = index;
    arr.push({key: key, priority: priority});
    this._decrease(index);
    return true;
  }
  return false;
};

/**
 * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
 */
PriorityQueue.prototype.removeMin = function() {
  this._swap(0, this._arr.length - 1);
  var min = this._arr.pop();
  delete this._keyIndices[min.key];
  this._heapify(0);
  return min.key;
};

/**
 * Decreases the priority for **key** to **priority**. If the new priority is
 * greater than the previous priority, this function will throw an Error.
 *
 * @param {Object} key the key for which to raise priority
 * @param {Number} priority the new priority for the key
 */
PriorityQueue.prototype.decrease = function(key, priority) {
  var index = this._keyIndices[key];
  if (priority > this._arr[index].priority) {
    throw new Error("New priority is greater than current priority. " +
        "Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
  }
  this._arr[index].priority = priority;
  this._decrease(index);
};

PriorityQueue.prototype._heapify = function(i) {
  var arr = this._arr;
  var l = 2 * i,
      r = l + 1,
      largest = i;
  if (l < arr.length) {
    largest = arr[l].priority < arr[largest].priority ? l : largest;
    if (r < arr.length) {
      largest = arr[r].priority < arr[largest].priority ? r : largest;
    }
    if (largest !== i) {
      this._swap(i, largest);
      this._heapify(largest);
    }
  }
};

PriorityQueue.prototype._decrease = function(index) {
  var arr = this._arr;
  var priority = arr[index].priority;
  var parent;
  while (index !== 0) {
    parent = index >> 1;
    if (arr[parent].priority < priority) {
      break;
    }
    this._swap(index, parent);
    index = parent;
  }
};

PriorityQueue.prototype._swap = function(i, j) {
  var arr = this._arr;
  var keyIndices = this._keyIndices;
  var origArrI = arr[i];
  var origArrJ = arr[j];
  arr[i] = origArrJ;
  arr[j] = origArrI;
  keyIndices[origArrJ.key] = i;
  keyIndices[origArrI.key] = j;
};

},{"../lodash":"../node_modules/graphlib-dot/node_modules/graphlib/lib/lodash.js"}],"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/dijkstra.js":[function(require,module,exports) {
var _ = require("../lodash"),
    PriorityQueue = require("../data/priority-queue");

module.exports = dijkstra;

var DEFAULT_WEIGHT_FUNC = _.constant(1);

function dijkstra(g, source, weightFn, edgeFn) {
  return runDijkstra(g, String(source),
                     weightFn || DEFAULT_WEIGHT_FUNC,
                     edgeFn || function(v) { return g.outEdges(v); });
}

function runDijkstra(g, source, weightFn, edgeFn) {
  var results = {},
      pq = new PriorityQueue(),
      v, vEntry;

  var updateNeighbors = function(edge) {
    var w = edge.v !== v ? edge.v : edge.w,
        wEntry = results[w],
        weight = weightFn(edge),
        distance = vEntry.distance + weight;

    if (weight < 0) {
      throw new Error("dijkstra does not allow negative edge weights. " +
                      "Bad edge: " + edge + " Weight: " + weight);
    }

    if (distance < wEntry.distance) {
      wEntry.distance = distance;
      wEntry.predecessor = v;
      pq.decrease(w, distance);
    }
  };

  g.nodes().forEach(function(v) {
    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;
    results[v] = { distance: distance };
    pq.add(v, distance);
  });

  while (pq.size() > 0) {
    v = pq.removeMin();
    vEntry = results[v];
    if (vEntry.distance === Number.POSITIVE_INFINITY) {
      break;
    }

    edgeFn(v).forEach(updateNeighbors);
  }

  return results;
}

},{"../lodash":"../node_modules/graphlib-dot/node_modules/graphlib/lib/lodash.js","../data/priority-queue":"../node_modules/graphlib-dot/node_modules/graphlib/lib/data/priority-queue.js"}],"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/dijkstra-all.js":[function(require,module,exports) {
var dijkstra = require("./dijkstra"),
    _ = require("../lodash");

module.exports = dijkstraAll;

function dijkstraAll(g, weightFunc, edgeFunc) {
  return _.transform(g.nodes(), function(acc, v) {
    acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
  }, {});
}

},{"./dijkstra":"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/dijkstra.js","../lodash":"../node_modules/graphlib-dot/node_modules/graphlib/lib/lodash.js"}],"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/tarjan.js":[function(require,module,exports) {
var _ = require("../lodash");

module.exports = tarjan;

function tarjan(g) {
  var index = 0,
      stack = [],
      visited = {}, // node id -> { onStack, lowlink, index }
      results = [];

  function dfs(v) {
    var entry = visited[v] = {
      onStack: true,
      lowlink: index,
      index: index++
    };
    stack.push(v);

    g.successors(v).forEach(function(w) {
      if (!_.has(visited, w)) {
        dfs(w);
        entry.lowlink = Math.min(entry.lowlink, visited[w].lowlink);
      } else if (visited[w].onStack) {
        entry.lowlink = Math.min(entry.lowlink, visited[w].index);
      }
    });

    if (entry.lowlink === entry.index) {
      var cmpt = [],
          w;
      do {
        w = stack.pop();
        visited[w].onStack = false;
        cmpt.push(w);
      } while (v !== w);
      results.push(cmpt);
    }
  }

  g.nodes().forEach(function(v) {
    if (!_.has(visited, v)) {
      dfs(v);
    }
  });

  return results;
}

},{"../lodash":"../node_modules/graphlib-dot/node_modules/graphlib/lib/lodash.js"}],"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/find-cycles.js":[function(require,module,exports) {
var _ = require("../lodash"),
    tarjan = require("./tarjan");

module.exports = findCycles;

function findCycles(g) {
  return _.filter(tarjan(g), function(cmpt) {
    return cmpt.length > 1 || (cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]));
  });
}

},{"../lodash":"../node_modules/graphlib-dot/node_modules/graphlib/lib/lodash.js","./tarjan":"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/tarjan.js"}],"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/floyd-warshall.js":[function(require,module,exports) {
var _ = require("../lodash");

module.exports = floydWarshall;

var DEFAULT_WEIGHT_FUNC = _.constant(1);

function floydWarshall(g, weightFn, edgeFn) {
  return runFloydWarshall(g,
                          weightFn || DEFAULT_WEIGHT_FUNC,
                          edgeFn || function(v) { return g.outEdges(v); });
}

function runFloydWarshall(g, weightFn, edgeFn) {
  var results = {},
      nodes = g.nodes();

  nodes.forEach(function(v) {
    results[v] = {};
    results[v][v] = { distance: 0 };
    nodes.forEach(function(w) {
      if (v !== w) {
        results[v][w] = { distance: Number.POSITIVE_INFINITY };
      }
    });
    edgeFn(v).forEach(function(edge) {
      var w = edge.v === v ? edge.w : edge.v,
          d = weightFn(edge);
      results[v][w] = { distance: d, predecessor: v };
    });
  });

  nodes.forEach(function(k) {
    var rowK = results[k];
    nodes.forEach(function(i) {
      var rowI = results[i];
      nodes.forEach(function(j) {
        var ik = rowI[k];
        var kj = rowK[j];
        var ij = rowI[j];
        var altDistance = ik.distance + kj.distance;
        if (altDistance < ij.distance) {
          ij.distance = altDistance;
          ij.predecessor = kj.predecessor;
        }
      });
    });
  });

  return results;
}

},{"../lodash":"../node_modules/graphlib-dot/node_modules/graphlib/lib/lodash.js"}],"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/topsort.js":[function(require,module,exports) {
var _ = require("../lodash");

module.exports = topsort;
topsort.CycleException = CycleException;

function topsort(g) {
  var visited = {},
      stack = {},
      results = [];

  function visit(node) {
    if (_.has(stack, node)) {
      throw new CycleException();
    }

    if (!_.has(visited, node)) {
      stack[node] = true;
      visited[node] = true;
      _.each(g.predecessors(node), visit);
      delete stack[node];
      results.push(node);
    }
  }

  _.each(g.sinks(), visit);

  if (_.size(visited) !== g.nodeCount()) {
    throw new CycleException();
  }

  return results;
}

function CycleException() {}

},{"../lodash":"../node_modules/graphlib-dot/node_modules/graphlib/lib/lodash.js"}],"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/is-acyclic.js":[function(require,module,exports) {
var topsort = require("./topsort");

module.exports = isAcyclic;

function isAcyclic(g) {
  try {
    topsort(g);
  } catch (e) {
    if (e instanceof topsort.CycleException) {
      return false;
    }
    throw e;
  }
  return true;
}

},{"./topsort":"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/topsort.js"}],"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/dfs.js":[function(require,module,exports) {
var _ = require("../lodash");

module.exports = dfs;

/*
 * A helper that preforms a pre- or post-order traversal on the input graph
 * and returns the nodes in the order they were visited. This algorithm treats
 * the input as undirected.
 *
 * Order must be one of "pre" or "post".
 */
function dfs(g, vs, order) {
  if (!_.isArray(vs)) {
    vs = [vs];
  }

  var acc = [],
      visited = {};
  _.each(vs, function(v) {
    if (!g.hasNode(v)) {
      throw new Error("Graph does not have node: " + v);
    }

    doDfs(g, v, order === "post", visited, acc);
  });
  return acc;
}

function doDfs(g, v, postorder, visited, acc) {
  if (!_.has(visited, v)) {
    visited[v] = true;

    if (!postorder) { acc.push(v); }
    _.each(g.neighbors(v), function(w) {
      doDfs(g, w, postorder, visited, acc);
    });
    if (postorder) { acc.push(v); }
  }
}

},{"../lodash":"../node_modules/graphlib-dot/node_modules/graphlib/lib/lodash.js"}],"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/postorder.js":[function(require,module,exports) {
var dfs = require("./dfs");

module.exports = postorder;

function postorder(g, vs) {
  return dfs(g, vs, "post");
}

},{"./dfs":"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/dfs.js"}],"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/preorder.js":[function(require,module,exports) {
var dfs = require("./dfs");

module.exports = preorder;

function preorder(g, vs) {
  return dfs(g, vs, "pre");
}

},{"./dfs":"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/dfs.js"}],"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/prim.js":[function(require,module,exports) {
var _ = require("../lodash"),
    Graph = require("../graph"),
    PriorityQueue = require("../data/priority-queue");

module.exports = prim;

function prim(g, weightFunc) {
  var result = new Graph(),
      parents = {},
      pq = new PriorityQueue(),
      v;

  function updateNeighbors(edge) {
    var w = edge.v === v ? edge.w : edge.v,
        pri = pq.priority(w);
    if (pri !== undefined) {
      var edgeWeight = weightFunc(edge);
      if (edgeWeight < pri) {
        parents[w] = v;
        pq.decrease(w, edgeWeight);
      }
    }
  }

  if (g.nodeCount() === 0) {
    return result;
  }

  _.each(g.nodes(), function(v) {
    pq.add(v, Number.POSITIVE_INFINITY);
    result.setNode(v);
  });

  // Start from an arbitrary node
  pq.decrease(g.nodes()[0], 0);

  var init = false;
  while (pq.size() > 0) {
    v = pq.removeMin();
    if (_.has(parents, v)) {
      result.setEdge(v, parents[v]);
    } else if (init) {
      throw new Error("Input graph is not connected: " + g);
    } else {
      init = true;
    }

    g.nodeEdges(v).forEach(updateNeighbors);
  }

  return result;
}

},{"../lodash":"../node_modules/graphlib-dot/node_modules/graphlib/lib/lodash.js","../graph":"../node_modules/graphlib-dot/node_modules/graphlib/lib/graph.js","../data/priority-queue":"../node_modules/graphlib-dot/node_modules/graphlib/lib/data/priority-queue.js"}],"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/index.js":[function(require,module,exports) {
module.exports = {
  components: require("./components"),
  dijkstra: require("./dijkstra"),
  dijkstraAll: require("./dijkstra-all"),
  findCycles: require("./find-cycles"),
  floydWarshall: require("./floyd-warshall"),
  isAcyclic: require("./is-acyclic"),
  postorder: require("./postorder"),
  preorder: require("./preorder"),
  prim: require("./prim"),
  tarjan: require("./tarjan"),
  topsort: require("./topsort")
};

},{"./components":"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/components.js","./dijkstra":"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/dijkstra.js","./dijkstra-all":"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/dijkstra-all.js","./find-cycles":"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/find-cycles.js","./floyd-warshall":"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/floyd-warshall.js","./is-acyclic":"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/is-acyclic.js","./postorder":"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/postorder.js","./preorder":"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/preorder.js","./prim":"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/prim.js","./tarjan":"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/tarjan.js","./topsort":"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/topsort.js"}],"../node_modules/graphlib-dot/node_modules/graphlib/index.js":[function(require,module,exports) {
/**
 * Copyright (c) 2014, Chris Pettitt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var lib = require("./lib");

module.exports = {
  Graph: lib.Graph,
  json: require("./lib/json"),
  alg: require("./lib/alg"),
  version: lib.version
};

},{"./lib":"../node_modules/graphlib-dot/node_modules/graphlib/lib/index.js","./lib/json":"../node_modules/graphlib-dot/node_modules/graphlib/lib/json.js","./lib/alg":"../node_modules/graphlib-dot/node_modules/graphlib/lib/alg/index.js"}],"../node_modules/graphlib-dot/lib/graphlib.js":[function(require,module,exports) {
/* global window */

var graphlib;

if (require) {
  try {
    graphlib = require("graphlib");
  } catch (e) {}
}

if (!graphlib) {
  graphlib = window.graphlib;
}

module.exports = graphlib;

},{"graphlib":"../node_modules/graphlib-dot/node_modules/graphlib/index.js"}],"../node_modules/graphlib-dot/lib/build-graph.js":[function(require,module,exports) {
"use strict";

var _ = require("./lodash"),
    Graph = require("./graphlib").Graph;

module.exports = buildGraph;

function buildGraph(parseTree) {
  var isDirected = parseTree.type !== "graph",
      isMultigraph = !parseTree.strict,
      defaultStack = [{ node: {}, edge: {} }],
      id = parseTree.id,
      g = new Graph({ directed: isDirected, multigraph: isMultigraph, compound: true });
      g.setGraph(id === null ? {} : {id: id});
  _.each(parseTree.stmts, function(stmt) { handleStmt(g, stmt, defaultStack); });
  return g;
}

function handleStmt(g, stmt, defaultStack, sg) {
  switch(stmt.type) {
    case "node": handleNodeStmt(g, stmt, defaultStack, sg); break;
    case "edge": handleEdgeStmt(g, stmt, defaultStack, sg); break;
    case "subgraph": handleSubgraphStmt(g, stmt, defaultStack, sg); break;
    case "attr": handleAttrStmt(g, stmt, defaultStack); break;
    case "inlineAttr": handleInlineAttrsStmt(g, stmt, defaultStack, sg); break;
  }
}

function handleNodeStmt(g, stmt, defaultStack, sg) {
  var v = stmt.id,
      attrs = stmt.attrs;
  maybeCreateNode(g, v, defaultStack, sg);
  _.merge(g.node(v), attrs);
}

function handleEdgeStmt(g, stmt, defaultStack, sg) {
  var attrs = stmt.attrs,
      prev, curr;
  _.each(stmt.elems, function(elem) {
    handleStmt(g, elem, defaultStack, sg);

    switch(elem.type) {
      case "node": curr = [elem.id]; break;
      case "subgraph": curr = collectNodeIds(elem); break;
    }

    _.each(prev, function(v) {
      _.each(curr, function(w) {
        var name;
        if (g.hasEdge(v, w) && g.isMultigraph()) {
          name = _.uniqueId("edge");
        }
        if (!g.hasEdge(v, w, name)) {
          g.setEdge(v, w, _.clone(_.last(defaultStack).edge), name);
        }
        _.merge(g.edge(v, w, name), attrs);
      });
    });

    prev = curr;
  });
}

function handleSubgraphStmt(g, stmt, defaultStack, sg) {
  var id = stmt.id;
  if (id === undefined) {
    id = generateSubgraphId(g);
  }

  defaultStack.push(_.clone(_.last(defaultStack)));

  maybeCreateNode(g, id, defaultStack, sg);

  _.each(stmt.stmts, function(s) {
    handleStmt(g, s, defaultStack, id);
  });

  // If there are no statements remove the subgraph
  if (!g.children(id).length) {
    g.removeNode(id);
  }

  defaultStack.pop();
}

function handleAttrStmt(g, stmt, defaultStack) {
  _.merge(_.last(defaultStack)[stmt.attrType], stmt.attrs);
}

function handleInlineAttrsStmt(g, stmt, defaultStack, sg) {
  _.merge(sg ? g.node(sg) : g.graph(), stmt.attrs);
}

function generateSubgraphId(g) {
  var id;
  do {
    id = _.uniqueId("sg");
  } while (g.hasNode(id));
  return id;
}

function maybeCreateNode(g, v, defaultStack, sg) {
  if (!g.hasNode(v)) {
    g.setNode(v, _.clone(_.last(defaultStack).node));
    g.setParent(v, sg);
  }
}

// Collect all nodes involved in a subgraph statement
function collectNodeIds(stmt) {
  var ids = {},
      stack = [],
      curr;

  var push = stack.push.bind(stack);

  push(stmt);
  while(stack.length) {
    curr = stack.pop();
    switch(curr.type) {
      case "node": ids[curr.id] = true; break;
      case "edge": _.each(curr.elems, push); break;
      case "subgraph": _.each(curr.stmts, push); break;
    }
  }

  return _.keys(ids);
}


},{"./lodash":"../node_modules/graphlib-dot/lib/lodash.js","./graphlib":"../node_modules/graphlib-dot/lib/graphlib.js"}],"../node_modules/graphlib-dot/lib/read-one.js":[function(require,module,exports) {
var grammar = require("./dot-grammar"),
    buildGraph = require("./build-graph");

module.exports = function readOne(str) {
  var parseTree = grammar.parse(str, { startRule: "graphStmt" });
  return buildGraph(parseTree);
};


},{"./dot-grammar":"../node_modules/graphlib-dot/lib/dot-grammar.js","./build-graph":"../node_modules/graphlib-dot/lib/build-graph.js"}],"../node_modules/graphlib-dot/lib/read-many.js":[function(require,module,exports) {
var _ = require("./lodash"),
    grammar = require("./dot-grammar"),
    buildGraph = require("./build-graph");

module.exports = function readMany(str) {
  var parseTree = grammar.parse(str);
  return _.map(parseTree, buildGraph);
};

},{"./lodash":"../node_modules/graphlib-dot/lib/lodash.js","./dot-grammar":"../node_modules/graphlib-dot/lib/dot-grammar.js","./build-graph":"../node_modules/graphlib-dot/lib/build-graph.js"}],"../node_modules/graphlib-dot/lib/write-one.js":[function(require,module,exports) {
var _ = require("./lodash");

module.exports = writeOne;

var UNESCAPED_ID_PATTERN = /^[a-zA-Z\200-\377_][a-zA-Z\200-\377_0-9]*$/;

function writeOne(g) {
  var ec = g.isDirected() ? "->" : "--",
      writer = new Writer();

  if (!g.isMultigraph()) {
    writer.write("strict ");
  }

  writer.writeLine((g.isDirected() ? "digraph" : "graph") + " {");
  writer.indent();

  var graphAttrs = g.graph();
  if (_.isObject(graphAttrs)) {
    _.each(graphAttrs, function(v, k) {
      writer.writeLine(id(k) + "=" + id(v) + ";");
    });
  }

  writeSubgraph(g, undefined, writer);

  g.edges().forEach(function(edge) {
    writeEdge(g, edge, ec, writer);
  });

  writer.unindent();
  writer.writeLine("}");

  return writer.toString();
}

function writeSubgraph(g, v, writer) {
  var children = g.isCompound() ? g.children(v) : g.nodes();
  _.each(children, function(w) {
    if (!g.isCompound() || !g.children(w).length) {
      writeNode(g, w, writer);
    } else {
      writer.writeLine("subgraph " + id(w) + " {");
      writer.indent();

      if (_.isObject(g.node(w))) {
        _.map(g.node(w), function(val, key) {
          writer.writeLine(id(key) + "=" + id(val) + ";");
        });
      }

      writeSubgraph(g, w, writer);
      writer.unindent();
      writer.writeLine("}");
    }
  });
}

function writeNode(g, v, writer) {
  writer.write(id(v));
  writeAttrs(g.node(v), writer);
  writer.writeLine();
}

function writeEdge(g, edge, ec, writer) {
  var v = edge.v,
      w = edge.w,
      attrs = g.edge(edge);

  writer.write(id(v) + " " + ec + " " + id(w));
  writeAttrs(attrs, writer);
  writer.writeLine();
}

function writeAttrs(attrs, writer) {
  if (_.isObject(attrs)) {
    var attrStrs = _.map(attrs, function(val, key) {
      return id(key) + "=" + id(val);
    });
    if (attrStrs.length) {
      writer.write(" [" + attrStrs.join(",") + "]");
    }
  }
}

function id(obj) {
  if (typeof obj === "number" || obj.toString().match(UNESCAPED_ID_PATTERN)) {
    return obj;
  }

  return "\"" + obj.toString().replace(/"/g, "\\\"") + "\"";
}

// Helper object for making a pretty printer
function Writer() {
  this._indent = "";
  this._content = "";
  this._shouldIndent = true;
}

Writer.prototype.INDENT = "  ";

Writer.prototype.indent = function() {
  this._indent += this.INDENT;
};

Writer.prototype.unindent = function() {
  this._indent = this._indent.slice(this.INDENT.length);
};

Writer.prototype.writeLine = function(line) {
  this.write((line || "") + "\n");
  this._shouldIndent = true;
};

Writer.prototype.write = function(str) {
  if (this._shouldIndent) {
    this._shouldIndent = false;
    this._content += this._indent;
  }
  this._content += str;
};

Writer.prototype.toString = function() {
  return this._content;
};


},{"./lodash":"../node_modules/graphlib-dot/lib/lodash.js"}],"../node_modules/graphlib-dot/lib/version.js":[function(require,module,exports) {
module.exports = '0.6.2';

},{}],"../node_modules/graphlib-dot/index.js":[function(require,module,exports) {
var read = require("./lib/read-one"),
    readMany = require("./lib/read-many"),
    write = require("./lib/write-one"),
    version = require("./lib/version");

module.exports = {
  graphlib: require("./lib/graphlib"),

  // Parsing
  read: read,
  readMany: readMany,

  // Writing
  write: write,

  // Version
  version: version,

  // For levelup encoding
  type: "dot",
  buffer: false
};

},{"./lib/read-one":"../node_modules/graphlib-dot/lib/read-one.js","./lib/read-many":"../node_modules/graphlib-dot/lib/read-many.js","./lib/write-one":"../node_modules/graphlib-dot/lib/write-one.js","./lib/version":"../node_modules/graphlib-dot/lib/version.js","./lib/graphlib":"../node_modules/graphlib-dot/lib/graphlib.js"}],"../src/parse.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parse2g6;

var _graphlibDot = _interopRequireDefault(require("graphlib-dot"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { if (i % 2) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } else { Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i])); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function parse2g6(str) {
  var graph;
  var nodes = [],
      edges = []; // read string to graph object

  try {
    graph = _graphlibDot.default.read(str);
  } catch (err) {
    console.error('[Error] While read string: ', err.message);
    return undefined;
  } // read node without subgraph


  graph.nodes().filter(function (node) {
    return !graph.children(node).length;
  }).map(function (node) {
    return nodes.push(_objectSpread({
      id: node
    }, graph.node(node)));
  });
  var subG = {};
  graph.nodes().filter(function (node) {
    return graph.children(node).length;
  }).map(function (e) {
    return graph.children(e).map(function (c) {
      subG[c] = e;
    });
  }); // read edge

  graph.edges().map(function (_ref) {
    var source = _ref.v,
        target = _ref.w;
    return edges.push(_objectSpread({
      source: source,
      target: target
    }, graph.edge(source, target)));
  }); // find the 0 in node

  var ninnodes = graph.nodes().filter(function (node) {
    return !graph.children(node).length;
  }).filter(function (n) {
    return !graph.inEdges(n).length;
  });
  var isUse = {};
  var resultNodes = [];
  var startX = 0,
      startY = 0;
  ninnodes.map(function (ninnode) {
    var arr = [{
      n: ninnode,
      level: 0
    }],
        res = [];
    var wgap = 50,
        width = 100,
        hgap = 50,
        height = 40;
    var max = 0;

    var _loop = function _loop() {
      var n = arr.shift();

      if (res[n.level] instanceof Array) {
        res[n.level].push(n);
        max = Math.max(res[n.level].length, max);
      } else {
        res[n.level] = [n];
      }

      if (graph.outEdges(n.n)) graph.outEdges(n.n).map(function (_ref2) {
        var w = _ref2.w;

        if (!isUse[w]) {
          arr.push({
            n: w,
            level: n.level + 1
          });
          isUse[w] = true;
        }
      });
    };

    while (arr.length) {
      _loop();
    }

    var newNodes = [];
    res.map(function (nodes, i) {
      var len = nodes.length;
      var point = {
        x: startX,
        y: startY
      };
      point.x = point.x + len * (width + wgap) / 2;
      point.y = point.y + i * (height + hgap);
      nodes.map(function (node) {
        var gr = subG[node.n] ? {
          parent: subG[node.n]
        } : {};
        newNodes.push(_objectSpread({}, point, {
          label: node.n,
          id: node.n
        }, graph.node(node.n), {}, gr));
        point.x -= width + wgap;
      });
    });
    resultNodes = resultNodes.concat(newNodes);
    startX -= max * (wgap + width);
    console.log('sx', startX);
  });
  var groups = graph.nodes().filter(function (node) {
    return graph.children(node).length;
  }).map(function (g) {
    return {
      id: g,
      shape: 'rect',
      index: 1,
      label: g
    };
  });
  return {
    nodes: resultNodes,
    edges: edges,
    groups: groups
  };
}
},{"graphlib-dot":"../node_modules/graphlib-dot/index.js"}],"../node_modules/@antv/g6/build/g6.js":[function(require,module,exports) {
var define;
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

!function (t, e) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.G6 = e() : t.G6 = e();
}(window, function () {
  return function (t) {
    var e = {};

    function n(r) {
      if (e[r]) return e[r].exports;
      var i = e[r] = {
        i: r,
        l: !1,
        exports: {}
      };
      return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports;
    }

    return n.m = t, n.c = e, n.d = function (t, e, r) {
      n.o(t, e) || Object.defineProperty(t, e, {
        enumerable: !0,
        get: r
      });
    }, n.r = function (t) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(t, "__esModule", {
        value: !0
      });
    }, n.t = function (t, e) {
      if (1 & e && (t = n(t)), 8 & e) return t;
      if (4 & e && "object" == _typeof(t) && t && t.__esModule) return t;
      var r = Object.create(null);
      if (n.r(r), Object.defineProperty(r, "default", {
        enumerable: !0,
        value: t
      }), 2 & e && "string" != typeof t) for (var i in t) {
        n.d(r, i, function (e) {
          return t[e];
        }.bind(null, i));
      }
      return r;
    }, n.n = function (t) {
      var e = t && t.__esModule ? function () {
        return t.default;
      } : function () {
        return t;
      };
      return n.d(e, "a", e), e;
    }, n.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }, n.p = "", n(n.s = 820);
  }([, function (t, e, n) {
    "use strict";

    var r = function r(t, e, n) {
      t.prototype = e.prototype = n, n.constructor = t;
    };

    function i(t, e) {
      var n = Object.create(t.prototype);

      for (var r in e) {
        n[r] = e[r];
      }

      return n;
    }

    function a() {}

    var o = "\\s*([+-]?\\d+)\\s*",
        s = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        u = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        c = /^#([0-9a-f]{3})$/,
        h = /^#([0-9a-f]{6})$/,
        f = new RegExp("^rgb\\(" + [o, o, o] + "\\)$"),
        l = new RegExp("^rgb\\(" + [u, u, u] + "\\)$"),
        p = new RegExp("^rgba\\(" + [o, o, o, s] + "\\)$"),
        d = new RegExp("^rgba\\(" + [u, u, u, s] + "\\)$"),
        g = new RegExp("^hsl\\(" + [s, u, u] + "\\)$"),
        v = new RegExp("^hsla\\(" + [s, u, u, s] + "\\)$"),
        m = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };

    function x(t) {
      var e;
      return t = (t + "").trim().toLowerCase(), (e = c.exec(t)) ? new _((e = parseInt(e[1], 16)) >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | 240 & e, (15 & e) << 4 | 15 & e, 1) : (e = h.exec(t)) ? y(parseInt(e[1], 16)) : (e = f.exec(t)) ? new _(e[1], e[2], e[3], 1) : (e = l.exec(t)) ? new _(255 * e[1] / 100, 255 * e[2] / 100, 255 * e[3] / 100, 1) : (e = p.exec(t)) ? b(e[1], e[2], e[3], e[4]) : (e = d.exec(t)) ? b(255 * e[1] / 100, 255 * e[2] / 100, 255 * e[3] / 100, e[4]) : (e = g.exec(t)) ? S(e[1], e[2] / 100, e[3] / 100, 1) : (e = v.exec(t)) ? S(e[1], e[2] / 100, e[3] / 100, e[4]) : m.hasOwnProperty(t) ? y(m[t]) : "transparent" === t ? new _(NaN, NaN, NaN, 0) : null;
    }

    function y(t) {
      return new _(t >> 16 & 255, t >> 8 & 255, 255 & t, 1);
    }

    function b(t, e, n, r) {
      return r <= 0 && (t = e = n = NaN), new _(t, e, n, r);
    }

    function M(t) {
      return t instanceof a || (t = x(t)), t ? new _((t = t.rgb()).r, t.g, t.b, t.opacity) : new _();
    }

    function w(t, e, n, r) {
      return 1 === arguments.length ? M(t) : new _(t, e, n, null == r ? 1 : r);
    }

    function _(t, e, n, r) {
      this.r = +t, this.g = +e, this.b = +n, this.opacity = +r;
    }

    function E(t) {
      return ((t = Math.max(0, Math.min(255, Math.round(t) || 0))) < 16 ? "0" : "") + t.toString(16);
    }

    function S(t, e, n, r) {
      return r <= 0 ? t = e = n = NaN : n <= 0 || n >= 1 ? t = e = NaN : e <= 0 && (t = NaN), new P(t, e, n, r);
    }

    function A(t, e, n, r) {
      return 1 === arguments.length ? function (t) {
        if (t instanceof P) return new P(t.h, t.s, t.l, t.opacity);
        if (t instanceof a || (t = x(t)), !t) return new P();
        if (t instanceof P) return t;
        var e = (t = t.rgb()).r / 255,
            n = t.g / 255,
            r = t.b / 255,
            i = Math.min(e, n, r),
            o = Math.max(e, n, r),
            s = NaN,
            u = o - i,
            c = (o + i) / 2;
        return u ? (s = e === o ? (n - r) / u + 6 * (n < r) : n === o ? (r - e) / u + 2 : (e - n) / u + 4, u /= c < .5 ? o + i : 2 - o - i, s *= 60) : u = c > 0 && c < 1 ? 0 : s, new P(s, u, c, t.opacity);
      }(t) : new P(t, e, n, null == r ? 1 : r);
    }

    function P(t, e, n, r) {
      this.h = +t, this.s = +e, this.l = +n, this.opacity = +r;
    }

    function O(t, e, n) {
      return 255 * (t < 60 ? e + (n - e) * t / 60 : t < 180 ? n : t < 240 ? e + (n - e) * (240 - t) / 60 : e);
    }

    r(a, x, {
      displayable: function displayable() {
        return this.rgb().displayable();
      },
      hex: function hex() {
        return this.rgb().hex();
      },
      toString: function toString() {
        return this.rgb() + "";
      }
    }), r(_, w, i(a, {
      brighter: function brighter(t) {
        return t = null == t ? 1 / .7 : Math.pow(1 / .7, t), new _(this.r * t, this.g * t, this.b * t, this.opacity);
      },
      darker: function darker(t) {
        return t = null == t ? .7 : Math.pow(.7, t), new _(this.r * t, this.g * t, this.b * t, this.opacity);
      },
      rgb: function rgb() {
        return this;
      },
      displayable: function displayable() {
        return 0 <= this.r && this.r <= 255 && 0 <= this.g && this.g <= 255 && 0 <= this.b && this.b <= 255 && 0 <= this.opacity && this.opacity <= 1;
      },
      hex: function hex() {
        return "#" + E(this.r) + E(this.g) + E(this.b);
      },
      toString: function toString() {
        var t = this.opacity;
        return (1 === (t = isNaN(t) ? 1 : Math.max(0, Math.min(1, t))) ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (1 === t ? ")" : ", " + t + ")");
      }
    })), r(P, A, i(a, {
      brighter: function brighter(t) {
        return t = null == t ? 1 / .7 : Math.pow(1 / .7, t), new P(this.h, this.s, this.l * t, this.opacity);
      },
      darker: function darker(t) {
        return t = null == t ? .7 : Math.pow(.7, t), new P(this.h, this.s, this.l * t, this.opacity);
      },
      rgb: function rgb() {
        var t = this.h % 360 + 360 * (this.h < 0),
            e = isNaN(t) || isNaN(this.s) ? 0 : this.s,
            n = this.l,
            r = n + (n < .5 ? n : 1 - n) * e,
            i = 2 * n - r;
        return new _(O(t >= 240 ? t - 240 : t + 120, i, r), O(t, i, r), O(t < 120 ? t + 240 : t - 120, i, r), this.opacity);
      },
      displayable: function displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
      }
    }));
    var C = Math.PI / 180,
        I = 180 / Math.PI,
        T = .96422,
        k = 1,
        N = .82521,
        L = 4 / 29,
        B = 6 / 29,
        j = 3 * B * B,
        D = B * B * B;

    function R(t) {
      if (t instanceof X) return new X(t.l, t.a, t.b, t.opacity);

      if (t instanceof Z) {
        if (isNaN(t.h)) return new X(t.l, 0, 0, t.opacity);
        var e = t.h * C;
        return new X(t.l, Math.cos(e) * t.c, Math.sin(e) * t.c, t.opacity);
      }

      t instanceof _ || (t = M(t));
      var n,
          r,
          i = H(t.r),
          a = H(t.g),
          o = H(t.b),
          s = G((.2225045 * i + .7168786 * a + .0606169 * o) / k);
      return i === a && a === o ? n = r = s : (n = G((.4360747 * i + .3850649 * a + .1430804 * o) / T), r = G((.0139322 * i + .0971045 * a + .7141733 * o) / N)), new X(116 * s - 16, 500 * (n - s), 200 * (s - r), t.opacity);
    }

    function F(t, e) {
      return new X(t, 0, 0, null == e ? 1 : e);
    }

    function Y(t, e, n, r) {
      return 1 === arguments.length ? R(t) : new X(t, e, n, null == r ? 1 : r);
    }

    function X(t, e, n, r) {
      this.l = +t, this.a = +e, this.b = +n, this.opacity = +r;
    }

    function G(t) {
      return t > D ? Math.pow(t, 1 / 3) : t / j + L;
    }

    function q(t) {
      return t > B ? t * t * t : j * (t - L);
    }

    function U(t) {
      return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055);
    }

    function H(t) {
      return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);
    }

    function V(t) {
      if (t instanceof Z) return new Z(t.h, t.c, t.l, t.opacity);
      if (t instanceof X || (t = R(t)), 0 === t.a && 0 === t.b) return new Z(NaN, 0, t.l, t.opacity);
      var e = Math.atan2(t.b, t.a) * I;
      return new Z(e < 0 ? e + 360 : e, Math.sqrt(t.a * t.a + t.b * t.b), t.l, t.opacity);
    }

    function z(t, e, n, r) {
      return 1 === arguments.length ? V(t) : new Z(n, e, t, null == r ? 1 : r);
    }

    function W(t, e, n, r) {
      return 1 === arguments.length ? V(t) : new Z(t, e, n, null == r ? 1 : r);
    }

    function Z(t, e, n, r) {
      this.h = +t, this.c = +e, this.l = +n, this.opacity = +r;
    }

    r(X, Y, i(a, {
      brighter: function brighter(t) {
        return new X(this.l + 18 * (null == t ? 1 : t), this.a, this.b, this.opacity);
      },
      darker: function darker(t) {
        return new X(this.l - 18 * (null == t ? 1 : t), this.a, this.b, this.opacity);
      },
      rgb: function rgb() {
        var t = (this.l + 16) / 116,
            e = isNaN(this.a) ? t : t + this.a / 500,
            n = isNaN(this.b) ? t : t - this.b / 200;
        return new _(U(3.1338561 * (e = T * q(e)) - 1.6168667 * (t = k * q(t)) - .4906146 * (n = N * q(n))), U(-.9787684 * e + 1.9161415 * t + .033454 * n), U(.0719453 * e - .2289914 * t + 1.4052427 * n), this.opacity);
      }
    })), r(Z, W, i(a, {
      brighter: function brighter(t) {
        return new Z(this.h, this.c, this.l + 18 * (null == t ? 1 : t), this.opacity);
      },
      darker: function darker(t) {
        return new Z(this.h, this.c, this.l - 18 * (null == t ? 1 : t), this.opacity);
      },
      rgb: function rgb() {
        return R(this).rgb();
      }
    }));
    var K = -.14861,
        Q = 1.78277,
        $ = -.29227,
        J = -.90649,
        tt = 1.97294,
        et = tt * J,
        nt = tt * Q,
        rt = Q * $ - J * K;

    function it(t, e, n, r) {
      return 1 === arguments.length ? function (t) {
        if (t instanceof at) return new at(t.h, t.s, t.l, t.opacity);
        t instanceof _ || (t = M(t));
        var e = t.r / 255,
            n = t.g / 255,
            r = t.b / 255,
            i = (rt * r + et * e - nt * n) / (rt + et - nt),
            a = r - i,
            o = (tt * (n - i) - $ * a) / J,
            s = Math.sqrt(o * o + a * a) / (tt * i * (1 - i)),
            u = s ? Math.atan2(o, a) * I - 120 : NaN;
        return new at(u < 0 ? u + 360 : u, s, i, t.opacity);
      }(t) : new at(t, e, n, null == r ? 1 : r);
    }

    function at(t, e, n, r) {
      this.h = +t, this.s = +e, this.l = +n, this.opacity = +r;
    }

    r(at, it, i(a, {
      brighter: function brighter(t) {
        return t = null == t ? 1 / .7 : Math.pow(1 / .7, t), new at(this.h, this.s, this.l * t, this.opacity);
      },
      darker: function darker(t) {
        return t = null == t ? .7 : Math.pow(.7, t), new at(this.h, this.s, this.l * t, this.opacity);
      },
      rgb: function rgb() {
        var t = isNaN(this.h) ? 0 : (this.h + 120) * C,
            e = +this.l,
            n = isNaN(this.s) ? 0 : this.s * e * (1 - e),
            r = Math.cos(t),
            i = Math.sin(t);
        return new _(255 * (e + n * (K * r + Q * i)), 255 * (e + n * ($ * r + J * i)), 255 * (e + n * (tt * r)), this.opacity);
      }
    })), n.d(e, "a", function () {
      return x;
    }), n.d(e, "h", function () {
      return w;
    }), n.d(e, "e", function () {
      return A;
    }), n.d(e, "f", function () {
      return Y;
    }), n.d(e, "d", function () {
      return W;
    }), n.d(e, "g", function () {
      return z;
    }), n.d(e, "c", function () {
      return F;
    }), n.d(e, "b", function () {
      return it;
    });
  },,,,,,,,,,,,,,, function (t, e) {
    t.exports = function (t) {
      var e = _typeof(t);

      return null != t && ("object" == e || "function" == e);
    };
  }, function (t, e, n) {
    "use strict";

    n.r(e);
    var r,
        i,
        a = 0,
        o = 0,
        s = 0,
        u = 1e3,
        c = 0,
        h = 0,
        f = 0,
        l = "object" == (typeof performance === "undefined" ? "undefined" : _typeof(performance)) && performance.now ? performance : Date,
        p = "object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (t) {
      setTimeout(t, 17);
    };

    function d() {
      return h || (p(g), h = l.now() + f);
    }

    function g() {
      h = 0;
    }

    function v() {
      this._call = this._time = this._next = null;
    }

    function m(t, e, n) {
      var r = new v();
      return r.restart(t, e, n), r;
    }

    function x() {
      d(), ++a;

      for (var t, e = r; e;) {
        (t = h - e._time) >= 0 && e._call.call(null, t), e = e._next;
      }

      --a;
    }

    function y() {
      h = (c = l.now()) + f, a = o = 0;

      try {
        x();
      } finally {
        a = 0, function () {
          var t,
              e,
              n = r,
              a = 1 / 0;

          for (; n;) {
            n._call ? (a > n._time && (a = n._time), t = n, n = n._next) : (e = n._next, n._next = null, n = t ? t._next = e : r = e);
          }

          i = t, M(a);
        }(), h = 0;
      }
    }

    function b() {
      var t = l.now(),
          e = t - c;
      e > u && (f -= e, c = t);
    }

    function M(t) {
      a || (o && (o = clearTimeout(o)), t - h > 24 ? (t < 1 / 0 && (o = setTimeout(y, t - l.now() - f)), s && (s = clearInterval(s))) : (s || (c = l.now(), s = setInterval(b, u)), a = 1, p(y)));
    }

    v.prototype = m.prototype = {
      constructor: v,
      restart: function restart(t, e, n) {
        if ("function" != typeof t) throw new TypeError("callback is not a function");
        n = (null == n ? d() : +n) + (null == e ? 0 : +e), this._next || i === this || (i ? i._next = this : r = this, i = this), this._call = t, this._time = n, M();
      },
      stop: function stop() {
        this._call && (this._call = null, this._time = 1 / 0, M());
      }
    };

    var w = function w(t, e, n) {
      var r = new v();
      return e = null == e ? 0 : +e, r.restart(function (n) {
        r.stop(), t(n + e);
      }, e, n), r;
    },
        _ = function _(t, e, n) {
      var r = new v(),
          i = e;
      return null == e ? (r.restart(t, e, n), r) : (e = +e, n = null == n ? d() : +n, r.restart(function a(o) {
        o += i, r.restart(a, i += e, n), t(o);
      }, e, n), r);
    };

    n.d(e, "now", function () {
      return d;
    }), n.d(e, "timer", function () {
      return m;
    }), n.d(e, "timerFlush", function () {
      return x;
    }), n.d(e, "timeout", function () {
      return w;
    }), n.d(e, "interval", function () {
      return _;
    });
  },, function (t, e, n) {
    var r = n(644),
        i = {};
    r.merge(i, r, {
      mixin: function mixin(t, e) {
        var n = t.CFG ? "CFG" : "ATTRS";

        if (t && e) {
          t._mixins = e, t[n] = t[n] || {};
          var r = {};
          i.each(e, function (e) {
            i.augment(t, e);
            var a = e[n];
            a && i.merge(r, a);
          }), t[n] = i.merge(r, t[n]);
        }
      }
    }), t.exports = i;
  }, function (t, e, n) {
    var r = n(117),
        i = "object" == (typeof self === "undefined" ? "undefined" : _typeof(self)) && self && self.Object === Object && self,
        a = r || i || Function("return this")();
    t.exports = a;
  },,, function (t, e) {
    t.exports = function (t) {
      return null != t && "object" == _typeof(t);
    };
  },,, function (t, e, n) {
    var r = {},
        i = n(682),
        a = n(748),
        o = n(257),
        s = n(727),
        u = n(726),
        c = n(725);
    o.mix(r, o, u, c, s, a, i), t.exports = r;
  },,,,,,,, function (t, e, n) {
    var r = n(38),
        i = n(250),
        a = n(249),
        o = "[object Null]",
        s = "[object Undefined]",
        u = r ? r.toStringTag : void 0;

    t.exports = function (t) {
      return null == t ? void 0 === t ? s : o : u && u in Object(t) ? i(t) : a(t);
    };
  },,,, function (t, e, n) {
    var r = n(20).Symbol;
    t.exports = r;
  }, function (t, e, n) {
    var r = n(34),
        i = n(23),
        a = "[object Symbol]";

    t.exports = function (t) {
      return "symbol" == _typeof(t) || i(t) && r(t) == a;
    };
  },,,,, function (t, e, n) {
    "use strict";

    function r(t) {
      return +t;
    }

    function i(t) {
      return t * t;
    }

    function a(t) {
      return t * (2 - t);
    }

    function o(t) {
      return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
    }

    function s(t) {
      return t * t * t;
    }

    function u(t) {
      return --t * t * t + 1;
    }

    function c(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    n.r(e);

    var h = function t(e) {
      function n(t) {
        return Math.pow(t, e);
      }

      return e = +e, n.exponent = t, n;
    }(3),
        f = function t(e) {
      function n(t) {
        return 1 - Math.pow(1 - t, e);
      }

      return e = +e, n.exponent = t, n;
    }(3),
        l = function t(e) {
      function n(t) {
        return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
      }

      return e = +e, n.exponent = t, n;
    }(3),
        p = Math.PI,
        d = p / 2;

    function g(t) {
      return 1 - Math.cos(t * d);
    }

    function v(t) {
      return Math.sin(t * d);
    }

    function m(t) {
      return (1 - Math.cos(p * t)) / 2;
    }

    function x(t) {
      return Math.pow(2, 10 * t - 10);
    }

    function y(t) {
      return 1 - Math.pow(2, -10 * t);
    }

    function b(t) {
      return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
    }

    function M(t) {
      return 1 - Math.sqrt(1 - t * t);
    }

    function w(t) {
      return Math.sqrt(1 - --t * t);
    }

    function _(t) {
      return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
    }

    var E = 4 / 11,
        S = 6 / 11,
        A = 8 / 11,
        P = .75,
        O = 9 / 11,
        C = 10 / 11,
        I = .9375,
        T = 21 / 22,
        k = 63 / 64,
        N = 1 / E / E;

    function L(t) {
      return 1 - B(1 - t);
    }

    function B(t) {
      return (t = +t) < E ? N * t * t : t < A ? N * (t -= S) * t + P : t < C ? N * (t -= O) * t + I : N * (t -= T) * t + k;
    }

    function j(t) {
      return ((t *= 2) <= 1 ? 1 - B(1 - t) : B(t - 1) + 1) / 2;
    }

    var D = function t(e) {
      function n(t) {
        return t * t * ((e + 1) * t - e);
      }

      return e = +e, n.overshoot = t, n;
    }(1.70158),
        R = function t(e) {
      function n(t) {
        return --t * t * ((e + 1) * t + e) + 1;
      }

      return e = +e, n.overshoot = t, n;
    }(1.70158),
        F = function t(e) {
      function n(t) {
        return ((t *= 2) < 1 ? t * t * ((e + 1) * t - e) : (t -= 2) * t * ((e + 1) * t + e) + 2) / 2;
      }

      return e = +e, n.overshoot = t, n;
    }(1.70158),
        Y = 2 * Math.PI,
        X = function t(e, n) {
      var r = Math.asin(1 / (e = Math.max(1, e))) * (n /= Y);

      function i(t) {
        return e * Math.pow(2, 10 * --t) * Math.sin((r - t) / n);
      }

      return i.amplitude = function (e) {
        return t(e, n * Y);
      }, i.period = function (n) {
        return t(e, n);
      }, i;
    }(1, .3),
        G = function t(e, n) {
      var r = Math.asin(1 / (e = Math.max(1, e))) * (n /= Y);

      function i(t) {
        return 1 - e * Math.pow(2, -10 * (t = +t)) * Math.sin((t + r) / n);
      }

      return i.amplitude = function (e) {
        return t(e, n * Y);
      }, i.period = function (n) {
        return t(e, n);
      }, i;
    }(1, .3),
        q = function t(e, n) {
      var r = Math.asin(1 / (e = Math.max(1, e))) * (n /= Y);

      function i(t) {
        return ((t = 2 * t - 1) < 0 ? e * Math.pow(2, 10 * t) * Math.sin((r - t) / n) : 2 - e * Math.pow(2, -10 * t) * Math.sin((r + t) / n)) / 2;
      }

      return i.amplitude = function (e) {
        return t(e, n * Y);
      }, i.period = function (n) {
        return t(e, n);
      }, i;
    }(1, .3);

    n.d(e, "easeLinear", function () {
      return r;
    }), n.d(e, "easeQuad", function () {
      return o;
    }), n.d(e, "easeQuadIn", function () {
      return i;
    }), n.d(e, "easeQuadOut", function () {
      return a;
    }), n.d(e, "easeQuadInOut", function () {
      return o;
    }), n.d(e, "easeCubic", function () {
      return c;
    }), n.d(e, "easeCubicIn", function () {
      return s;
    }), n.d(e, "easeCubicOut", function () {
      return u;
    }), n.d(e, "easeCubicInOut", function () {
      return c;
    }), n.d(e, "easePoly", function () {
      return l;
    }), n.d(e, "easePolyIn", function () {
      return h;
    }), n.d(e, "easePolyOut", function () {
      return f;
    }), n.d(e, "easePolyInOut", function () {
      return l;
    }), n.d(e, "easeSin", function () {
      return m;
    }), n.d(e, "easeSinIn", function () {
      return g;
    }), n.d(e, "easeSinOut", function () {
      return v;
    }), n.d(e, "easeSinInOut", function () {
      return m;
    }), n.d(e, "easeExp", function () {
      return b;
    }), n.d(e, "easeExpIn", function () {
      return x;
    }), n.d(e, "easeExpOut", function () {
      return y;
    }), n.d(e, "easeExpInOut", function () {
      return b;
    }), n.d(e, "easeCircle", function () {
      return _;
    }), n.d(e, "easeCircleIn", function () {
      return M;
    }), n.d(e, "easeCircleOut", function () {
      return w;
    }), n.d(e, "easeCircleInOut", function () {
      return _;
    }), n.d(e, "easeBounce", function () {
      return B;
    }), n.d(e, "easeBounceIn", function () {
      return L;
    }), n.d(e, "easeBounceOut", function () {
      return B;
    }), n.d(e, "easeBounceInOut", function () {
      return j;
    }), n.d(e, "easeBack", function () {
      return F;
    }), n.d(e, "easeBackIn", function () {
      return D;
    }), n.d(e, "easeBackOut", function () {
      return R;
    }), n.d(e, "easeBackInOut", function () {
      return F;
    }), n.d(e, "easeElastic", function () {
      return G;
    }), n.d(e, "easeElasticIn", function () {
      return X;
    }), n.d(e, "easeElasticOut", function () {
      return G;
    }), n.d(e, "easeElasticInOut", function () {
      return q;
    });
  }, function (t, e, n) {
    var r = n(115),
        i = Array.isArray ? Array.isArray : function (t) {
      return r(t, "Array");
    };
    t.exports = i;
  }, function (t, e, n) {
    var r = n(621),
        i = n(45);

    t.exports = function (t, e) {
      if (t) if (i(t)) for (var n = 0, a = t.length; n < a && !1 !== e(t[n], n); n++) {
        ;
      } else if (r(t)) for (var o in t) {
        if (t.hasOwnProperty(o) && !1 === e(t[o], o)) break;
      }
    };
  },,,,,,,,,,,, function (t, e, n) {
    var r = n(19),
        i = n(742),
        a = n(641),
        o = n(613),
        s = function t(e) {
      t.superclass.constructor.call(this, e);
    };

    s.ATTRS = {}, r.extend(s, a);
    var u = {
      matrix: "matrix",
      path: "path",
      points: "points",
      lineDash: "lineDash"
    };
    r.augment(s, i, {
      isShape: !0,
      drawInner: function drawInner(t) {
        var e = this._attrs;
        this.createPath(t);
        var n = t.globalAlpha;

        if (this.hasFill()) {
          var i = e.fillOpacity;
          r.isNil(i) || 1 === i ? t.fill() : (t.globalAlpha = i, t.fill(), t.globalAlpha = n);
        }

        if (this.hasStroke() && this._attrs.lineWidth > 0) {
          var a = e.strokeOpacity;
          r.isNil(a) || 1 === a || (t.globalAlpha = a), t.stroke();
        }

        this.afterPath(t);
      },
      afterPath: function afterPath() {},
      isHitBox: function isHitBox() {
        return !0;
      },
      isHit: function isHit(t, e) {
        var n = [t, e, 1];

        if (this.invert(n), this.isHitBox()) {
          var r = this.getBBox();
          if (r && !o.box(r.minX, r.maxX, r.minY, r.maxY, n[0], n[1])) return !1;
        }

        var i = this._attrs.clip;
        return i ? (i.invert(n, this.get("canvas")), !!i.isPointInPath(n[0], n[1]) && this.isPointInPath(n[0], n[1])) : this.isPointInPath(n[0], n[1]);
      },
      calculateBox: function calculateBox() {
        return null;
      },
      getHitLineWidth: function getHitLineWidth() {
        var t = this._attrs,
            e = t.lineAppendWidth || 0;
        return (t.lineWidth || 0) + e;
      },
      clearTotalMatrix: function clearTotalMatrix() {
        this._cfg.totalMatrix = null, this._cfg.region = null;
      },
      clearBBox: function clearBBox() {
        this._cfg.box = null, this._cfg.region = null;
      },
      getBBox: function getBBox() {
        var t = this._cfg.box;
        return t || ((t = this.calculateBox()) && (t.x = t.minX, t.y = t.minY, t.width = t.maxX - t.minX, t.height = t.maxY - t.minY), this._cfg.box = t), t;
      },
      clone: function clone() {
        var t = null,
            e = this._attrs,
            n = {};
        return r.each(e, function (t, i) {
          u[i] && r.isArray(e[i]) ? n[i] = function (t) {
            for (var e = [], n = 0; n < t.length; n++) {
              r.isArray(t[n]) ? e.push([].concat(t[n])) : e.push(t[n]);
            }

            return e;
          }(e[i]) : n[i] = e[i];
        }), t = new this.constructor({
          attrs: n
        }), t._cfg.zIndex = this._cfg.zIndex, t;
      }
    }), t.exports = s;
  }, function (t, e, n) {
    "use strict";

    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.setMatrixArrayType = function (t) {
      e.ARRAY_TYPE = t;
    }, e.toRadian = function (t) {
      return t * i;
    }, e.equals = function (t, e) {
      return Math.abs(t - e) <= r * Math.max(1, Math.abs(t), Math.abs(e));
    };
    var r = e.EPSILON = 1e-6;
    e.ARRAY_TYPE = "undefined" != typeof Float32Array ? Float32Array : Array, e.RANDOM = Math.random;
    var i = Math.PI / 180;
  },,,,,,,,,,,,,,,,,,,,,,,,, function (t, e, n) {
    var r = n(115);

    t.exports = function (t) {
      return r(t, "Function");
    };
  },,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, function (t, e) {
    var n = {}.toString;

    t.exports = function (t, e) {
      return n.call(t) === "[object " + e + "]";
    };
  }, function (t, e, n) {
    var r;
    /*!
     * EventEmitter v5.1.0 - git.io/ee
     * Unlicense - http://unlicense.org/
     * Oliver Caldwell - http://oli.me.uk/
     * @preserve
     */

    !function (e) {
      "use strict";

      function i() {}

      var a = i.prototype,
          o = e.EventEmitter;

      function s(t, e) {
        for (var n = t.length; n--;) {
          if (t[n].listener === e) return n;
        }

        return -1;
      }

      function u(t) {
        return function () {
          return this[t].apply(this, arguments);
        };
      }

      a.getListeners = function (t) {
        var e,
            n,
            r = this._getEvents();

        if (t instanceof RegExp) for (n in e = {}, r) {
          r.hasOwnProperty(n) && t.test(n) && (e[n] = r[n]);
        } else e = r[t] || (r[t] = []);
        return e;
      }, a.flattenListeners = function (t) {
        var e,
            n = [];

        for (e = 0; e < t.length; e += 1) {
          n.push(t[e].listener);
        }

        return n;
      }, a.getListenersAsObject = function (t) {
        var e,
            n = this.getListeners(t);
        return n instanceof Array && ((e = {})[t] = n), e || n;
      }, a.addListener = function (t, e) {
        if (!function t(e) {
          return "function" == typeof e || e instanceof RegExp || !(!e || "object" != _typeof(e)) && t(e.listener);
        }(e)) throw new TypeError("listener must be a function");

        var n,
            r = this.getListenersAsObject(t),
            i = "object" == _typeof(e);

        for (n in r) {
          r.hasOwnProperty(n) && -1 === s(r[n], e) && r[n].push(i ? e : {
            listener: e,
            once: !1
          });
        }

        return this;
      }, a.on = u("addListener"), a.addOnceListener = function (t, e) {
        return this.addListener(t, {
          listener: e,
          once: !0
        });
      }, a.once = u("addOnceListener"), a.defineEvent = function (t) {
        return this.getListeners(t), this;
      }, a.defineEvents = function (t) {
        for (var e = 0; e < t.length; e += 1) {
          this.defineEvent(t[e]);
        }

        return this;
      }, a.removeListener = function (t, e) {
        var n,
            r,
            i = this.getListenersAsObject(t);

        for (r in i) {
          i.hasOwnProperty(r) && -1 !== (n = s(i[r], e)) && i[r].splice(n, 1);
        }

        return this;
      }, a.off = u("removeListener"), a.addListeners = function (t, e) {
        return this.manipulateListeners(!1, t, e);
      }, a.removeListeners = function (t, e) {
        return this.manipulateListeners(!0, t, e);
      }, a.manipulateListeners = function (t, e, n) {
        var r,
            i,
            a = t ? this.removeListener : this.addListener,
            o = t ? this.removeListeners : this.addListeners;
        if ("object" != _typeof(e) || e instanceof RegExp) for (r = n.length; r--;) {
          a.call(this, e, n[r]);
        } else for (r in e) {
          e.hasOwnProperty(r) && (i = e[r]) && ("function" == typeof i ? a.call(this, r, i) : o.call(this, r, i));
        }
        return this;
      }, a.removeEvent = function (t) {
        var e,
            n = _typeof(t),
            r = this._getEvents();

        if ("string" === n) delete r[t];else if (t instanceof RegExp) for (e in r) {
          r.hasOwnProperty(e) && t.test(e) && delete r[e];
        } else delete this._events;
        return this;
      }, a.removeAllListeners = u("removeEvent"), a.emitEvent = function (t, e) {
        var n,
            r,
            i,
            a,
            o = this.getListenersAsObject(t);

        for (a in o) {
          if (o.hasOwnProperty(a)) for (n = o[a].slice(0), i = 0; i < n.length; i++) {
            !0 === (r = n[i]).once && this.removeListener(t, r.listener), r.listener.apply(this, e || []) === this._getOnceReturnValue() && this.removeListener(t, r.listener);
          }
        }

        return this;
      }, a.trigger = u("emitEvent"), a.emit = function (t) {
        var e = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(t, e);
      }, a.setOnceReturnValue = function (t) {
        return this._onceReturnValue = t, this;
      }, a._getOnceReturnValue = function () {
        return !this.hasOwnProperty("_onceReturnValue") || this._onceReturnValue;
      }, a._getEvents = function () {
        return this._events || (this._events = {});
      }, i.noConflict = function () {
        return e.EventEmitter = o, i;
      }, void 0 === (r = function () {
        return i;
      }.call(e, n, e, t)) || (t.exports = r);
    }(this || {});
  }, function (t, e, n) {
    (function (e) {
      var n = "object" == _typeof(e) && e && e.Object === Object && e;
      t.exports = n;
    }).call(this, n(252));
  }, function (t, e) {
    t.exports = function (t) {
      return null !== t && "function" != typeof t && isFinite(t.length);
    };
  },,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, function (t, e, n) {
    var r = n(115);

    t.exports = function (t) {
      return r(t, "Number");
    };
  }, function (t, e) {
    t.exports = function (t) {
      return null === t || void 0 === t;
    };
  }, function (t, e, n) {
    "use strict";

    n.r(e);
    var r = n(1);

    function i(t, e, n, r, i) {
      var a = t * t,
          o = a * t;
      return ((1 - 3 * t + 3 * a - o) * e + (4 - 6 * a + 3 * o) * n + (1 + 3 * t + 3 * a - 3 * o) * r + o * i) / 6;
    }

    var a = function a(t) {
      var e = t.length - 1;
      return function (n) {
        var r = n <= 0 ? n = 0 : n >= 1 ? (n = 1, e - 1) : Math.floor(n * e),
            a = t[r],
            o = t[r + 1],
            s = r > 0 ? t[r - 1] : 2 * a - o,
            u = r < e - 1 ? t[r + 2] : 2 * o - a;
        return i((n - r / e) * e, s, a, o, u);
      };
    },
        o = function o(t) {
      var e = t.length;
      return function (n) {
        var r = Math.floor(((n %= 1) < 0 ? ++n : n) * e),
            a = t[(r + e - 1) % e],
            o = t[r % e],
            s = t[(r + 1) % e],
            u = t[(r + 2) % e];
        return i((n - r / e) * e, a, o, s, u);
      };
    },
        s = function s(t) {
      return function () {
        return t;
      };
    };

    function u(t, e) {
      return function (n) {
        return t + n * e;
      };
    }

    function c(t, e) {
      var n = e - t;
      return n ? u(t, n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n) : s(isNaN(t) ? e : t);
    }

    function h(t) {
      return 1 == (t = +t) ? f : function (e, n) {
        return n - e ? function (t, e, n) {
          return t = Math.pow(t, n), e = Math.pow(e, n) - t, n = 1 / n, function (r) {
            return Math.pow(t + r * e, n);
          };
        }(e, n, t) : s(isNaN(e) ? n : e);
      };
    }

    function f(t, e) {
      var n = e - t;
      return n ? u(t, n) : s(isNaN(t) ? e : t);
    }

    var l = function t(e) {
      var n = h(e);

      function i(t, e) {
        var i = n((t = Object(r.h)(t)).r, (e = Object(r.h)(e)).r),
            a = n(t.g, e.g),
            o = n(t.b, e.b),
            s = f(t.opacity, e.opacity);
        return function (e) {
          return t.r = i(e), t.g = a(e), t.b = o(e), t.opacity = s(e), t + "";
        };
      }

      return i.gamma = t, i;
    }(1);

    function p(t) {
      return function (e) {
        var n,
            i,
            a = e.length,
            o = new Array(a),
            s = new Array(a),
            u = new Array(a);

        for (n = 0; n < a; ++n) {
          i = Object(r.h)(e[n]), o[n] = i.r || 0, s[n] = i.g || 0, u[n] = i.b || 0;
        }

        return o = t(o), s = t(s), u = t(u), i.opacity = 1, function (t) {
          return i.r = o(t), i.g = s(t), i.b = u(t), i + "";
        };
      };
    }

    var d = p(a),
        g = p(o),
        v = function v(t, e) {
      var n,
          r = e ? e.length : 0,
          i = t ? Math.min(r, t.length) : 0,
          a = new Array(i),
          o = new Array(r);

      for (n = 0; n < i; ++n) {
        a[n] = P(t[n], e[n]);
      }

      for (; n < r; ++n) {
        o[n] = e[n];
      }

      return function (t) {
        for (n = 0; n < i; ++n) {
          o[n] = a[n](t);
        }

        return o;
      };
    },
        m = function m(t, e) {
      var n = new Date();
      return e -= t = +t, function (r) {
        return n.setTime(t + e * r), n;
      };
    },
        x = function x(t, e) {
      return e -= t = +t, function (n) {
        return t + e * n;
      };
    },
        y = function y(t, e) {
      var n,
          r = {},
          i = {};

      for (n in null !== t && "object" == _typeof(t) || (t = {}), null !== e && "object" == _typeof(e) || (e = {}), e) {
        n in t ? r[n] = P(t[n], e[n]) : i[n] = e[n];
      }

      return function (t) {
        for (n in r) {
          i[n] = r[n](t);
        }

        return i;
      };
    },
        b = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        M = new RegExp(b.source, "g");

    var w,
        _,
        E,
        S,
        A = function A(t, e) {
      var n,
          r,
          i,
          a = b.lastIndex = M.lastIndex = 0,
          o = -1,
          s = [],
          u = [];

      for (t += "", e += ""; (n = b.exec(t)) && (r = M.exec(e));) {
        (i = r.index) > a && (i = e.slice(a, i), s[o] ? s[o] += i : s[++o] = i), (n = n[0]) === (r = r[0]) ? s[o] ? s[o] += r : s[++o] = r : (s[++o] = null, u.push({
          i: o,
          x: x(n, r)
        })), a = M.lastIndex;
      }

      return a < e.length && (i = e.slice(a), s[o] ? s[o] += i : s[++o] = i), s.length < 2 ? u[0] ? function (t) {
        return function (e) {
          return t(e) + "";
        };
      }(u[0].x) : function (t) {
        return function () {
          return t;
        };
      }(e) : (e = u.length, function (t) {
        for (var n, r = 0; r < e; ++r) {
          s[(n = u[r]).i] = n.x(t);
        }

        return s.join("");
      });
    },
        P = function P(t, e) {
      var n,
          i = _typeof(e);

      return null == e || "boolean" === i ? s(e) : ("number" === i ? x : "string" === i ? (n = Object(r.a)(e)) ? (e = n, l) : A : e instanceof r.a ? l : e instanceof Date ? m : Array.isArray(e) ? v : "function" != typeof e.valueOf && "function" != typeof e.toString || isNaN(e) ? y : x)(t, e);
    },
        O = function O(t, e) {
      return e -= t = +t, function (n) {
        return Math.round(t + e * n);
      };
    },
        C = 180 / Math.PI,
        I = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    },
        T = function T(t, e, n, r, i, a) {
      var o, s, u;
      return (o = Math.sqrt(t * t + e * e)) && (t /= o, e /= o), (u = t * n + e * r) && (n -= t * u, r -= e * u), (s = Math.sqrt(n * n + r * r)) && (n /= s, r /= s, u /= s), t * r < e * n && (t = -t, e = -e, u = -u, o = -o), {
        translateX: i,
        translateY: a,
        rotate: Math.atan2(e, t) * C,
        skewX: Math.atan(u) * C,
        scaleX: o,
        scaleY: s
      };
    };

    function k(t, e, n, r) {
      function i(t) {
        return t.length ? t.pop() + " " : "";
      }

      return function (a, o) {
        var s = [],
            u = [];
        return a = t(a), o = t(o), function (t, r, i, a, o, s) {
          if (t !== i || r !== a) {
            var u = o.push("translate(", null, e, null, n);
            s.push({
              i: u - 4,
              x: x(t, i)
            }, {
              i: u - 2,
              x: x(r, a)
            });
          } else (i || a) && o.push("translate(" + i + e + a + n);
        }(a.translateX, a.translateY, o.translateX, o.translateY, s, u), function (t, e, n, a) {
          t !== e ? (t - e > 180 ? e += 360 : e - t > 180 && (t += 360), a.push({
            i: n.push(i(n) + "rotate(", null, r) - 2,
            x: x(t, e)
          })) : e && n.push(i(n) + "rotate(" + e + r);
        }(a.rotate, o.rotate, s, u), function (t, e, n, a) {
          t !== e ? a.push({
            i: n.push(i(n) + "skewX(", null, r) - 2,
            x: x(t, e)
          }) : e && n.push(i(n) + "skewX(" + e + r);
        }(a.skewX, o.skewX, s, u), function (t, e, n, r, a, o) {
          if (t !== n || e !== r) {
            var s = a.push(i(a) + "scale(", null, ",", null, ")");
            o.push({
              i: s - 4,
              x: x(t, n)
            }, {
              i: s - 2,
              x: x(e, r)
            });
          } else 1 === n && 1 === r || a.push(i(a) + "scale(" + n + "," + r + ")");
        }(a.scaleX, a.scaleY, o.scaleX, o.scaleY, s, u), a = o = null, function (t) {
          for (var e, n = -1, r = u.length; ++n < r;) {
            s[(e = u[n]).i] = e.x(t);
          }

          return s.join("");
        };
      };
    }

    var N = k(function (t) {
      return "none" === t ? I : (w || (w = document.createElement("DIV"), _ = document.documentElement, E = document.defaultView), w.style.transform = t, t = E.getComputedStyle(_.appendChild(w), null).getPropertyValue("transform"), _.removeChild(w), t = t.slice(7, -1).split(","), T(+t[0], +t[1], +t[2], +t[3], +t[4], +t[5]));
    }, "px, ", "px)", "deg)"),
        L = k(function (t) {
      return null == t ? I : (S || (S = document.createElementNS("http://www.w3.org/2000/svg", "g")), S.setAttribute("transform", t), (t = S.transform.baseVal.consolidate()) ? (t = t.matrix, T(t.a, t.b, t.c, t.d, t.e, t.f)) : I);
    }, ", ", ")", ")"),
        B = Math.SQRT2;

    function j(t) {
      return ((t = Math.exp(t)) + 1 / t) / 2;
    }

    var D = function D(t, e) {
      var n,
          r,
          i = t[0],
          a = t[1],
          o = t[2],
          s = e[0],
          u = e[1],
          c = e[2],
          h = s - i,
          f = u - a,
          l = h * h + f * f;
      if (l < 1e-12) r = Math.log(c / o) / B, n = function n(t) {
        return [i + t * h, a + t * f, o * Math.exp(B * t * r)];
      };else {
        var p = Math.sqrt(l),
            d = (c * c - o * o + 4 * l) / (2 * o * 2 * p),
            g = (c * c - o * o - 4 * l) / (2 * c * 2 * p),
            v = Math.log(Math.sqrt(d * d + 1) - d),
            m = Math.log(Math.sqrt(g * g + 1) - g);
        r = (m - v) / B, n = function n(t) {
          var e = t * r,
              n = j(v),
              s = o / (2 * p) * (n * function (t) {
            return ((t = Math.exp(2 * t)) - 1) / (t + 1);
          }(B * e + v) - function (t) {
            return ((t = Math.exp(t)) - 1 / t) / 2;
          }(v));

          return [i + s * h, a + s * f, o * n / j(B * e + v)];
        };
      }
      return n.duration = 1e3 * r, n;
    };

    function R(t) {
      return function (e, n) {
        var i = t((e = Object(r.e)(e)).h, (n = Object(r.e)(n)).h),
            a = f(e.s, n.s),
            o = f(e.l, n.l),
            s = f(e.opacity, n.opacity);
        return function (t) {
          return e.h = i(t), e.s = a(t), e.l = o(t), e.opacity = s(t), e + "";
        };
      };
    }

    var F = R(c),
        Y = R(f);

    function X(t, e) {
      var n = f((t = Object(r.f)(t)).l, (e = Object(r.f)(e)).l),
          i = f(t.a, e.a),
          a = f(t.b, e.b),
          o = f(t.opacity, e.opacity);
      return function (e) {
        return t.l = n(e), t.a = i(e), t.b = a(e), t.opacity = o(e), t + "";
      };
    }

    function G(t) {
      return function (e, n) {
        var i = t((e = Object(r.d)(e)).h, (n = Object(r.d)(n)).h),
            a = f(e.c, n.c),
            o = f(e.l, n.l),
            s = f(e.opacity, n.opacity);
        return function (t) {
          return e.h = i(t), e.c = a(t), e.l = o(t), e.opacity = s(t), e + "";
        };
      };
    }

    var q = G(c),
        U = G(f);

    function H(t) {
      return function e(n) {
        function i(e, i) {
          var a = t((e = Object(r.b)(e)).h, (i = Object(r.b)(i)).h),
              o = f(e.s, i.s),
              s = f(e.l, i.l),
              u = f(e.opacity, i.opacity);
          return function (t) {
            return e.h = a(t), e.s = o(t), e.l = s(Math.pow(t, n)), e.opacity = u(t), e + "";
          };
        }

        return n = +n, i.gamma = e, i;
      }(1);
    }

    var V = H(c),
        z = H(f),
        W = function W(t, e) {
      for (var n = new Array(e), r = 0; r < e; ++r) {
        n[r] = t(r / (e - 1));
      }

      return n;
    };

    n.d(e, "interpolate", function () {
      return P;
    }), n.d(e, "interpolateArray", function () {
      return v;
    }), n.d(e, "interpolateBasis", function () {
      return a;
    }), n.d(e, "interpolateBasisClosed", function () {
      return o;
    }), n.d(e, "interpolateDate", function () {
      return m;
    }), n.d(e, "interpolateNumber", function () {
      return x;
    }), n.d(e, "interpolateObject", function () {
      return y;
    }), n.d(e, "interpolateRound", function () {
      return O;
    }), n.d(e, "interpolateString", function () {
      return A;
    }), n.d(e, "interpolateTransformCss", function () {
      return N;
    }), n.d(e, "interpolateTransformSvg", function () {
      return L;
    }), n.d(e, "interpolateZoom", function () {
      return D;
    }), n.d(e, "interpolateRgb", function () {
      return l;
    }), n.d(e, "interpolateRgbBasis", function () {
      return d;
    }), n.d(e, "interpolateRgbBasisClosed", function () {
      return g;
    }), n.d(e, "interpolateHsl", function () {
      return F;
    }), n.d(e, "interpolateHslLong", function () {
      return Y;
    }), n.d(e, "interpolateLab", function () {
      return X;
    }), n.d(e, "interpolateHcl", function () {
      return q;
    }), n.d(e, "interpolateHclLong", function () {
      return U;
    }), n.d(e, "interpolateCubehelix", function () {
      return V;
    }), n.d(e, "interpolateCubehelixLong", function () {
      return z;
    }), n.d(e, "quantize", function () {
      return W;
    });
  },,,,,,,,, function (t, e, n) {
    var r = n(609);
    t.exports = {
      track: !1,
      defaultNodeSize: 40,
      labelStyle: {
        fill: "#595959",
        textAlign: "center",
        textBaseline: "middle"
      },
      groupStyle: {
        stroke: "#CED4D9",
        fill: "#F2F4F5",
        radius: 2
      },
      groupBackgroundPadding: [40, 10, 10, 10],
      updateDuration: 450,
      enterDuration: 450,
      leaveDuration: 450,
      updateEasing: "easeQuadOut",
      enterEasing: "easeQuadOut",
      leaveEasing: "easeQuadOut",
      version: r
    };
  }, function (t, e, n) {
    t.exports = {
      Canvas: n(747),
      Group: n(642),
      Shape: n(58),
      Arc: n(638),
      Circle: n(637),
      Dom: n(636),
      Ellipse: n(635),
      Fan: n(634),
      Image: n(633),
      Line: n(632),
      Marker: n(611),
      Path: n(631),
      Polygon: n(630),
      Polyline: n(629),
      Rect: n(628),
      Text: n(627),
      PathSegment: n(600),
      PathUtil: n(610),
      Event: n(643),
      version: "3.3.5"
    };
  }, function (t, e) {
    var n = Object.prototype.toString;

    t.exports = function (t) {
      return n.call(t);
    };
  }, function (t, e, n) {
    var r = n(38),
        i = Object.prototype,
        a = i.hasOwnProperty,
        o = i.toString,
        s = r ? r.toStringTag : void 0;

    t.exports = function (t) {
      var e = a.call(t, s),
          n = t[s];

      try {
        t[s] = void 0;
        var r = !0;
      } catch (t) {}

      var i = o.call(t);
      return r && (e ? t[s] = n : delete t[s]), i;
    };
  }, function (t, e, n) {
    var r = n(16),
        i = n(39),
        a = NaN,
        o = /^\s+|\s+$/g,
        s = /^[-+]0x[0-9a-f]+$/i,
        u = /^0b[01]+$/i,
        c = /^0o[0-7]+$/i,
        h = parseInt;

    t.exports = function (t) {
      if ("number" == typeof t) return t;
      if (i(t)) return a;

      if (r(t)) {
        var e = "function" == typeof t.valueOf ? t.valueOf() : t;
        t = r(e) ? e + "" : e;
      }

      if ("string" != typeof t) return 0 === t ? t : +t;
      t = t.replace(o, "");
      var n = u.test(t);
      return n || c.test(t) ? h(t.slice(2), n ? 2 : 8) : s.test(t) ? a : +t;
    };
  }, function (t, e) {
    var n;

    n = function () {
      return this;
    }();

    try {
      n = n || Function("return this")() || (0, eval)("this");
    } catch (t) {
      "object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && (n = window);
    }

    t.exports = n;
  }, function (t, e, n) {
    var r = n(20);

    t.exports = function () {
      return r.Date.now();
    };
  }, function (t, e, n) {
    "use strict";

    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.forEach = e.sqrLen = e.len = e.sqrDist = e.dist = e.div = e.mul = e.sub = void 0, e.create = i, e.clone = function (t) {
      var e = new r.ARRAY_TYPE(3);
      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;
    }, e.length = a, e.fromValues = o, e.copy = function (t, e) {
      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t;
    }, e.set = function (t, e, n, r) {
      return t[0] = e, t[1] = n, t[2] = r, t;
    }, e.add = function (t, e, n) {
      return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t;
    }, e.subtract = s, e.multiply = u, e.divide = c, e.ceil = function (t, e) {
      return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t[2] = Math.ceil(e[2]), t;
    }, e.floor = function (t, e) {
      return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t[2] = Math.floor(e[2]), t;
    }, e.min = function (t, e, n) {
      return t[0] = Math.min(e[0], n[0]), t[1] = Math.min(e[1], n[1]), t[2] = Math.min(e[2], n[2]), t;
    }, e.max = function (t, e, n) {
      return t[0] = Math.max(e[0], n[0]), t[1] = Math.max(e[1], n[1]), t[2] = Math.max(e[2], n[2]), t;
    }, e.round = function (t, e) {
      return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t[2] = Math.round(e[2]), t;
    }, e.scale = function (t, e, n) {
      return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t;
    }, e.scaleAndAdd = function (t, e, n, r) {
      return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t;
    }, e.distance = h, e.squaredDistance = f, e.squaredLength = l, e.negate = function (t, e) {
      return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t;
    }, e.inverse = function (t, e) {
      return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t;
    }, e.normalize = p, e.dot = d, e.cross = function (t, e, n) {
      var r = e[0],
          i = e[1],
          a = e[2],
          o = n[0],
          s = n[1],
          u = n[2];
      return t[0] = i * u - a * s, t[1] = a * o - r * u, t[2] = r * s - i * o, t;
    }, e.lerp = function (t, e, n, r) {
      var i = e[0],
          a = e[1],
          o = e[2];
      return t[0] = i + r * (n[0] - i), t[1] = a + r * (n[1] - a), t[2] = o + r * (n[2] - o), t;
    }, e.hermite = function (t, e, n, r, i, a) {
      var o = a * a,
          s = o * (2 * a - 3) + 1,
          u = o * (a - 2) + a,
          c = o * (a - 1),
          h = o * (3 - 2 * a);
      return t[0] = e[0] * s + n[0] * u + r[0] * c + i[0] * h, t[1] = e[1] * s + n[1] * u + r[1] * c + i[1] * h, t[2] = e[2] * s + n[2] * u + r[2] * c + i[2] * h, t;
    }, e.bezier = function (t, e, n, r, i, a) {
      var o = 1 - a,
          s = o * o,
          u = a * a,
          c = s * o,
          h = 3 * a * s,
          f = 3 * u * o,
          l = u * a;
      return t[0] = e[0] * c + n[0] * h + r[0] * f + i[0] * l, t[1] = e[1] * c + n[1] * h + r[1] * f + i[1] * l, t[2] = e[2] * c + n[2] * h + r[2] * f + i[2] * l, t;
    }, e.random = function (t, e) {
      e = e || 1;
      var n = 2 * r.RANDOM() * Math.PI,
          i = 2 * r.RANDOM() - 1,
          a = Math.sqrt(1 - i * i) * e;
      return t[0] = Math.cos(n) * a, t[1] = Math.sin(n) * a, t[2] = i * e, t;
    }, e.transformMat4 = function (t, e, n) {
      var r = e[0],
          i = e[1],
          a = e[2],
          o = n[3] * r + n[7] * i + n[11] * a + n[15];
      return o = o || 1, t[0] = (n[0] * r + n[4] * i + n[8] * a + n[12]) / o, t[1] = (n[1] * r + n[5] * i + n[9] * a + n[13]) / o, t[2] = (n[2] * r + n[6] * i + n[10] * a + n[14]) / o, t;
    }, e.transformMat3 = function (t, e, n) {
      var r = e[0],
          i = e[1],
          a = e[2];
      return t[0] = r * n[0] + i * n[3] + a * n[6], t[1] = r * n[1] + i * n[4] + a * n[7], t[2] = r * n[2] + i * n[5] + a * n[8], t;
    }, e.transformQuat = function (t, e, n) {
      var r = n[0],
          i = n[1],
          a = n[2],
          o = n[3],
          s = e[0],
          u = e[1],
          c = e[2],
          h = i * c - a * u,
          f = a * s - r * c,
          l = r * u - i * s,
          p = i * l - a * f,
          d = a * h - r * l,
          g = r * f - i * h,
          v = 2 * o;
      return h *= v, f *= v, l *= v, p *= 2, d *= 2, g *= 2, t[0] = s + h + p, t[1] = u + f + d, t[2] = c + l + g, t;
    }, e.rotateX = function (t, e, n, r) {
      var i = [],
          a = [];
      return i[0] = e[0] - n[0], i[1] = e[1] - n[1], i[2] = e[2] - n[2], a[0] = i[0], a[1] = i[1] * Math.cos(r) - i[2] * Math.sin(r), a[2] = i[1] * Math.sin(r) + i[2] * Math.cos(r), t[0] = a[0] + n[0], t[1] = a[1] + n[1], t[2] = a[2] + n[2], t;
    }, e.rotateY = function (t, e, n, r) {
      var i = [],
          a = [];
      return i[0] = e[0] - n[0], i[1] = e[1] - n[1], i[2] = e[2] - n[2], a[0] = i[2] * Math.sin(r) + i[0] * Math.cos(r), a[1] = i[1], a[2] = i[2] * Math.cos(r) - i[0] * Math.sin(r), t[0] = a[0] + n[0], t[1] = a[1] + n[1], t[2] = a[2] + n[2], t;
    }, e.rotateZ = function (t, e, n, r) {
      var i = [],
          a = [];
      return i[0] = e[0] - n[0], i[1] = e[1] - n[1], i[2] = e[2] - n[2], a[0] = i[0] * Math.cos(r) - i[1] * Math.sin(r), a[1] = i[0] * Math.sin(r) + i[1] * Math.cos(r), a[2] = i[2], t[0] = a[0] + n[0], t[1] = a[1] + n[1], t[2] = a[2] + n[2], t;
    }, e.angle = function (t, e) {
      var n = o(t[0], t[1], t[2]),
          r = o(e[0], e[1], e[2]);
      p(n, n), p(r, r);
      var i = d(n, r);
      return i > 1 ? 0 : i < -1 ? Math.PI : Math.acos(i);
    }, e.str = function (t) {
      return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")";
    }, e.exactEquals = function (t, e) {
      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2];
    }, e.equals = function (t, e) {
      var n = t[0],
          i = t[1],
          a = t[2],
          o = e[0],
          s = e[1],
          u = e[2];
      return Math.abs(n - o) <= r.EPSILON * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(i - s) <= r.EPSILON * Math.max(1, Math.abs(i), Math.abs(s)) && Math.abs(a - u) <= r.EPSILON * Math.max(1, Math.abs(a), Math.abs(u));
    };

    var r = function (t) {
      if (t && t.__esModule) return t;
      var e = {};
      if (null != t) for (var n in t) {
        Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
      }
      return e.default = t, e;
    }(n(59));

    function i() {
      var t = new r.ARRAY_TYPE(3);
      return r.ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;
    }

    function a(t) {
      var e = t[0],
          n = t[1],
          r = t[2];
      return Math.sqrt(e * e + n * n + r * r);
    }

    function o(t, e, n) {
      var i = new r.ARRAY_TYPE(3);
      return i[0] = t, i[1] = e, i[2] = n, i;
    }

    function s(t, e, n) {
      return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t;
    }

    function u(t, e, n) {
      return t[0] = e[0] * n[0], t[1] = e[1] * n[1], t[2] = e[2] * n[2], t;
    }

    function c(t, e, n) {
      return t[0] = e[0] / n[0], t[1] = e[1] / n[1], t[2] = e[2] / n[2], t;
    }

    function h(t, e) {
      var n = e[0] - t[0],
          r = e[1] - t[1],
          i = e[2] - t[2];
      return Math.sqrt(n * n + r * r + i * i);
    }

    function f(t, e) {
      var n = e[0] - t[0],
          r = e[1] - t[1],
          i = e[2] - t[2];
      return n * n + r * r + i * i;
    }

    function l(t) {
      var e = t[0],
          n = t[1],
          r = t[2];
      return e * e + n * n + r * r;
    }

    function p(t, e) {
      var n = e[0],
          r = e[1],
          i = e[2],
          a = n * n + r * r + i * i;
      return a > 0 && (a = 1 / Math.sqrt(a), t[0] = e[0] * a, t[1] = e[1] * a, t[2] = e[2] * a), t;
    }

    function d(t, e) {
      return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
    }

    e.sub = s, e.mul = u, e.div = c, e.dist = h, e.sqrDist = f, e.len = a, e.sqrLen = l, e.forEach = function () {
      var t = i();
      return function (e, n, r, i, a, o) {
        var s = void 0,
            u = void 0;

        for (n || (n = 3), r || (r = 0), u = i ? Math.min(i * n + r, e.length) : e.length, s = r; s < u; s += n) {
          t[0] = e[s], t[1] = e[s + 1], t[2] = e[s + 2], a(t, t, o), e[s] = t[0], e[s + 1] = t[1], e[s + 2] = t[2];
        }

        return e;
      };
    }();
  }, function (t, e, n) {
    "use strict";

    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.forEach = e.sqrLen = e.sqrDist = e.dist = e.div = e.mul = e.sub = e.len = void 0, e.create = i, e.clone = function (t) {
      var e = new r.ARRAY_TYPE(2);
      return e[0] = t[0], e[1] = t[1], e;
    }, e.fromValues = function (t, e) {
      var n = new r.ARRAY_TYPE(2);
      return n[0] = t, n[1] = e, n;
    }, e.copy = function (t, e) {
      return t[0] = e[0], t[1] = e[1], t;
    }, e.set = function (t, e, n) {
      return t[0] = e, t[1] = n, t;
    }, e.add = function (t, e, n) {
      return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t;
    }, e.subtract = a, e.multiply = o, e.divide = s, e.ceil = function (t, e) {
      return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t;
    }, e.floor = function (t, e) {
      return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t;
    }, e.min = function (t, e, n) {
      return t[0] = Math.min(e[0], n[0]), t[1] = Math.min(e[1], n[1]), t;
    }, e.max = function (t, e, n) {
      return t[0] = Math.max(e[0], n[0]), t[1] = Math.max(e[1], n[1]), t;
    }, e.round = function (t, e) {
      return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t;
    }, e.scale = function (t, e, n) {
      return t[0] = e[0] * n, t[1] = e[1] * n, t;
    }, e.scaleAndAdd = function (t, e, n, r) {
      return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t;
    }, e.distance = u, e.squaredDistance = c, e.length = h, e.squaredLength = f, e.negate = function (t, e) {
      return t[0] = -e[0], t[1] = -e[1], t;
    }, e.inverse = function (t, e) {
      return t[0] = 1 / e[0], t[1] = 1 / e[1], t;
    }, e.normalize = function (t, e) {
      var n = e[0],
          r = e[1],
          i = n * n + r * r;
      i > 0 && (i = 1 / Math.sqrt(i), t[0] = e[0] * i, t[1] = e[1] * i);
      return t;
    }, e.dot = function (t, e) {
      return t[0] * e[0] + t[1] * e[1];
    }, e.cross = function (t, e, n) {
      var r = e[0] * n[1] - e[1] * n[0];
      return t[0] = t[1] = 0, t[2] = r, t;
    }, e.lerp = function (t, e, n, r) {
      var i = e[0],
          a = e[1];
      return t[0] = i + r * (n[0] - i), t[1] = a + r * (n[1] - a), t;
    }, e.random = function (t, e) {
      e = e || 1;
      var n = 2 * r.RANDOM() * Math.PI;
      return t[0] = Math.cos(n) * e, t[1] = Math.sin(n) * e, t;
    }, e.transformMat2 = function (t, e, n) {
      var r = e[0],
          i = e[1];
      return t[0] = n[0] * r + n[2] * i, t[1] = n[1] * r + n[3] * i, t;
    }, e.transformMat2d = function (t, e, n) {
      var r = e[0],
          i = e[1];
      return t[0] = n[0] * r + n[2] * i + n[4], t[1] = n[1] * r + n[3] * i + n[5], t;
    }, e.transformMat3 = function (t, e, n) {
      var r = e[0],
          i = e[1];
      return t[0] = n[0] * r + n[3] * i + n[6], t[1] = n[1] * r + n[4] * i + n[7], t;
    }, e.transformMat4 = function (t, e, n) {
      var r = e[0],
          i = e[1];
      return t[0] = n[0] * r + n[4] * i + n[12], t[1] = n[1] * r + n[5] * i + n[13], t;
    }, e.rotate = function (t, e, n, r) {
      var i = e[0] - n[0],
          a = e[1] - n[1],
          o = Math.sin(r),
          s = Math.cos(r);
      return t[0] = i * s - a * o + n[0], t[1] = i * o + a * s + n[1], t;
    }, e.angle = function (t, e) {
      var n = t[0],
          r = t[1],
          i = e[0],
          a = e[1],
          o = n * n + r * r;
      o > 0 && (o = 1 / Math.sqrt(o));
      var s = i * i + a * a;
      s > 0 && (s = 1 / Math.sqrt(s));
      var u = (n * i + r * a) * o * s;
      return u > 1 ? 0 : u < -1 ? Math.PI : Math.acos(u);
    }, e.str = function (t) {
      return "vec2(" + t[0] + ", " + t[1] + ")";
    }, e.exactEquals = function (t, e) {
      return t[0] === e[0] && t[1] === e[1];
    }, e.equals = function (t, e) {
      var n = t[0],
          i = t[1],
          a = e[0],
          o = e[1];
      return Math.abs(n - a) <= r.EPSILON * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(i - o) <= r.EPSILON * Math.max(1, Math.abs(i), Math.abs(o));
    };

    var r = function (t) {
      if (t && t.__esModule) return t;
      var e = {};
      if (null != t) for (var n in t) {
        Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
      }
      return e.default = t, e;
    }(n(59));

    function i() {
      var t = new r.ARRAY_TYPE(2);
      return r.ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0), t;
    }

    function a(t, e, n) {
      return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t;
    }

    function o(t, e, n) {
      return t[0] = e[0] * n[0], t[1] = e[1] * n[1], t;
    }

    function s(t, e, n) {
      return t[0] = e[0] / n[0], t[1] = e[1] / n[1], t;
    }

    function u(t, e) {
      var n = e[0] - t[0],
          r = e[1] - t[1];
      return Math.sqrt(n * n + r * r);
    }

    function c(t, e) {
      var n = e[0] - t[0],
          r = e[1] - t[1];
      return n * n + r * r;
    }

    function h(t) {
      var e = t[0],
          n = t[1];
      return Math.sqrt(e * e + n * n);
    }

    function f(t) {
      var e = t[0],
          n = t[1];
      return e * e + n * n;
    }

    e.len = h, e.sub = a, e.mul = o, e.div = s, e.dist = u, e.sqrDist = c, e.sqrLen = f, e.forEach = function () {
      var t = i();
      return function (e, n, r, i, a, o) {
        var s = void 0,
            u = void 0;

        for (n || (n = 2), r || (r = 0), u = i ? Math.min(i * n + r, e.length) : e.length, s = r; s < u; s += n) {
          t[0] = e[s], t[1] = e[s + 1], a(t, t, o), e[s] = t[0], e[s + 1] = t[1];
        }

        return e;
      };
    }();
  }, function (t, e, n) {
    "use strict";

    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.sub = e.mul = void 0, e.create = function () {
      var t = new r.ARRAY_TYPE(9);
      r.ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0);
      return t[0] = 1, t[4] = 1, t[8] = 1, t;
    }, e.fromMat4 = function (t, e) {
      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t;
    }, e.clone = function (t) {
      var e = new r.ARRAY_TYPE(9);
      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e;
    }, e.copy = function (t, e) {
      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;
    }, e.fromValues = function (t, e, n, i, a, o, s, u, c) {
      var h = new r.ARRAY_TYPE(9);
      return h[0] = t, h[1] = e, h[2] = n, h[3] = i, h[4] = a, h[5] = o, h[6] = s, h[7] = u, h[8] = c, h;
    }, e.set = function (t, e, n, r, i, a, o, s, u, c) {
      return t[0] = e, t[1] = n, t[2] = r, t[3] = i, t[4] = a, t[5] = o, t[6] = s, t[7] = u, t[8] = c, t;
    }, e.identity = function (t) {
      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
    }, e.transpose = function (t, e) {
      if (t === e) {
        var n = e[1],
            r = e[2],
            i = e[5];
        t[1] = e[3], t[2] = e[6], t[3] = n, t[5] = e[7], t[6] = r, t[7] = i;
      } else t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8];

      return t;
    }, e.invert = function (t, e) {
      var n = e[0],
          r = e[1],
          i = e[2],
          a = e[3],
          o = e[4],
          s = e[5],
          u = e[6],
          c = e[7],
          h = e[8],
          f = h * o - s * c,
          l = -h * a + s * u,
          p = c * a - o * u,
          d = n * f + r * l + i * p;
      if (!d) return null;
      return d = 1 / d, t[0] = f * d, t[1] = (-h * r + i * c) * d, t[2] = (s * r - i * o) * d, t[3] = l * d, t[4] = (h * n - i * u) * d, t[5] = (-s * n + i * a) * d, t[6] = p * d, t[7] = (-c * n + r * u) * d, t[8] = (o * n - r * a) * d, t;
    }, e.adjoint = function (t, e) {
      var n = e[0],
          r = e[1],
          i = e[2],
          a = e[3],
          o = e[4],
          s = e[5],
          u = e[6],
          c = e[7],
          h = e[8];
      return t[0] = o * h - s * c, t[1] = i * c - r * h, t[2] = r * s - i * o, t[3] = s * u - a * h, t[4] = n * h - i * u, t[5] = i * a - n * s, t[6] = a * c - o * u, t[7] = r * u - n * c, t[8] = n * o - r * a, t;
    }, e.determinant = function (t) {
      var e = t[0],
          n = t[1],
          r = t[2],
          i = t[3],
          a = t[4],
          o = t[5],
          s = t[6],
          u = t[7],
          c = t[8];
      return e * (c * a - o * u) + n * (-c * i + o * s) + r * (u * i - a * s);
    }, e.multiply = i, e.translate = function (t, e, n) {
      var r = e[0],
          i = e[1],
          a = e[2],
          o = e[3],
          s = e[4],
          u = e[5],
          c = e[6],
          h = e[7],
          f = e[8],
          l = n[0],
          p = n[1];
      return t[0] = r, t[1] = i, t[2] = a, t[3] = o, t[4] = s, t[5] = u, t[6] = l * r + p * o + c, t[7] = l * i + p * s + h, t[8] = l * a + p * u + f, t;
    }, e.rotate = function (t, e, n) {
      var r = e[0],
          i = e[1],
          a = e[2],
          o = e[3],
          s = e[4],
          u = e[5],
          c = e[6],
          h = e[7],
          f = e[8],
          l = Math.sin(n),
          p = Math.cos(n);
      return t[0] = p * r + l * o, t[1] = p * i + l * s, t[2] = p * a + l * u, t[3] = p * o - l * r, t[4] = p * s - l * i, t[5] = p * u - l * a, t[6] = c, t[7] = h, t[8] = f, t;
    }, e.scale = function (t, e, n) {
      var r = n[0],
          i = n[1];
      return t[0] = r * e[0], t[1] = r * e[1], t[2] = r * e[2], t[3] = i * e[3], t[4] = i * e[4], t[5] = i * e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;
    }, e.fromTranslation = function (t, e) {
      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = e[0], t[7] = e[1], t[8] = 1, t;
    }, e.fromRotation = function (t, e) {
      var n = Math.sin(e),
          r = Math.cos(e);
      return t[0] = r, t[1] = n, t[2] = 0, t[3] = -n, t[4] = r, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
    }, e.fromScaling = function (t, e) {
      return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = e[1], t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
    }, e.fromMat2d = function (t, e) {
      return t[0] = e[0], t[1] = e[1], t[2] = 0, t[3] = e[2], t[4] = e[3], t[5] = 0, t[6] = e[4], t[7] = e[5], t[8] = 1, t;
    }, e.fromQuat = function (t, e) {
      var n = e[0],
          r = e[1],
          i = e[2],
          a = e[3],
          o = n + n,
          s = r + r,
          u = i + i,
          c = n * o,
          h = r * o,
          f = r * s,
          l = i * o,
          p = i * s,
          d = i * u,
          g = a * o,
          v = a * s,
          m = a * u;
      return t[0] = 1 - f - d, t[3] = h - m, t[6] = l + v, t[1] = h + m, t[4] = 1 - c - d, t[7] = p - g, t[2] = l - v, t[5] = p + g, t[8] = 1 - c - f, t;
    }, e.normalFromMat4 = function (t, e) {
      var n = e[0],
          r = e[1],
          i = e[2],
          a = e[3],
          o = e[4],
          s = e[5],
          u = e[6],
          c = e[7],
          h = e[8],
          f = e[9],
          l = e[10],
          p = e[11],
          d = e[12],
          g = e[13],
          v = e[14],
          m = e[15],
          x = n * s - r * o,
          y = n * u - i * o,
          b = n * c - a * o,
          M = r * u - i * s,
          w = r * c - a * s,
          _ = i * c - a * u,
          E = h * g - f * d,
          S = h * v - l * d,
          A = h * m - p * d,
          P = f * v - l * g,
          O = f * m - p * g,
          C = l * m - p * v,
          I = x * C - y * O + b * P + M * A - w * S + _ * E;

      if (!I) return null;
      return I = 1 / I, t[0] = (s * C - u * O + c * P) * I, t[1] = (u * A - o * C - c * S) * I, t[2] = (o * O - s * A + c * E) * I, t[3] = (i * O - r * C - a * P) * I, t[4] = (n * C - i * A + a * S) * I, t[5] = (r * A - n * O - a * E) * I, t[6] = (g * _ - v * w + m * M) * I, t[7] = (v * b - d * _ - m * y) * I, t[8] = (d * w - g * b + m * x) * I, t;
    }, e.projection = function (t, e, n) {
      return t[0] = 2 / e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / n, t[5] = 0, t[6] = -1, t[7] = 1, t[8] = 1, t;
    }, e.str = function (t) {
      return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")";
    }, e.frob = function (t) {
      return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2) + Math.pow(t[4], 2) + Math.pow(t[5], 2) + Math.pow(t[6], 2) + Math.pow(t[7], 2) + Math.pow(t[8], 2));
    }, e.add = function (t, e, n) {
      return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t[4] = e[4] + n[4], t[5] = e[5] + n[5], t[6] = e[6] + n[6], t[7] = e[7] + n[7], t[8] = e[8] + n[8], t;
    }, e.subtract = a, e.multiplyScalar = function (t, e, n) {
      return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * n, t[5] = e[5] * n, t[6] = e[6] * n, t[7] = e[7] * n, t[8] = e[8] * n, t;
    }, e.multiplyScalarAndAdd = function (t, e, n, r) {
      return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t[3] = e[3] + n[3] * r, t[4] = e[4] + n[4] * r, t[5] = e[5] + n[5] * r, t[6] = e[6] + n[6] * r, t[7] = e[7] + n[7] * r, t[8] = e[8] + n[8] * r, t;
    }, e.exactEquals = function (t, e) {
      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8];
    }, e.equals = function (t, e) {
      var n = t[0],
          i = t[1],
          a = t[2],
          o = t[3],
          s = t[4],
          u = t[5],
          c = t[6],
          h = t[7],
          f = t[8],
          l = e[0],
          p = e[1],
          d = e[2],
          g = e[3],
          v = e[4],
          m = e[5],
          x = e[6],
          y = e[7],
          b = e[8];
      return Math.abs(n - l) <= r.EPSILON * Math.max(1, Math.abs(n), Math.abs(l)) && Math.abs(i - p) <= r.EPSILON * Math.max(1, Math.abs(i), Math.abs(p)) && Math.abs(a - d) <= r.EPSILON * Math.max(1, Math.abs(a), Math.abs(d)) && Math.abs(o - g) <= r.EPSILON * Math.max(1, Math.abs(o), Math.abs(g)) && Math.abs(s - v) <= r.EPSILON * Math.max(1, Math.abs(s), Math.abs(v)) && Math.abs(u - m) <= r.EPSILON * Math.max(1, Math.abs(u), Math.abs(m)) && Math.abs(c - x) <= r.EPSILON * Math.max(1, Math.abs(c), Math.abs(x)) && Math.abs(h - y) <= r.EPSILON * Math.max(1, Math.abs(h), Math.abs(y)) && Math.abs(f - b) <= r.EPSILON * Math.max(1, Math.abs(f), Math.abs(b));
    };

    var r = function (t) {
      if (t && t.__esModule) return t;
      var e = {};
      if (null != t) for (var n in t) {
        Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
      }
      return e.default = t, e;
    }(n(59));

    function i(t, e, n) {
      var r = e[0],
          i = e[1],
          a = e[2],
          o = e[3],
          s = e[4],
          u = e[5],
          c = e[6],
          h = e[7],
          f = e[8],
          l = n[0],
          p = n[1],
          d = n[2],
          g = n[3],
          v = n[4],
          m = n[5],
          x = n[6],
          y = n[7],
          b = n[8];
      return t[0] = l * r + p * o + d * c, t[1] = l * i + p * s + d * h, t[2] = l * a + p * u + d * f, t[3] = g * r + v * o + m * c, t[4] = g * i + v * s + m * h, t[5] = g * a + v * u + m * f, t[6] = x * r + y * o + b * c, t[7] = x * i + y * s + b * h, t[8] = x * a + y * u + b * f, t;
    }

    function a(t, e, n) {
      return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t[4] = e[4] - n[4], t[5] = e[5] - n[5], t[6] = e[6] - n[6], t[7] = e[7] - n[7], t[8] = e[8] - n[8], t;
    }

    e.mul = i, e.sub = a;
  }, function (t, e, n) {
    function r(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : t[e] = n, t;
    }

    var i = 5,
        a = n(819);

    Math.sign = function (t) {
      return 0 === (t = +t) || isNaN(t) ? t : t > 0 ? 1 : -1;
    };

    var o = function (t) {
      for (var e = 1; e < arguments.length; e++) {
        var n = null != arguments[e] ? arguments[e] : {},
            i = Object.keys(n);
        "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter(function (t) {
          return Object.getOwnPropertyDescriptor(n, t).enumerable;
        }))), i.forEach(function (e) {
          r(t, e, n[e]);
        });
      }

      return t;
    }({}, a, {
      throttle: n(749),
      debounce: n(645),
      omit: function omit(t, e) {
        var n = {};
        return a.each(t, function (t, r) {
          -1 === e.indexOf(r) && (n[r] = t);
        }), n;
      },
      traverseTree: function traverseTree(t, e, n, r) {
        void 0 === r && (r = !1);
        var i = n(t);
        r && e(t, null, null), i && o.each(i, function (r, i) {
          e(r, t, i), o.traverseTree(r, e, n);
        });
      },
      toAllPadding: function toAllPadding(t) {
        var e = 0,
            n = 0,
            r = 0,
            i = 0;
        return o.isNumber(t) || o.isString(t) ? e = n = r = i = t : o.isArray(t) && (e = t[0], r = o.isNil(t[1]) ? t[0] : t[1], i = o.isNil(t[2]) ? t[0] : t[2], n = o.isNil(t[3]) ? r : t[3]), [e, r, i, n];
      },
      guid: function guid() {
        return "xxxxxxxx".replace(/[xy]/g, function (t) {
          var e = 16 * Math.random() | 0;
          return ("x" === t ? e : 3 & e | 8).toString(16);
        });
      },
      mix: function mix() {
        var t,
            e,
            n = o.toArray(arguments),
            r = n[0];
        if (!0 === r) for (r = n[1], e = 2; e < n.length; e++) {
          s(r, t = n[e]);
        } else for (e = 1; e < n.length; e++) {
          for (var i in t = n[e]) {
            t.hasOwnProperty(i) && "constructor" !== i && (r[i] = t[i]);
          }
        }
        return r;
      },
      mixin: function mixin(t, e) {
        if (t && e) {
          t._mixins = e, t.ATTRS = t.ATTRS || {};
          o.each(e, function (e) {
            o.augment(t, e);
          }), t.ATTRS = o.mix({}, t.ATTRS);
        }
      }
    });

    function s(t, e, n) {
      for (var r in n = n || 0, e) {
        if (e.hasOwnProperty(r)) {
          var a = e[r];
          null !== a && o.isPlainObject(a) ? (o.isPlainObject(t[r]) || (t[r] = {}), n < i ? s(t[r], e[r], n + 1) : t[r] = e[r]) : o.isArray(a) ? (t[r] = [], t[r] = t[r].concat(a)) : void 0 !== a && (t[r] = e[r]);
        }
      }
    }

    o.Array = {
      remove: function remove(t, e) {
        var n = o.indexOf(t, e);
        -1 !== n && t.splice(n, 1);
      }
    }, t.exports = o;
  }, function (t, e, n) {
    var r = n(26),
        i = {},
        a = {
      draw: function draw() {}
    },
        o = {
      defaultShapeType: null,
      getShape: function getShape(t, e) {
        return this[t] || this[e] || this[this.defaultShapeType] || a;
      },
      getExtendShape: function getExtendShape(t, e) {
        var n = this;

        if (r.isArray(t)) {
          var i = {};
          return t.forEach(function (t) {
            n[t] && (i = r.mix({}, i, n.getShape(t, e)));
          }), i;
        }

        return this.getShape(t, e);
      }
    };
    i.registerShapeManager = function (t, e) {
      var n = r.mix({}, o, e),
          a = r.upperFirst(t);
      return i[a] = n, i["register" + a] = function (t, e, i, a) {
        r.isNil(i) && r.isNil(a) && (i = t);
        var o = n.getExtendShape(i, a),
            s = r.mix(!0, {}, o, e);
        return s.type = t, n[t] = s, s;
      }, n;
    }, t.exports = i;
  },,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, function (t, e, n) {
    var r = n(19),
        i = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/gi,
        a = /[^\s\,]+/gi;
    t.exports = {
      parseRadius: function parseRadius(t) {
        var e = 0,
            n = 0,
            i = 0,
            a = 0;
        return r.isArray(t) ? 1 === t.length ? e = n = i = a = t[0] : 2 === t.length ? (e = i = t[0], n = a = t[1]) : 3 === t.length ? (e = t[0], n = a = t[1], i = t[2]) : (e = t[0], n = t[1], i = t[2], a = t[3]) : e = n = i = a = t, {
          r1: e,
          r2: n,
          r3: i,
          r4: a
        };
      },
      parsePath: function parsePath(t) {
        return t = t || [], r.isArray(t) ? t : r.isString(t) ? (t = t.match(i), r.each(t, function (e, n) {
          if ((e = e.match(a))[0].length > 1) {
            var i = e[0].charAt(0);
            e.splice(1, 0, e[0].substr(1)), e[0] = i;
          }

          r.each(e, function (t, n) {
            isNaN(t) || (e[n] = +t);
          }), t[n] = e;
        }), t) : void 0;
      }
    };
  }, function (t, e, n) {
    var r = n(237);

    t.exports = function (t) {
      return r(t) ? "" : t.toString();
    };
  }, function (t, e, n) {
    var r = n(115);

    t.exports = function (t) {
      return r(t, "String");
    };
  }, function (t, e, n) {
    var r = n(619),
        i = n(115);

    t.exports = function (t) {
      if (!r(t) || !i(t, "Object")) return !1;
      if (null === Object.getPrototypeOf(t)) return !0;

      for (var e = t; null !== Object.getPrototypeOf(e);) {
        e = Object.getPrototypeOf(e);
      }

      return Object.getPrototypeOf(t) === e;
    };
  }, function (t, e, n) {
    var r = function (t) {
      function e(e) {
        var n;
        return (n = t.call(this) || this).options = e, n;
      }

      return function (t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
      }(e, t), e.prototype.execute = function () {
        var t = this,
            e = this.options;
        this.roots.forEach(function (n) {
          t.layout(n, e).eachNode(function (t) {
            t.data.x = t.x + t.data.width / 2 + t.hgap, t.data.y = t.y + t.data.height / 2 + t.vgap;
          });
        });
      }, e;
    }(n(622));

    t.exports = r;
  }, function (t, e, n) {
    !function (e, n) {
      t.exports = n();
    }("undefined" != typeof self && self, function () {
      return function (t) {
        var e = {};

        function n(r) {
          if (e[r]) return e[r].exports;
          var i = e[r] = {
            i: r,
            l: !1,
            exports: {}
          };
          return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports;
        }

        return n.m = t, n.c = e, n.d = function (t, e, r) {
          n.o(t, e) || Object.defineProperty(t, e, {
            configurable: !1,
            enumerable: !0,
            get: r
          });
        }, n.n = function (t) {
          var e = t && t.__esModule ? function () {
            return t.default;
          } : function () {
            return t;
          };
          return n.d(e, "a", e), e;
        }, n.o = function (t, e) {
          return Object.prototype.hasOwnProperty.call(t, e);
        }, n.p = "", n(n.s = 5);
      }([function (t, e, n) {
        var r = n(7);
        t.exports = {
          assign: r
        };
      }, function (t, e, n) {
        var r = n(3),
            i = function () {
          function t(t, e) {
            void 0 === e && (e = {});
            this.options = e, this.rootNode = r(t, e);
          }

          return t.prototype.execute = function () {
            throw new Error("please override this method");
          }, t;
        }();

        t.exports = i;
      }, function (t, e, n) {
        var r = n(4),
            i = ["LR", "RL", "TB", "BT", "H", "V"],
            a = ["LR", "RL", "H"],
            o = i[0];

        t.exports = function (t, e, n) {
          var s = e.direction || o;
          if (e.isHorizontal = function (t) {
            return a.indexOf(t) > -1;
          }(s), s && -1 === i.indexOf(s)) throw new TypeError("Invalid direction: " + s);
          if (s === i[0]) n(t, e);else if (s === i[1]) n(t, e), t.right2left();else if (s === i[2]) n(t, e);else if (s === i[3]) n(t, e), t.bottom2top();else if (s === i[4] || s === i[5]) {
            var u = r(t, e),
                c = u.left,
                h = u.right;
            n(c, e), n(h, e), e.isHorizontal ? c.right2left() : c.bottom2top(), h.translate(c.x - h.x, c.y - h.y), t.x = c.x, t.y = h.y;
            var f = t.getBoundingBox();
            e.isHorizontal ? f.top < 0 && t.translate(0, -f.top) : f.left < 0 && t.translate(-f.left, 0);
          }
          return t.translate(-(t.x + t.width / 2 + t.hgap), -(t.y + t.height / 2 + t.vgap)), t;
        };
      }, function (t, e, n) {
        var r = n(0),
            i = {
          getId: function getId(t) {
            return t.id || t.name;
          },
          getHGap: function getHGap(t) {
            return t.hgap || 18;
          },
          getVGap: function getVGap(t) {
            return t.vgap || 18;
          },
          getChildren: function getChildren(t) {
            return t.children;
          },
          getHeight: function getHeight(t) {
            return t.height || 36;
          },
          getWidth: function getWidth(t) {
            var e = t.name || " ";
            return t.width || 18 * e.split("").length;
          }
        };

        function a(t, e) {
          var n = this;
          if (n.vgap = n.hgap = 0, t instanceof a) return t;
          n.data = t;
          var r = e.getHGap(t),
              i = e.getVGap(t);
          return n.width = e.getWidth(t), n.height = e.getHeight(t), n.id = e.getId(t), n.x = n.y = 0, n.depth = 0, n.children || (n.children = []), n.addGap(r, i), n;
        }

        r.assign(a.prototype, {
          isRoot: function isRoot() {
            return 0 === this.depth;
          },
          isLeaf: function isLeaf() {
            return 0 === this.children.length;
          },
          addGap: function addGap(t, e) {
            this.hgap += t, this.vgap += e, this.width += 2 * t, this.height += 2 * e;
          },
          eachNode: function eachNode(t) {
            for (var e, n = [this]; e = n.pop();) {
              t(e), n = n.concat(e.children);
            }
          },
          DFTraverse: function DFTraverse(t) {
            this.eachNode(t);
          },
          BFTraverse: function BFTraverse(t) {
            for (var e, n = [this]; e = n.shift();) {
              t(e), n = n.concat(e.children);
            }
          },
          getBoundingBox: function getBoundingBox() {
            var t = {
              left: Number.MAX_VALUE,
              top: Number.MAX_VALUE,
              width: 0,
              height: 0
            };
            return this.eachNode(function (e) {
              t.left = Math.min(t.left, e.x), t.top = Math.min(t.top, e.y), t.width = Math.max(t.width, e.x + e.width), t.height = Math.max(t.height, e.y + e.height);
            }), t;
          },
          translate: function translate(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), this.eachNode(function (n) {
              n.x += t, n.y += e;
            });
          },
          right2left: function right2left() {
            var t = this.getBoundingBox();
            this.eachNode(function (e) {
              e.x = e.x - 2 * (e.x - t.left) - e.width;
            }), this.translate(t.width, 0);
          },
          bottom2top: function bottom2top() {
            var t = this.getBoundingBox();
            this.eachNode(function (e) {
              e.y = e.y - 2 * (e.y - t.top) - e.height;
            }), this.translate(0, t.height);
          }
        }), t.exports = function (t, e, n) {
          void 0 === e && (e = {});
          var o,
              s = new a(t, e = r.assign({}, i, e)),
              u = [s];
          if (!n && !t.collapsed) for (; o = u.pop();) {
            if (!o.data.collapsed) {
              var c = e.getChildren(o.data),
                  h = c ? c.length : 0;
              if (o.children = new Array(h), c && h) for (var f = 0; f < h; f++) {
                var l = new a(c[f], e);
                o.children[f] = l, u.push(l), l.parent = o, l.depth = o.depth + 1;
              }
            }
          }
          return s;
        };
      }, function (t, e, n) {
        var r = n(3);

        t.exports = function (t, e) {
          for (var n = r(t.data, e, !0), i = r(t.data, e, !0), a = t.children.length, o = Math.round(a / 2), s = e.getSide || function (t, e) {
            return e < o ? "right" : "left";
          }, u = 0; u < a; u++) {
            var c = t.children[u];
            "right" === s(c, u) ? i.children.push(c) : n.children.push(c);
          }

          return n.eachNode(function (t) {
            t.isRoot() || (t.side = "left");
          }), i.eachNode(function (t) {
            t.isRoot() || (t.side = "right");
          }), {
            left: n,
            right: i
          };
        };
      }, function (t, e, n) {
        var r = {
          compactBox: n(6),
          dendrogram: n(9),
          indented: n(11),
          mindmap: n(13)
        };
        t.exports = r;
      }, function (t, e, n) {
        var r = n(1),
            i = n(8),
            a = n(2),
            o = n(0),
            s = function (t) {
          function e() {
            return t.apply(this, arguments) || this;
          }

          return function (t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
          }(e, t), e.prototype.execute = function () {
            return a(this.rootNode, this.options, i);
          }, e;
        }(r),
            u = {};

        t.exports = function (t, e) {
          return e = o.assign({}, u, e), new s(t, e).execute();
        };
      }, function (t, e) {
        function n(t, e) {
          for (var n in e) {
            e.hasOwnProperty(n) && "constructor" !== n && void 0 !== e[n] && (t[n] = e[n]);
          }
        }

        t.exports = function (t, e, r, i) {
          return e && n(t, e), r && n(t, r), i && n(t, i), t;
        };
      }, function (t, e) {
        function n(t, e, n, r) {
          void 0 === r && (r = []);
          var i = this;
          i.w = t || 0, i.h = e || 0, i.y = n || 0, i.x = 0, i.c = r || [], i.cs = r.length, i.prelim = 0, i.mod = 0, i.shift = 0, i.change = 0, i.tl = null, i.tr = null, i.el = null, i.er = null, i.msel = 0, i.mser = 0;
        }

        function r(t, e) {
          !function t(e, n, r) {
            r ? e.y += n : e.x += n, e.children.forEach(function (e) {
              t(e, n, r);
            });
          }(t, -function t(e, n) {
            var r = n ? e.y : e.x;
            return e.children.forEach(function (e) {
              r = Math.min(t(e, n), r);
            }), r;
          }(t, e), e);
        }

        n.fromNode = function (t, e) {
          if (!t) return null;
          var r = [];
          return t.children.forEach(function (t) {
            r.push(n.fromNode(t, e));
          }), e ? new n(t.height, t.width, t.x, r) : new n(t.width, t.height, t.y, r);
        }, t.exports = function (t, e) {
          void 0 === e && (e = {});
          var i = e.isHorizontal;

          function a(t) {
            0 === t.cs ? (t.el = t, t.er = t, t.msel = t.mser = 0) : (t.el = t.c[0].el, t.msel = t.c[0].msel, t.er = t.c[t.cs - 1].er, t.mser = t.c[t.cs - 1].mser);
          }

          function o(t, e, n) {
            for (var r = t.c[e - 1], i = r.mod, a = t.c[e], o = a.mod; null !== r && null !== a;) {
              h(r) > n.low && (n = n.nxt);
              var f = i + r.prelim + r.w - (o + a.prelim);
              f > 0 && (o += f, s(t, e, n.index, f));
              var l = h(r),
                  p = h(a);
              l <= p && null !== (r = c(r)) && (i += r.mod), l >= p && null !== (a = u(a)) && (o += a.mod);
            }

            !r && a ? function (t, e, n, r) {
              var i = t.c[0].el;
              i.tl = n;
              var a = r - n.mod - t.c[0].msel;
              i.mod += a, i.prelim -= a, t.c[0].el = t.c[e].el, t.c[0].msel = t.c[e].msel;
            }(t, e, a, o) : r && !a && function (t, e, n, r) {
              var i = t.c[e].er;
              i.tr = n;
              var a = r - n.mod - t.c[e].mser;
              i.mod += a, i.prelim -= a, t.c[e].er = t.c[e - 1].er, t.c[e].mser = t.c[e - 1].mser;
            }(t, e, r, i);
          }

          function s(t, e, n, r) {
            t.c[e].mod += r, t.c[e].msel += r, t.c[e].mser += r, function (t, e, n, r) {
              if (n !== e - 1) {
                var i = e - n;
                t.c[n + 1].shift += r / i, t.c[e].shift -= r / i, t.c[e].change -= r - r / i;
              }
            }(t, e, n, r);
          }

          function u(t) {
            return 0 === t.cs ? t.tl : t.c[0];
          }

          function c(t) {
            return 0 === t.cs ? t.tr : t.c[t.cs - 1];
          }

          function h(t) {
            return t.y + t.h;
          }

          function f(t, e, n) {
            for (; null !== n && t >= n.low;) {
              n = n.nxt;
            }

            return {
              low: t,
              index: e,
              nxt: n
            };
          }

          !function t(e, n, r) {
            void 0 === r && (r = 0), n ? (e.x = r, r += e.width) : (e.y = r, r += e.height), e.children.forEach(function (e) {
              t(e, n, r);
            });
          }(t, i);
          var l = n.fromNode(t, i);
          return function t(e) {
            if (0 !== e.cs) {
              t(e.c[0]);

              for (var n = f(h(e.c[0].el), 0, null), r = 1; r < e.cs; ++r) {
                t(e.c[r]);
                var i = h(e.c[r].er);
                o(e, r, n), n = f(i, r, n);
              }

              !function (t) {
                t.prelim = (t.c[0].prelim + t.c[0].mod + t.c[t.cs - 1].mod + t.c[t.cs - 1].prelim + t.c[t.cs - 1].w) / 2 - t.w / 2;
              }(e), a(e);
            } else a(e);
          }(l), function t(e, n) {
            n += e.mod, e.x = e.prelim + n, function (t) {
              for (var e = 0, n = 0, r = 0; r < t.cs; r++) {
                e += t.c[r].shift, n += e + t.c[r].change, t.c[r].mod += n;
              }
            }(e);

            for (var r = 0; r < e.cs; r++) {
              t(e.c[r], n);
            }
          }(l, 0), function t(e, n, r) {
            r ? n.y = e.x : n.x = e.x, e.c.forEach(function (e, i) {
              t(e, n.children[i], r);
            });
          }(l, t, i), r(t, i), t;
        };
      }, function (t, e, n) {
        var r = n(1),
            i = n(10),
            a = n(2),
            o = n(0),
            s = function (t) {
          function e() {
            return t.apply(this, arguments) || this;
          }

          return function (t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
          }(e, t), e.prototype.execute = function () {
            return this.rootNode.width = 0, a(this.rootNode, this.options, i);
          }, e;
        }(r),
            u = {};

        t.exports = function (t, e) {
          return e = o.assign({}, u, e), new s(t, e).execute();
        };
      }, function (t, e, n) {
        var r = n(0);
        var i = {
          isHorizontal: !0,
          nodeSep: 20,
          nodeSize: 20,
          rankSep: 200,
          subTreeSep: 10
        };

        t.exports = function (t, e) {
          void 0 === e && (e = {}), e = r.assign({}, i, e);
          var n,
              a = 0;

          var o = function t(e) {
            if (!e) return null;
            e.width = 0, e.depth && e.depth > a && (a = e.depth);
            var n = e.children,
                r = n.length,
                i = new function (t, e) {
              void 0 === t && (t = 0), void 0 === e && (e = []);
              var n = this;
              n.x = n.y = 0, n.leftChild = n.rightChild = null, n.height = 0, n.children = e;
            }(e.height, []);
            return n.forEach(function (e, n) {
              var a = t(e);
              i.children.push(a), 0 === n && (i.leftChild = a), n === r - 1 && (i.rightChild = a);
            }), i.originNode = e, i.isLeaf = e.isLeaf(), i;
          }(t);

          return function t(e) {
            if (e.isLeaf || 0 === e.children.length) e.drawingDepth = a;else {
              var n = e.children.map(function (e) {
                return t(e);
              }),
                  r = Math.min.apply(null, n);
              e.drawingDepth = r - 1;
            }
            return e.drawingDepth;
          }(o), function t(r) {
            r.x = r.drawingDepth * e.rankSep, r.isLeaf ? (r.y = 0, n && (r.y = n.y + n.height + e.nodeSep, r.originNode.parent !== n.originNode.parent && (r.y += e.subTreeSep)), n = r) : (r.children.forEach(function (e) {
              t(e);
            }), r.y = (r.leftChild.y + r.rightChild.y) / 2);
          }(o), function t(e, n, r) {
            r ? (n.x = e.x, n.y = e.y) : (n.x = e.y, n.y = e.x), e.children.forEach(function (e, i) {
              t(e, n.children[i], r);
            });
          }(o, t, e.isHorizontal), t;
        };
      }, function (t, e, n) {
        var r = n(1),
            i = n(12),
            a = n(4),
            o = n(0),
            s = ["LR", "RL", "H"],
            u = s[0],
            c = function (t) {
          function e() {
            return t.apply(this, arguments) || this;
          }

          return function (t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
          }(e, t), e.prototype.execute = function () {
            var t = this.options,
                e = this.rootNode;
            t.isHorizontal = !0;
            var n = t.indent,
                r = t.direction || u;
            if (r && -1 === s.indexOf(r)) throw new TypeError("Invalid direction: " + r);
            if (r === s[0]) i(e, n);else if (r === s[1]) i(e, n), e.right2left();else if (r === s[2]) {
              var o = a(e, t),
                  c = o.left,
                  h = o.right;
              i(c, n), c.right2left(), i(h, n);
              var f = c.getBoundingBox();
              h.translate(f.width, 0), e.x = h.x - e.width / 2;
            }
            return e;
          }, e;
        }(r),
            h = {};

        t.exports = function (t, e) {
          return e = o.assign({}, h, e), new c(t, e).execute();
        };
      }, function (t, e) {
        t.exports = function (t, e) {
          void 0 === e && (e = 20);
          var n = null;
          t.eachNode(function (t) {
            !function (t, e, n) {
              t.x += n * t.depth, t.y = e ? e.y + e.height : 0;
            }(t, n, e), n = t;
          });
        };
      }, function (t, e, n) {
        var r = n(1),
            i = n(14),
            a = n(2),
            o = n(0),
            s = function (t) {
          function e() {
            return t.apply(this, arguments) || this;
          }

          return function (t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
          }(e, t), e.prototype.execute = function () {
            return a(this.rootNode, this.options, i);
          }, e;
        }(r),
            u = {};

        t.exports = function (t, e) {
          return e = o.assign({}, u, e), new s(t, e).execute();
        };
      }, function (t, e, n) {
        var r = n(0);
        var i = {
          getSubTreeSep: function getSubTreeSep() {
            return 0;
          }
        };

        t.exports = function (t, e) {
          void 0 === e && (e = {}), e = r.assign({}, i, e), t.parent = {
            x: 0,
            width: 0,
            height: 0,
            y: 0
          }, t.BFTraverse(function (t) {
            t.x = t.parent.x + t.parent.width;
          }), t.parent = null, function t(e, n) {
            var r = 0;
            return e.children.length ? e.children.forEach(function (e) {
              r += t(e, n);
            }) : r = e.height, e._subTreeSep = n.getSubTreeSep(e.data), e.totalHeight = Math.max(e.height, r) + 2 * e._subTreeSep, e.totalHeight;
          }(t, e), t.startY = 0, t.y = t.totalHeight / 2 - t.height / 2, t.eachNode(function (t) {
            var e = t.children,
                n = e.length;

            if (n) {
              var r = e[0];
              if (r.startY = t.startY + t._subTreeSep, 1 === n) r.y = t.y + t.height / 2 - r.height / 2;else {
                r.y = r.startY + r.totalHeight / 2 - r.height / 2;

                for (var i = 1; i < n; i++) {
                  var a = e[i];
                  a.startY = e[i - 1].startY + e[i - 1].totalHeight, a.y = a.startY + a.totalHeight / 2 - a.height / 2;
                }
              }
            }
          }), function t(e) {
            var n = e.children,
                r = n.length;

            if (r) {
              n.forEach(function (e) {
                t(e);
              });
              var i = n[0],
                  a = n[r - 1],
                  o = a.y - i.y + a.height,
                  s = 0;
              if (n.forEach(function (t) {
                s += t.totalHeight;
              }), o > e.height) e.y = i.y + o / 2 - e.height / 2;else if (1 !== n.length || e.height > s) {
                var u = e.y + (e.height - o) / 2 - i.y;
                n.forEach(function (t) {
                  t.translate(0, u);
                });
              } else e.y = (i.y + i.height / 2 + a.y + a.height / 2) / 2 - e.height / 2;
            }
          }(t);
        };
      }]);
    });
  }, function (t, e, n) {
    var r = n(26),
        i = function () {
      var t = e.prototype;

      function e(t) {
        var e = this.getDefaultCfg();
        r.mix(this, e, t), this._init();
      }

      return t.getDefaultCfg = function () {
        return {};
      }, t._init = function () {}, t.destroy = function () {}, e;
    }();

    t.exports = i;
  }, function (t, e, n) {
    var r = n(19),
        i = n(613),
        a = n(612),
        o = n(640),
        s = n(639),
        u = r.vec3,
        c = r.mat3,
        h = ["m", "l", "c", "a", "q", "h", "v", "t", "s", "z"];

    function f(t, e, n) {
      return {
        x: n.x + t,
        y: n.y + e
      };
    }

    function l(t, e) {
      return {
        x: e.x + (e.x - t.x),
        y: e.y + (e.y - t.y)
      };
    }

    function p(t) {
      return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
    }

    function d(t, e) {
      return (t[0] * e[0] + t[1] * e[1]) / (p(t) * p(e));
    }

    function g(t, e) {
      return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(d(t, e));
    }

    var v = function v(t, e, n) {
      this.preSegment = e, this.isLast = n, this.init(t, e);
    };

    r.augment(v, {
      init: function init(t, e) {
        var n = t[0];
        e = e || {
          endPoint: {
            x: 0,
            y: 0
          }
        };
        var i,
            a,
            o,
            s,
            u = h.indexOf(n) >= 0,
            c = u ? n.toUpperCase() : n,
            p = t,
            v = e.endPoint,
            m = p[1],
            x = p[2];

        switch (c) {
          default:
            break;

          case "M":
            s = u ? f(m, x, v) : {
              x: m,
              y: x
            }, this.command = "M", this.params = [v, s], this.subStart = s, this.endPoint = s;
            break;

          case "L":
            s = u ? f(m, x, v) : {
              x: m,
              y: x
            }, this.command = "L", this.params = [v, s], this.subStart = e.subStart, this.endPoint = s, this.endTangent = function () {
              return [s.x - v.x, s.y - v.y];
            }, this.startTangent = function () {
              return [v.x - s.x, v.y - s.y];
            };
            break;

          case "H":
            s = u ? f(m, 0, v) : {
              x: m,
              y: v.y
            }, this.command = "L", this.params = [v, s], this.subStart = e.subStart, this.endPoint = s, this.endTangent = function () {
              return [s.x - v.x, s.y - v.y];
            }, this.startTangent = function () {
              return [v.x - s.x, v.y - s.y];
            };
            break;

          case "V":
            s = u ? f(0, m, v) : {
              x: v.x,
              y: m
            }, this.command = "L", this.params = [v, s], this.subStart = e.subStart, this.endPoint = s, this.endTangent = function () {
              return [s.x - v.x, s.y - v.y];
            }, this.startTangent = function () {
              return [v.x - s.x, v.y - s.y];
            };
            break;

          case "Q":
            u ? (i = f(m, x, v), a = f(p[3], p[4], v)) : (i = {
              x: m,
              y: x
            }, a = {
              x: p[3],
              y: p[4]
            }), this.command = "Q", this.params = [v, i, a], this.subStart = e.subStart, this.endPoint = a, this.endTangent = function () {
              return [a.x - i.x, a.y - i.y];
            }, this.startTangent = function () {
              return [v.x - i.x, v.y - i.y];
            };
            break;

          case "T":
            a = u ? f(m, x, v) : {
              x: m,
              y: x
            }, "Q" === e.command ? (i = l(e.params[1], v), this.command = "Q", this.params = [v, i, a], this.subStart = e.subStart, this.endPoint = a, this.endTangent = function () {
              return [a.x - i.x, a.y - i.y];
            }, this.startTangent = function () {
              return [v.x - i.x, v.y - i.y];
            }) : (this.command = "TL", this.params = [v, a], this.subStart = e.subStart, this.endPoint = a, this.endTangent = function () {
              return [a.x - v.x, a.y - v.y];
            }, this.startTangent = function () {
              return [v.x - a.x, v.y - a.y];
            });
            break;

          case "C":
            u ? (i = f(m, x, v), a = f(p[3], p[4], v), o = f(p[5], p[6], v)) : (i = {
              x: m,
              y: x
            }, a = {
              x: p[3],
              y: p[4]
            }, o = {
              x: p[5],
              y: p[6]
            }), this.command = "C", this.params = [v, i, a, o], this.subStart = e.subStart, this.endPoint = o, this.endTangent = function () {
              return [o.x - a.x, o.y - a.y];
            }, this.startTangent = function () {
              return [v.x - i.x, v.y - i.y];
            };
            break;

          case "S":
            u ? (a = f(m, x, v), o = f(p[3], p[4], v)) : (a = {
              x: m,
              y: x
            }, o = {
              x: p[3],
              y: p[4]
            }), "C" === e.command ? (i = l(e.params[2], v), this.command = "C", this.params = [v, i, a, o], this.subStart = e.subStart, this.endPoint = o, this.endTangent = function () {
              return [o.x - a.x, o.y - a.y];
            }, this.startTangent = function () {
              return [v.x - i.x, v.y - i.y];
            }) : (this.command = "SQ", this.params = [v, a, o], this.subStart = e.subStart, this.endPoint = o, this.endTangent = function () {
              return [o.x - a.x, o.y - a.y];
            }, this.startTangent = function () {
              return [v.x - a.x, v.y - a.y];
            });
            break;

          case "A":
            var y = m,
                b = x,
                M = p[3],
                w = p[4],
                _ = p[5];
            s = u ? f(p[6], p[7], v) : {
              x: p[6],
              y: p[7]
            }, this.command = "A";

            var E = function (t, e, n, i, a, o, s) {
              var u = r.mod(r.toRadian(s), 2 * Math.PI),
                  c = t.x,
                  h = t.y,
                  f = e.x,
                  l = e.y,
                  p = Math.cos(u) * (c - f) / 2 + Math.sin(u) * (h - l) / 2,
                  v = -1 * Math.sin(u) * (c - f) / 2 + Math.cos(u) * (h - l) / 2,
                  m = p * p / (a * a) + v * v / (o * o);
              m > 1 && (a *= Math.sqrt(m), o *= Math.sqrt(m));
              var x = a * a * (v * v) + o * o * (p * p),
                  y = Math.sqrt((a * a * (o * o) - x) / x);
              n === i && (y *= -1), isNaN(y) && (y = 0);

              var b = y * a * v / o,
                  M = y * -o * p / a,
                  w = (c + f) / 2 + Math.cos(u) * b - Math.sin(u) * M,
                  _ = (h + l) / 2 + Math.sin(u) * b + Math.cos(u) * M,
                  E = g([1, 0], [(p - b) / a, (v - M) / o]),
                  S = [(p - b) / a, (v - M) / o],
                  A = [(-1 * p - b) / a, (-1 * v - M) / o],
                  P = g(S, A);

              return d(S, A) <= -1 && (P = Math.PI), d(S, A) >= 1 && (P = 0), 0 === i && P > 0 && (P -= 2 * Math.PI), 1 === i && P < 0 && (P += 2 * Math.PI), [t, w, _, a, o, E, P, u, i];
            }(v, s, w, _, y, b, M);

            this.params = E;
            var S = e.subStart;
            this.subStart = S, this.endPoint = s;
            var A = E[5] % (2 * Math.PI);
            r.isNumberEqual(A, 2 * Math.PI) && (A = 0);
            var P = E[6] % (2 * Math.PI);
            r.isNumberEqual(P, 2 * Math.PI) && (P = 0);
            var O = .001;
            this.startTangent = function () {
              0 === _ && (O *= -1);
              var t = E[3] * Math.cos(A - O) + E[1],
                  e = E[4] * Math.sin(A - O) + E[2];
              return [t - S.x, e - S.y];
            }, this.endTangent = function () {
              var t = E[6];
              t - 2 * Math.PI < 1e-4 && (t = 0);
              var e = E[3] * Math.cos(A + t + O) + E[1],
                  n = E[4] * Math.sin(A + t - O) + E[2];
              return [v.x - e, v.y - n];
            };
            break;

          case "Z":
            this.command = "Z", this.params = [v, e.subStart], this.subStart = e.subStart, this.endPoint = e.subStart;
        }
      },
      isInside: function isInside(t, e, n) {
        var r = this.command,
            a = this.params,
            o = this.box;
        if (o && !i.box(o.minX, o.maxX, o.minY, o.maxY, t, e)) return !1;

        switch (r) {
          default:
            break;

          case "M":
            return !1;

          case "TL":
          case "L":
          case "Z":
            return i.line(a[0].x, a[0].y, a[1].x, a[1].y, n, t, e);

          case "SQ":
          case "Q":
            return i.quadraticline(a[0].x, a[0].y, a[1].x, a[1].y, a[2].x, a[2].y, n, t, e);

          case "C":
            return i.cubicline(a[0].x, a[0].y, a[1].x, a[1].y, a[2].x, a[2].y, a[3].x, a[3].y, n, t, e);

          case "A":
            var s = a,
                h = s[1],
                f = s[2],
                l = s[3],
                p = s[4],
                d = s[5],
                g = s[6],
                v = s[7],
                m = s[8],
                x = l > p ? l : p,
                y = l > p ? 1 : l / p,
                b = l > p ? p / l : 1;
            s = [t, e, 1];
            var M = [1, 0, 0, 0, 1, 0, 0, 0, 1];
            return c.translate(M, M, [-h, -f]), c.rotate(M, M, -v), c.scale(M, M, [1 / y, 1 / b]), u.transformMat3(s, s, M), i.arcline(0, 0, x, d, d + g, 1 - m, n, s[0], s[1]);
        }

        return !1;
      },
      draw: function draw(t) {
        var e,
            n,
            r,
            i = this.command,
            a = this.params;

        switch (i) {
          default:
            break;

          case "M":
            t.moveTo(a[1].x, a[1].y);
            break;

          case "TL":
          case "L":
            t.lineTo(a[1].x, a[1].y);
            break;

          case "SQ":
          case "Q":
            e = a[1], n = a[2], t.quadraticCurveTo(e.x, e.y, n.x, n.y);
            break;

          case "C":
            e = a[1], n = a[2], r = a[3], t.bezierCurveTo(e.x, e.y, n.x, n.y, r.x, r.y);
            break;

          case "A":
            var o = a,
                s = o[1],
                u = o[2],
                c = o[3],
                h = o[4],
                f = o[5],
                l = o[6],
                p = o[7],
                d = o[8],
                g = c > h ? c : h,
                v = c > h ? 1 : c / h,
                m = c > h ? h / c : 1;
            t.translate(s, u), t.rotate(p), t.scale(v, m), t.arc(0, 0, g, f, f + l, 1 - d), t.scale(1 / v, 1 / m), t.rotate(-p), t.translate(-s, -u);
            break;

          case "Z":
            t.closePath();
        }
      },
      getBBox: function getBBox(t) {
        var e,
            n,
            r,
            i,
            u = t / 2,
            c = this.params;

        switch (this.command) {
          default:
          case "M":
          case "Z":
            break;

          case "TL":
          case "L":
            this.box = {
              minX: Math.min(c[0].x, c[1].x) - u,
              maxX: Math.max(c[0].x, c[1].x) + u,
              minY: Math.min(c[0].y, c[1].y) - u,
              maxY: Math.max(c[0].y, c[1].y) + u
            };
            break;

          case "SQ":
          case "Q":
            for (r = 0, i = (n = o.extrema(c[0].x, c[1].x, c[2].x)).length; r < i; r++) {
              n[r] = o.at(c[0].x, c[1].x, c[2].x, n[r]);
            }

            for (n.push(c[0].x, c[2].x), r = 0, i = (e = o.extrema(c[0].y, c[1].y, c[2].y)).length; r < i; r++) {
              e[r] = o.at(c[0].y, c[1].y, c[2].y, e);
            }

            e.push(c[0].y, c[2].y), this.box = {
              minX: Math.min.apply(Math, n) - u,
              maxX: Math.max.apply(Math, n) + u,
              minY: Math.min.apply(Math, e) - u,
              maxY: Math.max.apply(Math, e) + u
            };
            break;

          case "C":
            for (r = 0, i = (n = a.extrema(c[0].x, c[1].x, c[2].x, c[3].x)).length; r < i; r++) {
              n[r] = a.at(c[0].x, c[1].x, c[2].x, c[3].x, n[r]);
            }

            for (r = 0, i = (e = a.extrema(c[0].y, c[1].y, c[2].y, c[3].y)).length; r < i; r++) {
              e[r] = a.at(c[0].y, c[1].y, c[2].y, c[3].y, e[r]);
            }

            n.push(c[0].x, c[3].x), e.push(c[0].y, c[3].y), this.box = {
              minX: Math.min.apply(Math, n) - u,
              maxX: Math.max.apply(Math, n) + u,
              minY: Math.min.apply(Math, e) - u,
              maxY: Math.max.apply(Math, e) + u
            };
            break;

          case "A":
            var h = c,
                f = h[1],
                l = h[2],
                p = h[3],
                d = h[4],
                g = h[5],
                v = h[6],
                m = h[7],
                x = h[8],
                y = g,
                b = g + v,
                M = s.xExtrema(m, p, d),
                w = 1 / 0,
                _ = -1 / 0,
                E = [y, b];

            for (r = 2 * -Math.PI; r <= 2 * Math.PI; r += Math.PI) {
              var S = M + r;
              1 === x ? y < S && S < b && E.push(S) : b < S && S < y && E.push(S);
            }

            for (r = 0, i = E.length; r < i; r++) {
              var A = s.xAt(m, p, d, f, E[r]);
              A < w && (w = A), A > _ && (_ = A);
            }

            var P = s.yExtrema(m, p, d),
                O = 1 / 0,
                C = -1 / 0,
                I = [y, b];

            for (r = 2 * -Math.PI; r <= 2 * Math.PI; r += Math.PI) {
              var T = P + r;
              1 === x ? y < T && T < b && I.push(T) : b < T && T < y && I.push(T);
            }

            for (r = 0, i = I.length; r < i; r++) {
              var k = s.yAt(m, p, d, l, I[r]);
              k < O && (O = k), k > C && (C = k);
            }

            this.box = {
              minX: w - u,
              maxX: _ + u,
              minY: O - u,
              maxY: C + u
            };
        }
      }
    }), t.exports = v;
  }, function (t, e, n) {
    var r = n(593),
        i = n(600),
        a = Math.PI,
        o = Math.sin,
        s = Math.cos,
        u = Math.atan2,
        c = 10,
        h = a / 3;

    function f(t, e, n, r, i, f, l) {
      var p, d, g, v, m, x, y;

      if (!e.fill) {
        var b = e.arrowLength || c,
            M = e.arrowAngle ? e.arrowAngle * a / 180 : h;
        y = u(r - f, n - i), m = Math.abs(e.lineWidth * s(y)) / 2, x = Math.abs(e.lineWidth * o(y)) / 2, l && (m = -m, x = -x), p = i + b * s(y + M / 2), d = f + b * o(y + M / 2), g = i + b * s(y - M / 2), v = f + b * o(y - M / 2), t.beginPath(), t.moveTo(p - m, d - x), t.lineTo(i - m, f - x), t.lineTo(g - m, v - x), t.moveTo(i - m, f - x), t.lineTo(i + m, f + x), t.moveTo(i, f), t.stroke();
      }
    }

    function l(t, e, n, a, o, s, u) {
      var c = u ? e.startArrow : e.endArrow,
          h = c.d,
          f = 0,
          l = o - n,
          p = s - a,
          d = Math.atan(l / p);
      0 === p && l < 0 ? f = Math.PI : l > 0 && p > 0 ? f = Math.PI / 2 - d : l < 0 && p < 0 ? f = -Math.PI / 2 - d : l >= 0 && p < 0 ? f = -d - Math.PI / 2 : l <= 0 && p > 0 && (f = Math.PI / 2 - d);

      var g = function (t) {
        var e,
            n = [],
            a = r.parsePath(t.path);
        if (!Array.isArray(a) || 0 === a.length || "M" !== a[0][0] && "m" !== a[0][0]) return !1;

        for (var o = a.length, s = 0; s < a.length; s++) {
          var u = a[s];
          e = new i(u, e, s === o - 1), n.push(e);
        }

        return n;
      }(c);

      if (g) {
        h && (u ? (o += Math.sin(Math.abs(d)) * h, s = s + Math.cos(Math.abs(d)) * h - .5 * t.lineWidth) : (o -= Math.sin(Math.abs(d)) * h, s = s - Math.cos(Math.abs(d)) * h + .5 * t.lineWidth)), t.save(), t.beginPath(), t.translate(o, s), t.rotate(f);

        for (var v = 0; v < g.length; v++) {
          g[v].draw(t);
        }

        t.setTransform(1, 0, 0, 1, 0, 0), t.fillStyle = t.strokeStyle, t.fill(), t.restore();
      }
    }

    t.exports = {
      addStartArrow: function addStartArrow(t, e, n, r, i, a) {
        "object" == _typeof(e.startArrow) ? l(t, e, n, r, i, a, !0) : e.startArrow && f(t, e, n, r, i, a, !0);
      },
      addEndArrow: function addEndArrow(t, e, n, r, i, a) {
        "object" == _typeof(e.endArrow) ? l(t, e, n, r, i, a, !1) : e.endArrow && f(t, e, n, r, i, a, !1);
      }
    };
  }, function (t, e, n) {
    var r = n(19);

    function i(t, e, n, r) {
      return {
        x: Math.cos(r) * n + t,
        y: Math.sin(r) * n + e
      };
    }

    function a(t, e, n, r) {
      var i, a;
      return r ? t < e ? (i = e - t, a = 2 * Math.PI - n + t) : t > n && (i = 2 * Math.PI - t + e, a = t - n) : (i = t - e, a = n - t), i > a ? n : e;
    }

    function o(t, e, n, i) {
      var o = 0;
      return n - e >= 2 * Math.PI && (o = 2 * Math.PI), e = r.mod(e, 2 * Math.PI), n = r.mod(n, 2 * Math.PI) + o, t = r.mod(t, 2 * Math.PI), i ? e >= n ? t > n && t < e ? t : a(t, n, e, !0) : t < e || t > n ? t : a(t, e, n) : e <= n ? e < t && t < n ? t : a(t, e, n, !0) : t > e || t < n ? t : a(t, n, e);
    }

    function s(t, e, n, i, a, s, u, c, h) {
      var f = [u, c],
          l = [t, e],
          p = r.vec2.subtract([], f, l),
          d = r.vec2.angleTo([1, 0], p);
      d = o(d, i, a, s);
      var g = [n * Math.cos(d) + t, n * Math.sin(d) + e];
      return h && (h.x = g[0], h.y = g[1]), r.vec2.distance(g, f);
    }

    t.exports = {
      nearAngle: o,
      projectPoint: function projectPoint(t, e, n, r, i, a, o, u) {
        var c = {};
        return s(t, e, n, r, i, a, o, u, c), c;
      },
      pointDistance: s,
      box: function box(t, e, n, a, s, u) {
        var c = Math.PI / 2,
            h = Math.PI,
            f = 3 * Math.PI / 2,
            l = [],
            p = o(0, a, s, u);
        0 === p && l.push(i(t, e, n, 0)), (p = o(c, a, s, u)) === c && l.push(i(t, e, n, c)), (p = o(h, a, s, u)) === h && l.push(i(t, e, n, h)), (p = o(f, a, s, u)) === f && l.push(i(t, e, n, f)), l.push(i(t, e, n, a)), l.push(i(t, e, n, s));
        var d = 1 / 0,
            g = -1 / 0,
            v = 1 / 0,
            m = -1 / 0;
        return r.each(l, function (t) {
          d > t.x && (d = t.x), g < t.x && (g = t.x), v > t.y && (v = t.y), m < t.y && (m = t.y);
        }), {
          minX: d,
          minY: v,
          maxX: g,
          maxY: m
        };
      }
    };
  }, function (t, e, n) {
    var r = n(19).vec2;
    t.exports = {
      at: function at(t, e, n) {
        return (e - t) * n + t;
      },
      pointDistance: function pointDistance(t, e, n, i, a, o) {
        var s = [n - t, i - e];
        if (r.exactEquals(s, [0, 0])) return NaN;
        var u = [-s[1], s[0]];
        r.normalize(u, u);
        var c = [a - t, o - e];
        return Math.abs(r.dot(c, u));
      },
      box: function box(t, e, n, r, i) {
        var a = i / 2,
            o = Math.min(t, n),
            s = Math.max(t, n);
        return {
          minX: o - a,
          minY: Math.min(e, r) - a,
          maxX: s + a,
          maxY: Math.max(e, r) + a
        };
      },
      len: function len(t, e, n, r) {
        return Math.sqrt((n - t) * (n - t) + (r - e) * (r - e));
      }
    };
  }, function (t, e, n) {
    var r = n(118);

    t.exports = function (t) {
      return r(t) ? Array.prototype.slice.call(t) : [];
    };
  }, function (t, e, n) {
    var r = n(118),
        i = Array.prototype.indexOf;

    t.exports = function (t, e) {
      return !!r(t) && i.call(t, e) > -1;
    };
  }, function (t, e) {
    function n(t, e) {
      for (var n in e) {
        e.hasOwnProperty(n) && "constructor" !== n && void 0 !== e[n] && (t[n] = e[n]);
      }
    }

    t.exports = function (t, e, r, i) {
      return e && n(t, e), r && n(t, r), i && n(t, i), t;
    };
  },, function (t, e, n) {
    var r = n(26);

    var i = function () {
      function t(t) {
        r.mix(this, {
          id: "",
          type: null,
          model: {},
          group: null,
          animate: !1,
          modelCache: {},
          isItem: !0,
          visible: !0
        }, t), this._init();
      }

      var e = t.prototype;
      return e._init = function () {
        this._initGroup(), this.draw();
      }, e._mapping = function () {
        var t = this.mapper,
            e = this.model;
        t.mapping(e);
      }, e._initGroup = function () {
        var t = this.group,
            e = this.model,
            n = this.type;
        t.isItemContainer = !0, t.id = e.id, t.itemType = n, t.model = e, t.item = this;
      }, e._calculateBBox = function () {
        var t = this.keyShape,
            e = this.group,
            n = r.getBBox(t, e);
        return n.width = n.maxX - n.minX, n.height = n.maxY - n.minY, n.centerX = (n.minX + n.maxX) / 2, n.centerY = (n.minY + n.maxY) / 2, n;
      }, e.getLabel = function () {
        return this.group.findByClass("label")[0];
      }, e.getGraph = function () {
        return this.graph;
      }, e._setShapeObj = function () {
        var t = this.graph,
            e = this.type,
            n = this.getModel();
        this.shapeObj = t.getShapeObj(e, n);
      }, e._afterDraw = function () {
        var t = this.graph;
        this._setGId(), this._cacheModel(), t.emit("afteritemdraw", {
          item: this
        });
      }, e._cacheModel = function () {
        this.modelCache = r.mix({}, this.model);
      }, e._setGId = function () {
        var t = this.group,
            e = this.id,
            n = this.type;
        t.gid = e, t.deepEach(function (t, r, i) {
          var a = r.gid;

          if (t.id = e, t.eventPreFix = n, t.gid = a + "-" + i, t.isShape) {
            var o = t.get("type");
            t.gid += "-" + o;
          }
        });
      }, e._beforeDraw = function () {
        var t = this.graph,
            e = this.group;
        t.emit("beforeitemdraw", {
          item: this
        }), e.resetMatrix(), this.updateCollapsedParent();
      }, e._shouldDraw = function () {
        return !0;
      }, e._getDiff = function () {
        var t = [],
            e = this.model,
            n = this.modelCache;
        return r.each(e, function (e, i) {
          r.isEqual(e, n[i]) || t.push(i);
        }), 0 !== t.length && t;
      }, e._drawInner = function () {
        var t = this.animate;
        this.group.clear(!t), this._mapping(), this._setShapeObj();
        var e = this.shapeObj,
            n = e.draw(this);
        n && (n.isKeyShape = !0, this.keyShape = n), e.afterDraw && e.afterDraw(this);
      }, e.deepEach = function (t, e) {
        r.traverseTree(this, t, e || function (t) {
          return t.getChildren();
        });
      }, e.getShapeObj = function () {
        return this.shapeObj;
      }, e.updateCollapsedParent = function () {
        var t = this.dataMap;

        this.collapsedParent = function t(e, n) {
          var r = n[e.parent];
          if (!r) return !1;

          if (r) {
            var i = t(r, n);
            if (i) return i;
          }

          return r.collapsed ? r : void 0;
        }(this.model, t);
      }, e.isVisible = function () {
        return this.visible;
      }, e.hide = function () {
        var t = this.group,
            e = this.graph;
        e.emit("beforeitemhide", {
          item: this
        }), t.hide(), this.visible = !1, e.emit("afteritemhide", {
          item: this
        });
      }, e.show = function () {
        var t = this.group,
            e = this.graph;
        e.emit("beforeitemshow", {
          item: this
        }), t.show(), this.visible = !0, e.emit("afteritemshow", {
          item: this
        });
      }, e.draw = function () {
        this._beforeDraw(), this._shouldDraw() && this._drawInner(), this._afterDraw();
      }, e.forceUpdate = function () {
        this._beforeDraw(), this._drawInner(), this._afterDraw();
      }, e.getCenter = function () {
        var t = this.getBBox();
        return {
          x: t.centerX,
          y: t.centerY
        };
      }, e.getBBox = function () {
        return this.bbox || this._calculateBBox();
      }, e.layoutUpdate = function () {
        this.isVisible() && this.draw();
      }, e.update = function () {
        this.draw();
      }, e.getModel = function () {
        return this.model;
      }, e.getKeyShape = function () {
        return this.keyShape;
      }, e.getGraphicGroup = function () {
        return this.group;
      }, e.getHierarchy = function () {
        return this.graph.getHierarchy(this);
      }, e.getParent = function () {
        var t = this.model;
        return this.itemMap[t.parent];
      }, e.getAllParents = function () {
        for (var t = this.model, e = this.itemMap, n = [], r = t.parent; r && e[r];) {
          var i = e[r],
              a = i.getModel();
          n.push(i), r = a.parent;
        }

        return n;
      }, e.getAllChildren = function () {
        var t = [];
        return this.deepEach(function (e) {
          t.push(e);
        }), t;
      }, e.getChildren = function () {
        var t = this.id;
        return this.graph.getItems().filter(function (e) {
          return e.model.parent === t;
        });
      }, e.toFront = function () {
        this.group.toFront();
      }, e.toBack = function () {
        this.group.toBack();
      }, e.destroy = function () {
        if (!this.destroyed) {
          var t = this.animate,
              e = this.graph;
          e.emit("beforeitemdestroy", {
            item: this
          }), this.group.remove(!t), this.destroyed = !0, e.emit("afteritemdestroy", {
            item: this
          });
        }
      }, t;
    }();

    t.exports = i;
  }, function (t, e) {
    t.exports = "2.2.6";
  }, function (t, e, n) {
    var r = n(644),
        i = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029",
        a = new RegExp("([a-z])[" + i + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + i + "]*,?[" + i + "]*)+)", "ig"),
        o = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + i + "]*,?[" + i + "]*", "ig"),
        s = function s(t) {
      if (!t) return null;
      if (_typeof(t) == _typeof([])) return t;
      var e = {
        a: 7,
        c: 6,
        o: 2,
        h: 1,
        l: 2,
        m: 2,
        r: 4,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        u: 3,
        z: 0
      },
          n = [];
      return String(t).replace(a, function (t, r, i) {
        var a = [],
            s = r.toLowerCase();
        if (i.replace(o, function (t, e) {
          e && a.push(+e);
        }), "m" === s && a.length > 2 && (n.push([r].concat(a.splice(0, 2))), s = "l", r = "m" === r ? "l" : "L"), "o" === s && 1 === a.length && n.push([r, a[0]]), "r" === s) n.push([r].concat(a));else for (; a.length >= e[s] && (n.push([r].concat(a.splice(0, e[s]))), e[s]);) {
          ;
        }
      }), n;
    },
        u = function u(t, e) {
      for (var n = [], r = 0, i = t.length; i - 2 * !e > r; r += 2) {
        var a = [{
          x: +t[r - 2],
          y: +t[r - 1]
        }, {
          x: +t[r],
          y: +t[r + 1]
        }, {
          x: +t[r + 2],
          y: +t[r + 3]
        }, {
          x: +t[r + 4],
          y: +t[r + 5]
        }];
        e ? r ? i - 4 === r ? a[3] = {
          x: +t[0],
          y: +t[1]
        } : i - 2 === r && (a[2] = {
          x: +t[0],
          y: +t[1]
        }, a[3] = {
          x: +t[2],
          y: +t[3]
        }) : a[0] = {
          x: +t[i - 2],
          y: +t[i - 1]
        } : i - 4 === r ? a[3] = a[2] : r || (a[0] = {
          x: +t[r],
          y: +t[r + 1]
        }), n.push(["C", (-a[0].x + 6 * a[1].x + a[2].x) / 6, (-a[0].y + 6 * a[1].y + a[2].y) / 6, (a[1].x + 6 * a[2].x - a[3].x) / 6, (a[1].y + 6 * a[2].y - a[3].y) / 6, a[2].x, a[2].y]);
      }

      return n;
    },
        c = function c(t, e, n, r, i) {
      var a = [];

      if (null === i && null === r && (r = n), t = +t, e = +e, n = +n, r = +r, null !== i) {
        var o = Math.PI / 180,
            s = t + n * Math.cos(-r * o),
            u = t + n * Math.cos(-i * o);
        a = [["M", s, e + n * Math.sin(-r * o)], ["A", n, n, 0, +(i - r > 180), 0, u, e + n * Math.sin(-i * o)]];
      } else a = [["M", t, e], ["m", 0, -r], ["a", n, r, 0, 1, 1, 0, 2 * r], ["a", n, r, 0, 1, 1, 0, -2 * r], ["z"]];

      return a;
    },
        h = function h(t) {
      if (!(t = s(t)) || !t.length) return [["M", 0, 0]];
      var e,
          n,
          r = [],
          i = 0,
          a = 0,
          o = 0,
          h = 0,
          f = 0;
      "M" === t[0][0] && (o = i = +t[0][1], h = a = +t[0][2], f++, r[0] = ["M", i, a]);

      for (var l, p, d = 3 === t.length && "M" === t[0][0] && "R" === t[1][0].toUpperCase() && "Z" === t[2][0].toUpperCase(), g = f, v = t.length; g < v; g++) {
        if (r.push(l = []), (e = (p = t[g])[0]) !== e.toUpperCase()) switch (l[0] = e.toUpperCase(), l[0]) {
          case "A":
            l[1] = p[1], l[2] = p[2], l[3] = p[3], l[4] = p[4], l[5] = p[5], l[6] = +p[6] + i, l[7] = +p[7] + a;
            break;

          case "V":
            l[1] = +p[1] + a;
            break;

          case "H":
            l[1] = +p[1] + i;
            break;

          case "R":
            for (var m = 2, x = (n = [i, a].concat(p.slice(1))).length; m < x; m++) {
              n[m] = +n[m] + i, n[++m] = +n[m] + a;
            }

            r.pop(), r = r.concat(u(n, d));
            break;

          case "O":
            r.pop(), (n = c(i, a, p[1], p[2])).push(n[0]), r = r.concat(n);
            break;

          case "U":
            r.pop(), r = r.concat(c(i, a, p[1], p[2], p[3])), l = ["U"].concat(r[r.length - 1].slice(-2));
            break;

          case "M":
            o = +p[1] + i, h = +p[2] + a;
            break;

          default:
            for (var y = 1, b = p.length; y < b; y++) {
              l[y] = +p[y] + (y % 2 ? i : a);
            }

        } else if ("R" === e) n = [i, a].concat(p.slice(1)), r.pop(), r = r.concat(u(n, d)), l = ["R"].concat(p.slice(-2));else if ("O" === e) r.pop(), (n = c(i, a, p[1], p[2])).push(n[0]), r = r.concat(n);else if ("U" === e) r.pop(), r = r.concat(c(i, a, p[1], p[2], p[3])), l = ["U"].concat(r[r.length - 1].slice(-2));else for (var M = 0, w = p.length; M < w; M++) {
          l[M] = p[M];
        }
        if ("O" !== (e = e.toUpperCase())) switch (l[0]) {
          case "Z":
            i = +o, a = +h;
            break;

          case "H":
            i = l[1];
            break;

          case "V":
            a = l[1];
            break;

          case "M":
            o = l[l.length - 2], h = l[l.length - 1];
            break;

          default:
            i = l[l.length - 2], a = l[l.length - 1];
        }
      }

      return r;
    },
        f = function f(t, e, n, r) {
      return [t, e, n, r, n, r];
    },
        l = function l(t, e, n, r, i, a) {
      return [1 / 3 * t + 2 / 3 * n, 1 / 3 * e + 2 / 3 * r, 1 / 3 * i + 2 / 3 * n, 1 / 3 * a + 2 / 3 * r, i, a];
    },
        p = function p(t, e) {
      var n,
          r = h(t),
          i = e && h(e),
          a = {
        x: 0,
        y: 0,
        bx: 0,
        by: 0,
        X: 0,
        Y: 0,
        qx: null,
        qy: null
      },
          o = {
        x: 0,
        y: 0,
        bx: 0,
        by: 0,
        X: 0,
        Y: 0,
        qx: null,
        qy: null
      },
          s = [],
          u = [],
          c = "",
          p = "",
          d = function d(t, e, n) {
        var r, i;
        if (!t) return ["C", e.x, e.y, e.x, e.y, e.x, e.y];

        switch (!(t[0] in {
          T: 1,
          Q: 1
        }) && (e.qx = e.qy = null), t[0]) {
          case "M":
            e.X = t[1], e.Y = t[2];
            break;

          case "A":
            t = ["C"].concat(function t(e, n, r, i, a, o, s, u, c, h) {
              r === i && (r += 1);

              var f,
                  l,
                  p,
                  d,
                  g,
                  v = 120 * Math.PI / 180,
                  m = Math.PI / 180 * (+a || 0),
                  x = [],
                  y = function y(t, e, n) {
                return {
                  x: t * Math.cos(n) - e * Math.sin(n),
                  y: t * Math.sin(n) + e * Math.cos(n)
                };
              };

              if (h) l = h[0], p = h[1], d = h[2], g = h[3];else {
                e = (f = y(e, n, -m)).x, n = f.y, u = (f = y(u, c, -m)).x, c = f.y, e === u && n === c && (u += 1, c += 1);
                var b = (e - u) / 2,
                    M = (n - c) / 2,
                    w = b * b / (r * r) + M * M / (i * i);
                w > 1 && (r *= w = Math.sqrt(w), i *= w);

                var _ = r * r,
                    E = i * i,
                    S = (o === s ? -1 : 1) * Math.sqrt(Math.abs((_ * E - _ * M * M - E * b * b) / (_ * M * M + E * b * b)));

                d = S * r * M / i + (e + u) / 2, g = S * -i * b / r + (n + c) / 2, l = Math.asin(((n - g) / i).toFixed(9)), p = Math.asin(((c - g) / i).toFixed(9)), l = e < d ? Math.PI - l : l, p = u < d ? Math.PI - p : p, l < 0 && (l = 2 * Math.PI + l), p < 0 && (p = 2 * Math.PI + p), s && l > p && (l -= 2 * Math.PI), !s && p > l && (p -= 2 * Math.PI);
              }
              var A = p - l;

              if (Math.abs(A) > v) {
                var P = p,
                    O = u,
                    C = c;
                p = l + v * (s && p > l ? 1 : -1), x = t(u = d + r * Math.cos(p), c = g + i * Math.sin(p), r, i, a, 0, s, O, C, [p, P, d, g]);
              }

              A = p - l;
              var I = Math.cos(l),
                  T = Math.sin(l),
                  k = Math.cos(p),
                  N = Math.sin(p),
                  L = Math.tan(A / 4),
                  B = 4 / 3 * r * L,
                  j = 4 / 3 * i * L,
                  D = [e, n],
                  R = [e + B * T, n - j * I],
                  F = [u + B * N, c - j * k],
                  Y = [u, c];
              if (R[0] = 2 * D[0] - R[0], R[1] = 2 * D[1] - R[1], h) return [R, F, Y].concat(x);

              for (var X = [], G = 0, q = (x = [R, F, Y].concat(x).join().split(",")).length; G < q; G++) {
                X[G] = G % 2 ? y(x[G - 1], x[G], m).y : y(x[G], x[G + 1], m).x;
              }

              return X;
            }.apply(0, [e.x, e.y].concat(t.slice(1))));
            break;

          case "S":
            "C" === n || "S" === n ? (r = 2 * e.x - e.bx, i = 2 * e.y - e.by) : (r = e.x, i = e.y), t = ["C", r, i].concat(t.slice(1));
            break;

          case "T":
            "Q" === n || "T" === n ? (e.qx = 2 * e.x - e.qx, e.qy = 2 * e.y - e.qy) : (e.qx = e.x, e.qy = e.y), t = ["C"].concat(l(e.x, e.y, e.qx, e.qy, t[1], t[2]));
            break;

          case "Q":
            e.qx = t[1], e.qy = t[2], t = ["C"].concat(l(e.x, e.y, t[1], t[2], t[3], t[4]));
            break;

          case "L":
            t = ["C"].concat(f(e.x, e.y, t[1], t[2]));
            break;

          case "H":
            t = ["C"].concat(f(e.x, e.y, t[1], e.y));
            break;

          case "V":
            t = ["C"].concat(f(e.x, e.y, e.x, t[1]));
            break;

          case "Z":
            t = ["C"].concat(f(e.x, e.y, e.X, e.Y));
        }

        return t;
      },
          g = function g(t, e) {
        if (t[e].length > 7) {
          t[e].shift();

          for (var a = t[e]; a.length;) {
            s[e] = "A", i && (u[e] = "A"), t.splice(e++, 0, ["C"].concat(a.splice(0, 6)));
          }

          t.splice(e, 1), n = Math.max(r.length, i && i.length || 0);
        }
      },
          v = function v(t, e, a, o, s) {
        t && e && "M" === t[s][0] && "M" !== e[s][0] && (e.splice(s, 0, ["M", o.x, o.y]), a.bx = 0, a.by = 0, a.x = t[s][1], a.y = t[s][2], n = Math.max(r.length, i && i.length || 0));
      };

      n = Math.max(r.length, i && i.length || 0);

      for (var m = 0; m < n; m++) {
        r[m] && (c = r[m][0]), "C" !== c && (s[m] = c, m && (p = s[m - 1])), r[m] = d(r[m], a, p), "A" !== s[m] && "C" === c && (s[m] = "C"), g(r, m), i && (i[m] && (c = i[m][0]), "C" !== c && (u[m] = c, m && (p = u[m - 1])), i[m] = d(i[m], o, p), "A" !== u[m] && "C" === c && (u[m] = "C"), g(i, m)), v(r, i, a, o, m), v(i, r, o, a, m);
        var x = r[m],
            y = i && i[m],
            b = x.length,
            M = i && y.length;
        a.x = x[b - 2], a.y = x[b - 1], a.bx = parseFloat(x[b - 4]) || a.x, a.by = parseFloat(x[b - 3]) || a.y, o.bx = i && (parseFloat(y[M - 4]) || o.x), o.by = i && (parseFloat(y[M - 3]) || o.y), o.x = i && y[M - 2], o.y = i && y[M - 1];
      }

      return i ? [r, i] : r;
    },
        d = /,?([a-z]),?/gi,
        g = function g(t) {
      return t.join(",").replace(d, "$1");
    },
        v = function v(t, e, n, r, i) {
      return t * (t * (-3 * e + 9 * n - 9 * r + 3 * i) + 6 * e - 12 * n + 6 * r) - 3 * e + 3 * n;
    },
        m = function m(t, e, n, r, i, a, o, s, u) {
      null === u && (u = 1);

      for (var c = (u = u > 1 ? 1 : u < 0 ? 0 : u) / 2, h = [-.1252, .1252, -.3678, .3678, -.5873, .5873, -.7699, .7699, -.9041, .9041, -.9816, .9816], f = [.2491, .2491, .2335, .2335, .2032, .2032, .1601, .1601, .1069, .1069, .0472, .0472], l = 0, p = 0; p < 12; p++) {
        var d = c * h[p] + c,
            g = v(d, t, n, i, o),
            m = v(d, e, r, a, s),
            x = g * g + m * m;
        l += f[p] * Math.sqrt(x);
      }

      return c * l;
    },
        x = function x(t, e, n, r, i, a, o, s) {
      if (!(Math.max(t, n) < Math.min(i, o) || Math.min(t, n) > Math.max(i, o) || Math.max(e, r) < Math.min(a, s) || Math.min(e, r) > Math.max(a, s))) {
        var u = (t - n) * (a - s) - (e - r) * (i - o);

        if (u) {
          var c = ((t * r - e * n) * (i - o) - (t - n) * (i * s - a * o)) / u,
              h = ((t * r - e * n) * (a - s) - (e - r) * (i * s - a * o)) / u,
              f = +c.toFixed(2),
              l = +h.toFixed(2);
          if (!(f < +Math.min(t, n).toFixed(2) || f > +Math.max(t, n).toFixed(2) || f < +Math.min(i, o).toFixed(2) || f > +Math.max(i, o).toFixed(2) || l < +Math.min(e, r).toFixed(2) || l > +Math.max(e, r).toFixed(2) || l < +Math.min(a, s).toFixed(2) || l > +Math.max(a, s).toFixed(2))) return {
            x: c,
            y: h
          };
        }
      }
    },
        y = function y(t, e, n) {
      return e >= t.x && e <= t.x + t.width && n >= t.y && n <= t.y + t.height;
    },
        b = function b(t, e, n, r, i) {
      if (i) return [["M", +t + +i, e], ["l", n - 2 * i, 0], ["a", i, i, 0, 0, 1, i, i], ["l", 0, r - 2 * i], ["a", i, i, 0, 0, 1, -i, i], ["l", 2 * i - n, 0], ["a", i, i, 0, 0, 1, -i, -i], ["l", 0, 2 * i - r], ["a", i, i, 0, 0, 1, i, -i], ["z"]];
      var a = [["M", t, e], ["l", n, 0], ["l", 0, r], ["l", -n, 0], ["z"]];
      return a.parsePathArray = g, a;
    },
        M = function M(t, e, n, r) {
      return null === t && (t = e = n = r = 0), null === e && (e = t.y, n = t.width, r = t.height, t = t.x), {
        x: t,
        y: e,
        width: n,
        w: n,
        height: r,
        h: r,
        x2: t + n,
        y2: e + r,
        cx: t + n / 2,
        cy: e + r / 2,
        r1: Math.min(n, r) / 2,
        r2: Math.max(n, r) / 2,
        r0: Math.sqrt(n * n + r * r) / 2,
        path: b(t, e, n, r),
        vb: [t, e, n, r].join(" ")
      };
    },
        w = function w(t, e, n, i, a, o, s, u) {
      r.isArray(t) || (t = [t, e, n, i, a, o, s, u]);

      var c = function (t, e, n, r, i, a, o, s) {
        for (var u, c, h, f, l = [], p = [[], []], d = 0; d < 2; ++d) {
          if (0 === d ? (c = 6 * t - 12 * n + 6 * i, u = -3 * t + 9 * n - 9 * i + 3 * o, h = 3 * n - 3 * t) : (c = 6 * e - 12 * r + 6 * a, u = -3 * e + 9 * r - 9 * a + 3 * s, h = 3 * r - 3 * e), Math.abs(u) < 1e-12) {
            if (Math.abs(c) < 1e-12) continue;
            (f = -h / c) > 0 && f < 1 && l.push(f);
          } else {
            var g = c * c - 4 * h * u,
                v = Math.sqrt(g);

            if (!(g < 0)) {
              var m = (-c + v) / (2 * u);
              m > 0 && m < 1 && l.push(m);
              var x = (-c - v) / (2 * u);
              x > 0 && x < 1 && l.push(x);
            }
          }
        }

        for (var y, b = l.length, M = b; b--;) {
          y = 1 - (f = l[b]), p[0][b] = y * y * y * t + 3 * y * y * f * n + 3 * y * f * f * i + f * f * f * o, p[1][b] = y * y * y * e + 3 * y * y * f * r + 3 * y * f * f * a + f * f * f * s;
        }

        return p[0][M] = t, p[1][M] = e, p[0][M + 1] = o, p[1][M + 1] = s, p[0].length = p[1].length = M + 2, {
          min: {
            x: Math.min.apply(0, p[0]),
            y: Math.min.apply(0, p[1])
          },
          max: {
            x: Math.max.apply(0, p[0]),
            y: Math.max.apply(0, p[1])
          }
        };
      }.apply(null, t);

      return M(c.min.x, c.min.y, c.max.x - c.min.x, c.max.y - c.min.y);
    },
        _ = function _(t, e, n, r, i, a, o, s, u) {
      var c = 1 - u,
          h = Math.pow(c, 3),
          f = Math.pow(c, 2),
          l = u * u,
          p = l * u,
          d = t + 2 * u * (n - t) + l * (i - 2 * n + t),
          g = e + 2 * u * (r - e) + l * (a - 2 * r + e),
          v = n + 2 * u * (i - n) + l * (o - 2 * i + n),
          m = r + 2 * u * (a - r) + l * (s - 2 * a + r);
      return {
        x: h * t + 3 * f * u * n + 3 * c * u * u * i + p * o,
        y: h * e + 3 * f * u * r + 3 * c * u * u * a + p * s,
        m: {
          x: d,
          y: g
        },
        n: {
          x: v,
          y: m
        },
        start: {
          x: c * t + u * n,
          y: c * e + u * r
        },
        end: {
          x: c * i + u * o,
          y: c * a + u * s
        },
        alpha: 90 - 180 * Math.atan2(d - v, g - m) / Math.PI
      };
    },
        E = function E(t, e, n) {
      if (!function (t, e) {
        return t = M(t), e = M(e), y(e, t.x, t.y) || y(e, t.x2, t.y) || y(e, t.x, t.y2) || y(e, t.x2, t.y2) || y(t, e.x, e.y) || y(t, e.x2, e.y) || y(t, e.x, e.y2) || y(t, e.x2, e.y2) || (t.x < e.x2 && t.x > e.x || e.x < t.x2 && e.x > t.x) && (t.y < e.y2 && t.y > e.y || e.y < t.y2 && e.y > t.y);
      }(w(t), w(e))) return n ? 0 : [];

      for (var r = ~~(m.apply(0, t) / 8), i = ~~(m.apply(0, e) / 8), a = [], o = [], s = {}, u = n ? 0 : [], c = 0; c < r + 1; c++) {
        var h = _.apply(0, t.concat(c / r));

        a.push({
          x: h.x,
          y: h.y,
          t: c / r
        });
      }

      for (var f = 0; f < i + 1; f++) {
        var l = _.apply(0, e.concat(f / i));

        o.push({
          x: l.x,
          y: l.y,
          t: f / i
        });
      }

      for (var p = 0; p < r; p++) {
        for (var d = 0; d < i; d++) {
          var g = a[p],
              v = a[p + 1],
              b = o[d],
              E = o[d + 1],
              S = Math.abs(v.x - g.x) < .001 ? "y" : "x",
              A = Math.abs(E.x - b.x) < .001 ? "y" : "x",
              P = x(g.x, g.y, v.x, v.y, b.x, b.y, E.x, E.y);

          if (P) {
            if (s[P.x.toFixed(4)] === P.y.toFixed(4)) continue;
            s[P.x.toFixed(4)] = P.y.toFixed(4);
            var O = g.t + Math.abs((P[S] - g[S]) / (v[S] - g[S])) * (v.t - g.t),
                C = b.t + Math.abs((P[A] - b[A]) / (E[A] - b[A])) * (E.t - b.t);
            O >= 0 && O <= 1 && C >= 0 && C <= 1 && (n ? u++ : u.push({
              x: P.x,
              y: P.y,
              t1: O,
              t2: C
            }));
          }
        }
      }

      return u;
    };

    function S(t, e) {
      var n = [],
          r = [];
      return t.length && function t(e, i) {
        if (1 === e.length) n.push(e[0]), r.push(e[0]);else {
          for (var a = [], o = 0; o < e.length - 1; o++) {
            0 === o && n.push(e[0]), o === e.length - 2 && r.push(e[o + 1]), a[o] = [(1 - i) * e[o][0] + i * e[o + 1][0], (1 - i) * e[o][1] + i * e[o + 1][1]];
          }

          t(a, i);
        }
      }(t, e), {
        left: n,
        right: r.reverse()
      };
    }

    var A = function A(t, e, n) {
      if (1 === n) return [[].concat(t)];
      var r = [];
      if ("L" === e[0] || "C" === e[0] || "Q" === e[0]) r = r.concat(function (t, e, n) {
        var r = [[t[1], t[2]]];
        n = n || 2;
        var i = [];
        "A" === e[0] ? (r.push(e[6]), r.push(e[7])) : "C" === e[0] ? (r.push([e[1], e[2]]), r.push([e[3], e[4]]), r.push([e[5], e[6]])) : "S" === e[0] || "Q" === e[0] ? (r.push([e[1], e[2]]), r.push([e[3], e[4]])) : r.push([e[1], e[2]]);

        for (var a = r, o = 1 / n, s = 0; s < n - 1; s++) {
          var u = S(a, o / (1 - o * s));
          i.push(u.left), a = u.right;
        }

        return i.push(a), i.map(function (t) {
          var e = [];
          return 4 === t.length && (e.push("C"), e = e.concat(t[2])), t.length >= 3 && (3 === t.length && e.push("Q"), e = e.concat(t[1])), 2 === t.length && e.push("L"), e = e.concat(t[t.length - 1]);
        });
      }(t, e, n));else {
        var i = [].concat(t);
        "M" === i[0] && (i[0] = "L");

        for (var a = 0; a <= n - 1; a++) {
          r.push(i);
        }
      }
      return r;
    },
        P = function P(t, e) {
      if (t.length !== e.length) return !1;
      var n = !0;
      return r.each(t, function (t, r) {
        if (t !== e[r]) return n = !1, !1;
      }), n;
    };

    function O(t, e, n) {
      var r = null,
          i = n;
      return e < i && (i = e, r = "add"), t < i && (i = t, r = "del"), {
        type: r,
        min: i
      };
    }

    function C(t, e, n) {
      for (var r, i = [].concat(t), a = 1 / (n + 1), o = I(e)[0], s = 1; s <= n; s++) {
        a *= s, 0 === (r = Math.floor(t.length * a)) ? i.unshift([o[0] * a + t[r][0] * (1 - a), o[1] * a + t[r][1] * (1 - a)]) : i.splice(r, 0, [o[0] * a + t[r][0] * (1 - a), o[1] * a + t[r][1] * (1 - a)]);
      }

      return i;
    }

    function I(t) {
      var e = [];

      switch (t[0]) {
        case "M":
        case "L":
          e.push([t[1], t[2]]);
          break;

        case "A":
          e.push([t[6], t[7]]);
          break;

        case "Q":
          e.push([t[3], t[4]]), e.push([t[1], t[2]]);
          break;

        case "T":
          e.push([t[1], t[2]]);
          break;

        case "C":
          e.push([t[5], t[6]]), e.push([t[1], t[2]]), e.push([t[3], t[4]]);
          break;

        case "S":
          e.push([t[3], t[4]]), e.push([t[1], t[2]]);
          break;

        case "H":
        case "V":
          e.push([t[1], t[1]]);
      }

      return e;
    }

    t.exports = {
      parsePathString: s,
      parsePathArray: g,
      pathTocurve: p,
      pathToAbsolute: h,
      catmullRomToBezier: u,
      rectPath: b,
      fillPath: function fillPath(t, e) {
        if (1 === t.length) return t;
        var n = t.length - 1,
            r = e.length - 1,
            i = n / r,
            a = [];

        if (1 === t.length && "M" === t[0][0]) {
          for (var o = 0; o < r - n; o++) {
            t.push(t[0]);
          }

          return t;
        }

        for (var s = 0; s < r; s++) {
          var u = Math.floor(i * s);
          a[u] = (a[u] || 0) + 1;
        }

        var c = a.reduce(function (e, r, i) {
          return i === n ? e.concat(t[n]) : e.concat(A(t[i], t[i + 1], r));
        }, []);
        return c.unshift(t[0]), "Z" !== e[r] && "z" !== e[r] || c.push("Z"), c;
      },
      fillPathByDiff: function fillPathByDiff(t, e) {
        var n = function (t, e) {
          var n,
              r,
              i = t.length,
              a = e.length,
              o = 0;
          if (0 === i || 0 === a) return null;

          for (var s = [], u = 0; u <= i; u++) {
            s[u] = [], s[u][0] = {
              min: u
            };
          }

          for (var c = 0; c <= a; c++) {
            s[0][c] = {
              min: c
            };
          }

          for (var h = 1; h <= i; h++) {
            n = t[h - 1];

            for (var f = 1; f <= a; f++) {
              r = e[f - 1], o = P(n, r) ? 0 : 1;
              var l = s[h - 1][f].min + 1,
                  p = s[h][f - 1].min + 1,
                  d = s[h - 1][f - 1].min + o;
              s[h][f] = O(l, p, d);
            }
          }

          return s;
        }(t, e),
            r = t.length,
            i = e.length,
            a = [],
            o = 1,
            s = 1;

        if (n[r][i] !== r) {
          for (var u = 1; u <= r; u++) {
            var c = n[u][u].min;
            s = u;

            for (var h = o; h <= i; h++) {
              n[u][h].min < c && (c = n[u][h].min, s = h);
            }

            o = s, n[u][o].type && a.push({
              index: u - 1,
              type: n[u][o].type
            });
          }

          for (var f = a.length - 1; f >= 0; f--) {
            o = a[f].index, "add" === a[f].type ? t.splice(o, 0, [].concat(t[o])) : t.splice(o, 1);
          }
        }

        var l = i - (r = t.length);
        if (r < i) for (var p = 0; p < l; p++) {
          "z" === t[r - 1][0] || "Z" === t[r - 1][0] ? t.splice(r - 2, 0, t[r - 2]) : t.push(t[r - 1]), r += 1;
        }
        return t;
      },
      formatPath: function formatPath(t, e) {
        if (t.length <= 1) return t;

        for (var n, r = 0; r < e.length; r++) {
          if (t[r][0] !== e[r][0]) switch (n = I(t[r]), e[r][0]) {
            case "M":
              t[r] = ["M"].concat(n[0]);
              break;

            case "L":
              t[r] = ["L"].concat(n[0]);
              break;

            case "A":
              t[r] = [].concat(e[r]), t[r][6] = n[0][0], t[r][7] = n[0][1];
              break;

            case "Q":
              if (n.length < 2) {
                if (!(r > 0)) {
                  t[r] = e[r];
                  break;
                }

                n = C(n, t[r - 1], 1);
              }

              t[r] = ["Q"].concat(n.reduce(function (t, e) {
                return t.concat(e);
              }, []));
              break;

            case "T":
              t[r] = ["T"].concat(n[0]);
              break;

            case "C":
              if (n.length < 3) {
                if (!(r > 0)) {
                  t[r] = e[r];
                  break;
                }

                n = C(n, t[r - 1], 2);
              }

              t[r] = ["C"].concat(n.reduce(function (t, e) {
                return t.concat(e);
              }, []));
              break;

            case "S":
              if (n.length < 2) {
                if (!(r > 0)) {
                  t[r] = e[r];
                  break;
                }

                n = C(n, t[r - 1], 1);
              }

              t[r] = ["S"].concat(n.reduce(function (t, e) {
                return t.concat(e);
              }, []));
              break;

            default:
              t[r] = e[r];
          }
        }

        return t;
      },
      intersection: function intersection(t, e) {
        return function (t, e, n) {
          var r, i, a, o, s, u, c, h, f, l;
          t = p(t), e = p(e);

          for (var d = n ? 0 : [], g = 0, v = t.length; g < v; g++) {
            var m = t[g];
            if ("M" === m[0]) r = s = m[1], i = u = m[2];else {
              "C" === m[0] ? (r = (f = [r, i].concat(m.slice(1)))[6], i = f[7]) : (f = [r, i, r, i, s, u, s, u], r = s, i = u);

              for (var x = 0, y = e.length; x < y; x++) {
                var b = e[x];
                if ("M" === b[0]) a = c = b[1], o = h = b[2];else {
                  "C" === b[0] ? (a = (l = [a, o].concat(b.slice(1)))[6], o = l[7]) : (l = [a, o, a, o, c, h, c, h], a = c, o = h);
                  var M = E(f, l, n);
                  if (n) d += M;else {
                    for (var w = 0, _ = M.length; w < _; w++) {
                      M[w].segment1 = g, M[w].segment2 = x, M[w].bez1 = f, M[w].bez2 = l;
                    }

                    d = d.concat(M);
                  }
                }
              }
            }
          }

          return d;
        }(t, e);
      }
    };
  }, function (t, e, n) {
    var r = n(19),
        i = n(58),
        a = n(593),
        o = n(600),
        s = function t(e) {
      t.superclass.constructor.call(this, e);
    };

    s.Symbols = {
      circle: function circle(t, e, n) {
        return [["M", t, e], ["m", -n, 0], ["a", n, n, 0, 1, 0, 2 * n, 0], ["a", n, n, 0, 1, 0, 2 * -n, 0]];
      },
      square: function square(t, e, n) {
        return [["M", t - n, e - n], ["L", t + n, e - n], ["L", t + n, e + n], ["L", t - n, e + n], ["Z"]];
      },
      diamond: function diamond(t, e, n) {
        return [["M", t - n, e], ["L", t, e - n], ["L", t + n, e], ["L", t, e + n], ["Z"]];
      },
      triangle: function triangle(t, e, n) {
        var r = n * Math.sin(1 / 3 * Math.PI);
        return [["M", t - n, e + r], ["L", t, e - r], ["L", t + n, e + r], ["z"]];
      },
      "triangle-down": function triangleDown(t, e, n) {
        var r = n * Math.sin(1 / 3 * Math.PI);
        return [["M", t - n, e - r], ["L", t + n, e - r], ["L", t, e + r], ["Z"]];
      }
    }, s.ATTRS = {
      path: null,
      lineWidth: 1
    }, r.extend(s, i), r.augment(s, {
      type: "marker",
      canFill: !0,
      canStroke: !0,
      getDefaultAttrs: function getDefaultAttrs() {
        return {
          x: 0,
          y: 0,
          lineWidth: 1
        };
      },
      calculateBox: function calculateBox() {
        var t = this._attrs,
            e = t.x,
            n = t.y,
            r = t.radius,
            i = this.getHitLineWidth() / 2 + r;
        return {
          minX: e - i,
          minY: n - i,
          maxX: e + i,
          maxY: n + i
        };
      },
      _getPath: function _getPath() {
        var t = this._attrs,
            e = t.x,
            n = t.y,
            i = t.radius || t.r,
            a = t.symbol || "circle";
        return (r.isFunction(a) ? a : s.Symbols[a])(e, n, i);
      },
      createPath: function createPath(t) {
        var e = this._cfg.segments;

        if (!e || this._cfg.hasUpdate) {
          var n,
              r = a.parsePath(this._getPath());
          t.beginPath(), e = [];

          for (var i = 0; i < r.length; i++) {
            var s = r[i];
            n = new o(s, n, i === r.length - 1), e.push(n), n.draw(t);
          }

          this._cfg.segments = e, this._cfg.hasUpdate = !1;
        } else {
          t.beginPath();

          for (var u = 0; u < e.length; u++) {
            e[u].draw(t);
          }
        }
      }
    }), t.exports = s;
  }, function (t, e, n) {
    var r = n(19),
        i = r.vec2;

    function a(t, e, n, r, i) {
      var a = 1 - i;
      return a * a * (a * r + 3 * i * n) + i * i * (i * t + 3 * a * e);
    }

    function o(t, e, n, r, o, s, u, c, h, f, l) {
      var p,
          d,
          g,
          v,
          m,
          x,
          y,
          b,
          M = .005,
          w = 1 / 0,
          _ = [h, f];

      for (d = 0; d < 1; d += .05) {
        g = [a(t, n, o, u, d), a(e, r, s, c, d)], (v = i.squaredDistance(_, g)) < w && (p = d, w = v);
      }

      w = 1 / 0;

      for (var E = 0; E < 32 && !(M < 1e-4); E++) {
        b = p + M, g = [a(t, n, o, u, y = p - M), a(e, r, s, c, y)], v = i.squaredDistance(_, g), y >= 0 && v < w ? (p = y, w = v) : (x = [a(t, n, o, u, b), a(e, r, s, c, b)], m = i.squaredDistance(_, x), b <= 1 && m < w ? (p = b, w = m) : M *= .5);
      }

      return l && (l.x = a(t, n, o, u, p), l.y = a(e, r, s, c, p)), Math.sqrt(w);
    }

    function s(t, e, n, r, i) {
      return t * (t * (-3 * e + 9 * n - 9 * r + 3 * i) + 6 * e - 12 * n + 6 * r) - 3 * e + 3 * n;
    }

    t.exports = {
      at: a,
      derivativeAt: function derivativeAt(t, e, n, r, i) {
        var a = 1 - i;
        return 3 * (((e - t) * a + 2 * (n - e) * i) * a + (r - n) * i * i);
      },
      projectPoint: function projectPoint(t, e, n, r, i, a, s, u, c, h) {
        var f = {};
        return o(t, e, n, r, i, a, s, u, c, h, f), f;
      },
      pointDistance: o,
      extrema: function extrema(t, e, n, i) {
        var a,
            o,
            s,
            u = 3 * t - 9 * e + 9 * n - 3 * i,
            c = 6 * e - 12 * n + 6 * i,
            h = 3 * n - 3 * i,
            f = [];
        if (r.isNumberEqual(u, 0)) r.isNumberEqual(c, 0) || (a = -h / c) >= 0 && a <= 1 && f.push(a);else {
          var l = c * c - 4 * u * h;
          r.isNumberEqual(l, 0) ? f.push(-c / (2 * u)) : l > 0 && (o = (-c - (s = Math.sqrt(l))) / (2 * u), (a = (-c + s) / (2 * u)) >= 0 && a <= 1 && f.push(a), o >= 0 && o <= 1 && f.push(o));
        }
        return f;
      },
      len: function len(t, e, n, i, a, o, u, c, h) {
        r.isNil(h) && (h = 1);

        for (var f = (h = h > 1 ? 1 : h < 0 ? 0 : h) / 2, l = [-.1252, .1252, -.3678, .3678, -.5873, .5873, -.7699, .7699, -.9041, .9041, -.9816, .9816], p = [.2491, .2491, .2335, .2335, .2032, .2032, .1601, .1601, .1069, .1069, .0472, .0472], d = 0, g = 0; g < 12; g++) {
          var v = f * l[g] + f,
              m = s(v, t, n, a, u),
              x = s(v, e, i, o, c),
              y = m * m + x * x;
          d += p[g] * Math.sqrt(y);
        }

        return f * d;
      }
    };
  }, function (t, e, n) {
    var r = n(603),
        i = n(640),
        a = n(612),
        o = n(602);
    t.exports = {
      line: function line(t, e, n, i, a, o, s) {
        var u = r.box(t, e, n, i, a);
        if (!this.box(u.minX, u.maxX, u.minY, u.maxY, o, s)) return !1;
        var c = r.pointDistance(t, e, n, i, o, s);
        return !isNaN(c) && c <= a / 2;
      },
      polyline: function polyline(t, e, n, r) {
        var i = t.length - 1;
        if (i < 1) return !1;

        for (var a = 0; a < i; a++) {
          var o = t[a][0],
              s = t[a][1],
              u = t[a + 1][0],
              c = t[a + 1][1];
          if (this.line(o, s, u, c, e, n, r)) return !0;
        }

        return !1;
      },
      cubicline: function cubicline(t, e, n, r, i, o, s, u, c, h, f) {
        return a.pointDistance(t, e, n, r, i, o, s, u, h, f) <= c / 2;
      },
      quadraticline: function quadraticline(t, e, n, r, a, o, s, u, c) {
        return i.pointDistance(t, e, n, r, a, o, u, c) <= s / 2;
      },
      arcline: function arcline(t, e, n, r, i, a, s, u, c) {
        return o.pointDistance(t, e, n, r, i, a, u, c) <= s / 2;
      },
      rect: function rect(t, e, n, r, i, a) {
        return t <= i && i <= t + n && e <= a && a <= e + r;
      },
      circle: function circle(t, e, n, r, i) {
        return Math.pow(r - t, 2) + Math.pow(i - e, 2) <= Math.pow(n, 2);
      },
      box: function box(t, e, n, r, i, a) {
        return t <= i && i <= e && n <= a && a <= r;
      }
    };
  }, function (t, e, n) {
    var r = n(619),
        i = n(118),
        a = n(595);

    t.exports = function t(e, n) {
      if (e === n) return !0;
      if (!e || !n) return !1;
      if (a(e) || a(n)) return !1;

      if (i(e) || i(n)) {
        if (e.length !== n.length) return !1;

        for (var o = !0, s = 0; s < e.length && (o = t(e[s], n[s])); s++) {
          ;
        }

        return o;
      }

      if (r(e) || r(n)) {
        var u = Object.keys(e),
            c = Object.keys(n);
        if (u.length !== c.length) return !1;

        for (var h = !0, f = 0; f < u.length && (h = t(e[u[f]], n[u[f]])); f++) {
          ;
        }

        return h;
      }

      return !1;
    };
  }, function (t, e, n) {
    var r = n(596),
        i = n(45),
        a = 5;

    function o(t, e, n, s) {
      for (var u in n = n || 0, s = s || a, e) {
        if (e.hasOwnProperty(u)) {
          var c = e[u];
          null !== c && r(c) ? (r(t[u]) || (t[u] = {}), n < s ? o(t[u], c, n + 1, s) : t[u] = e[u]) : i(c) ? (t[u] = [], t[u] = t[u].concat(c)) : void 0 !== c && (t[u] = c);
        }
      }
    }

    t.exports = function () {
      for (var t = new Array(arguments.length), e = t.length, n = 0; n < e; n++) {
        t[n] = arguments[n];
      }

      for (var r = t[0], i = 1; i < e; i++) {
        o(r, t[i]);
      }

      return r;
    };
  }, function (t, e, n) {
    var r = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (t) {
      return _typeof(t);
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : _typeof(t);
    },
        i = n(45);

    t.exports = function t(e) {
      if ("object" !== (void 0 === e ? "undefined" : r(e)) || null === e) return e;
      var n = void 0;

      if (i(e)) {
        n = [];

        for (var a = 0, o = e.length; a < o; a++) {
          "object" === r(e[a]) && null != e[a] ? n[a] = t(e[a]) : n[a] = e[a];
        }
      } else for (var s in n = {}, e) {
        "object" === r(e[s]) && null != e[s] ? n[s] = t(e[s]) : n[s] = e[s];
      }

      return n;
    };
  }, function (t, e, n) {
    var r = n(256);
    r.translate = function (t, e, n) {
      var i = new Array(9);
      return r.fromTranslation(i, n), r.multiply(t, i, e);
    }, r.rotate = function (t, e, n) {
      var i = new Array(9);
      return r.fromRotation(i, n), r.multiply(t, i, e);
    }, r.scale = function (t, e, n) {
      var i = new Array(9);
      return r.fromScaling(i, n), r.multiply(t, i, e);
    }, t.exports = r;
  }, function (t, e) {
    t.exports = function (t, e, n) {
      return t < e ? e : t > n ? n : t;
    };
  }, function (t, e) {
    var n = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (t) {
      return _typeof(t);
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : _typeof(t);
    };

    t.exports = function (t) {
      return "object" === (void 0 === t ? "undefined" : n(t)) && null !== t;
    };
  }, function (t, e, n) {
    var r = n(46),
        i = n(118);

    t.exports = function (t, e) {
      if (!i(t)) return t;
      var n = [];
      return r(t, function (t, r) {
        e(t, r) && n.push(t);
      }), n;
    };
  }, function (t, e) {
    var n = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (t) {
      return _typeof(t);
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : _typeof(t);
    };

    t.exports = function (t) {
      var e = void 0 === t ? "undefined" : n(t);
      return null !== t && "object" === e || "function" === e;
    };
  }, function (t, e) {
    var n = function () {
      function t() {}

      return t.prototype.execute = function () {
        throw new Error("please override this method");
      }, t;
    }();

    t.exports = n;
  }, function (t, e, n) {
    t.exports = {
      CompactBoxTree: n(688),
      Dendrogram: n(687),
      IndentedTree: n(686),
      Mindmap: n(685),
      Base: n(622)
    };
  }, function (t, e, n) {
    var r = n(26),
        i = function (t) {
      function e(e) {
        var n = {
          type: "node",
          isNode: !0,
          zIndex: 3,
          edges: [],
          linkable: !0
        };
        return r.mix(n, e), t.call(this, n) || this;
      }

      !function (t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
      }(e, t);
      var n = e.prototype;
      return n.updatePosition = function () {
        var t = this.group,
            e = this.model;
        t.setMatrix([1, 0, 0, 0, 1, 0, e.x ? e.x : 0, e.y ? e.y : 0, 1]), this.bbox = this._calculateBBox();
      }, n._shouldDraw = function () {
        var e = this._getDiff(),
            n = t.prototype._shouldDraw.call(this);

        return e && !(2 === e.length && -1 !== e.indexOf("x") && -1 !== e.indexOf("y")) && !(1 === e.length && ("x" === e[0] || "y" === e[0])) && n;
      }, n._afterDraw = function () {
        this.updatePosition(), t.prototype._afterDraw.call(this);
      }, n.layoutUpdate = function () {
        this._beforeDraw(), this._afterDraw();
      }, n.getEdges = function () {
        var t = this;
        return this.graph.getEdges().filter(function (e) {
          var n = e.getModel();
          return n.source === t.id || n.target === t.id;
        });
      }, n.getInEdges = function () {
        var t = this;
        return this.getEdges().filter(function (e) {
          return e.target === t;
        });
      }, n.getOutEdges = function () {
        var t = this;
        return this.getEdges().filter(function (e) {
          return e.source === t;
        });
      }, n.getLinkPoints = function (t) {
        var e = this.getAnchorPoints();
        if (r.isNumber(t) && e[t]) return [e[t]];
        var n = t.x,
            i = t.y,
            a = this.getBBox(),
            o = a.centerX,
            s = a.centerY,
            u = n - o,
            c = i - s,
            h = this.shapeObj,
            f = h.anchor || {},
            l = this.defaultIntersectBox,
            p = [];

        if (r.isEmpty(e)) {
          switch (h.intersectBox || f.intersectBox || f.type || l) {
            case "rect":
              p = [r.getIntersectPointRect(a, t)];
              break;

            case "path":
              if (this.keyShape && "path" === this.keyShape.get("type")) {
                var d = r.parsePathArray(["M", n, i, "L", o, s]);
                p = [r.intersection(d, this.keyShape.get("path"))];
              }

              break;

            default:
              p = [r.getIntersectPointCircle(n, i, a.centerX, a.centerY, Math.max(a.width, a.height) / 2)];
          }

          r.isEmpty(p[0]) && (p = [{
            x: o,
            y: s
          }]);
        } else p = e.map(function (t) {
          var e = t.x - o,
              n = t.y - s,
              i = r.getArcOfVectors({
            x: u,
            y: c
          }, {
            x: e,
            y: n
          });
          return r.mix({}, t, {
            arc: i
          });
        }).sort(function (t, e) {
          return t.arc - e.arc;
        });

        return p;
      }, n.getAnchorPoints = function (t) {
        var e,
            n = this.shapeObj,
            i = this.getBBox(),
            a = [],
            o = n.anchor || {};
        return e = r.isArray(o) ? o : r.isFunction(o) ? o(this) : r.isFunction(o.points) ? o.points(this) : o.points, r.each(e, function (t, e) {
          var n = r.mix({
            x: i.minX + t[0] * i.width,
            y: i.minY + t[1] * i.height
          }, t[2], {
            index: e
          });
          a.push(n);
        }), this._anchorPoints = a, r.isNumber(t) ? this._anchorPoints[t] : this._anchorPoints;
      }, e;
    }(n(608));

    t.exports = i;
  }, function (t, e, n) {
    function r(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : t[e] = n, t;
    }

    n(715), n(714), n(713);

    var i = n(712),
        a = n(710),
        o = n(683),
        s = n(26),
        u = n(706),
        c = n(248),
        h = n(704),
        f = n(702),
        l = n(700),
        p = n(699),
        d = n(697),
        g = n(696),
        v = n(695),
        m = n(692),
        x = n(691),
        y = [g, f, l, h, v, m, n(690), x, p, d],
        b = function (t) {
      !function (t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
      }(n, t);
      var e = n.prototype;

      function n(e) {
        var n,
            r = {};
        return y.forEach(function (t) {
          s.mix(r, s.clone(t.CFG), e);
        }), (n = t.call(this, r) || this)._pluginInit(), n.emit("beforeinit"), n._init(), n.emit("afterinit"), n;
      }

      return e.getDefaultCfg = function () {
        return {
          container: void 0,
          width: void 0,
          height: void 0,
          plugins: [],
          fontFamily: '"Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", SimSun, "sans-serif"',
          nodeDefaultShape: void 0,
          edgeDefaultShape: void 0,
          groupDefaultShape: void 0,
          defaultIntersectBox: "circle",
          renderer: "canvas",
          _type: "graph",
          _controllers: {},
          _timers: {},
          _dataMap: {},
          _itemMap: {},
          _freezMap: {},
          _data: {},
          _delayRunObj: {}
        };
      }, e._init = function () {
        var t = this;
        this._initData(), this._initContainer(), this._initCanvas(), y.forEach(function (e) {
          e.INIT && t[e.INIT]();
        }), this.initEvent();
      }, e.initEvent = function () {}, e._executeLayout = function (t, e, n, r) {
        s.isFunction(t) ? t(e, n, this) : s.isObject(t) && (t.nodes = e, t.edges = n, t.groups = r, t.graph = this, t.execute());
      }, e._pluginInit = function () {
        var t = this;
        this.get("plugins").forEach(function (e) {
          t._initPlugin(e);
        });
      }, e._initPlugin = function (t) {
        t.graph = this, t.init && t.init();
      }, e._getTimer = function (t) {
        return this.get("_timers")[t];
      }, e._setTimer = function (t, e) {
        this.get("_timers")[t] = e;
      }, e._getController = function (t) {
        return this.get("_controllers")[t];
      }, e._initContainer = function () {
        var t = this.get("container");
        t || (t = this.get("id")), t = s.initDOMContainer(t, "graph");
        var e = s.createDOM('<div class="graph-container"></div>', {
          position: "relative"
        });
        t.appendChild(e), this.set("_containerDOM", t), this.set("_graphContainer", e);
      }, e._initCanvas = function () {
        var t = this.get("_graphContainer"),
            e = this.get("width"),
            n = this.get("height"),
            r = this.get("fontFamily"),
            i = this.get("renderer"),
            a = {
          width: e,
          height: n,
          fontFamily: r,
          renderer: i,
          eventEnable: !1,
          containerDOM: t
        };
        "svg" === i && (a.pixelRatio = 1);
        var o = new (0, c.Canvas)(a),
            s = o.get("el");
        s.style.top = 0, s.style.left = 0, s.style.overflow = "hidden", this.set("_canvas", o);
        var u = this.getMouseEventWrapper();
        u.style.outline = "none", u.style["user-select"] = "none", u.setAttribute("tabindex", 20);
        var h = o.addGroup(),
            f = h.addGroup();
        this.set("_itemGroup", f), this.set("_rootGroup", h);
      }, e._initData = function () {
        this.set("_dataMap", {}), this.set("_itemMap", {
          _nodes: [],
          _edges: [],
          _groups: [],
          _guides: []
        }), this.set("_data", {});
      }, e._refresh = function () {}, e.getKeyboardEventWrapper = function () {
        var t = this.get("keyboardEventWrapper");
        return t || this.getMouseEventWrapper();
      }, e.getMouseEventWrapper = function () {
        return this.get("_canvas").get("el");
      }, e.addPlugin = function (t) {
        var e = this.get("plugins");
        this._initPlugin(t), e.push(t);
      }, e.getGraphContainer = function () {
        return this.get("_graphContainer");
      }, e._sortGroup = function (t) {
        var e = this.get("_dataMap"),
            n = {};
        t.forEach(function (t) {
          var r = t.id,
              i = t.parent;

          for (n[r] = 1; i && e[i];) {
            n[r]++, i = e[i].parent;
          }
        }), t.sort(function (t, e) {
          return n[e.id] - n[t.id];
        });
      }, e._addItems = function (t, e) {
        var n = this;
        this._addDatas(t, e), "group" === t && this._sortGroup(e);
        var r = s.upperFirst(t),
            i = a[r],
            o = this.get("_itemMap"),
            u = this.get("_itemGroup"),
            c = this.get("_dataMap"),
            h = this.get("animate"),
            f = this.get("defaultIntersectBox");
        if (!i) throw new Error("please set valid item type!");
        e.forEach(function (e) {
          var r = new i({
            id: e.id,
            type: t,
            model: e,
            group: u.addGroup(),
            graph: n,
            mapper: n._getController(t + "Mapper"),
            itemMap: o,
            animate: h,
            dataMap: c,
            defaultIntersectBox: f
          });
          o[e.id] = r, o["_" + t + "s"].push(r);
        });
      }, e._removeItems = function (t) {
        var e = this.get("_dataMap"),
            n = this.get("_itemMap");
        t.forEach(function (t) {
          delete e[t.id], delete n[t.id], s.Array.remove(n["_" + t.type + "s"], t), t.destroy();
        });
      }, e._updateItems = function (t, e) {
        t.forEach(function (t, n) {
          var r = e[n];
          r && s.mix(t.getModel(), r), t.update();
        });
      }, e._getShowEdge = function (t) {
        var e = t.getSource(),
            n = t.getTarget();
        return (e.linkable && e.isVisible() || !e.linkable) && (n.linkable && n.isVisible() || !n.linkable) && t;
      }, e._addDatas = function (t, e) {
        var n = this.get("_dataMap");
        e.forEach(function (t) {
          if (s.isNil(t.id) && (t.id = s.guid()), n[t.id]) throw new Error("id:" + t.id + " has already been set, please set new one");
          n[t.id] = t;
        });
      }, e._drawInner = function () {
        var t = this.get("_data"),
            e = this.get("_itemGroup"),
            n = this.get("_dataMap"),
            r = this.get("_itemMap");
        t.nodes && this._addItems("node", t.nodes), t.groups && this._addItems("group", t.groups), t.edges && this._addItems("edge", t.edges), t.guides && this._addItems("guide", t.guides), e.sortBy(function (t) {
          var e = t.id,
              i = r[e],
              a = n[e];
          return a && !s.isNil(a.index) ? a.index : !i || i.destroyed || s.isNil(i.zIndex) ? void 0 : i.zIndex;
        });
      }, e._clearInner = function () {
        this.getItems().forEach(function (t) {
          t && t.destroy();
        });
      }, e.preventAnimate = function (t) {
        return this.set("_forcePreventAnimate", !0), t(), this.set("_forcePreventAnimate", !1), this;
      }, e.getShapeObj = function (t, e) {
        if (!s.isObject(t)) {
          var n = s.upperFirst(t),
              r = o[n],
              i = this.get(t + "DefaultShape");
          return r.getShape(e.shape, i);
        }

        return t.getShapeObj();
      }, e.getSource = function () {
        return this.get("_sourceData");
      }, e.parseSource = function (t) {
        return t;
      }, e.getCanvas = function () {
        return this.get("_canvas");
      }, e.getRootGroup = function () {
        return this.get("_rootGroup");
      }, e.getItemGroup = function () {
        return this.get("_itemGroup");
      }, e.source = function (t) {
        return this.emit("beforesource"), this.set("_data", t), this.set("_sourceData", t), this.emit("aftersource"), this;
      }, e.render = function () {
        return this.emit("beforerender"), this.emit("beforedrawinner"), this._drawInner(), this.emit("afterdrawinner"), this.emit("afterrender"), this;
      }, e.reRender = function () {
        var t = this.get("_sourceData");
        return this.read(t), this;
      }, e.setCapture = function (t) {
        this.get("_rootGroup").set("capture", t);
      }, e.destroy = function () {
        this.emit("beforedestroy");
        var e = this.get("_canvas"),
            n = this.get("_graphContainer"),
            r = this.get("_controllers"),
            i = this.get("_timers"),
            a = this.get("_windowForceResizeEvent"),
            o = this.get("plugins");
        return s.each(i, function (t) {
          clearTimeout(t);
        }), s.each(r, function (t) {
          t.destroy();
        }), o.forEach(function (t) {
          t.destroy && t.destroy();
        }), e && e.destroy(), n.destroy(), window.removeEventListener("resize", a), this.emit("afterdestroy"), t.prototype.destroy.call(this), this;
      }, e.save = function () {
        var t = {
          nodes: [],
          edges: [],
          groups: [],
          guides: []
        };
        return this.get("_itemGroup").get("children").forEach(function (e, n) {
          var r = e.model;

          if (r) {
            var i = e.itemType,
                a = s.clone(r);
            a.index = n, t[i + "s"].push(a);
          }
        }), 0 === t.nodes.length && delete t.nodes, 0 === t.edges.length && delete t.edges, 0 === t.groups.length && delete t.groups, 0 === t.guides.length && delete t.guides, t;
      }, e.add = function (t, e) {
        var n = [],
            r = {
          action: "add",
          model: e,
          affectedItemIds: n
        };
        this.emit("beforechange", r);
        var i = this.get("_itemMap");

        this._addItems(t, [e]);

        var a = i[e.id];
        return a.getAllParents().forEach(function (t) {
          t.update();
        }), r.item = a, n.push(e.id), this.emit("afterchange", r), a;
      }, e.remove = function (t) {
        if ((t = this.getItem(t)) && !t.destroyed) {
          var e = [],
              n = [],
              r = {
            action: "remove",
            item: t,
            affectedItemIds: n
          };

          if (t.isNode) {
            var i = t.getEdges();
            e = e.concat(i);
          }

          if (t.isGroup) {
            var a = t.getEdges(),
                o = t.getAllChildren(),
                u = t.getCrossEdges(),
                c = t.getInnerEdges();
            e = e.concat(a, o, u, c), e = s.uniq(e);
          }

          e.push(t);
          var h = t.getAllParents();
          return h.forEach(function (t) {
            n.push(t.id);
          }), e.forEach(function (t) {
            n.push(t.id);
          }), this.emit("beforechange", r), this._removeItems(e), h.forEach(function (t) {
            t.update();
          }), this.emit("afterchange", r), this;
        }
      }, e.simpleUpdate = function (t, e) {
        return this._updateItems([t], [e]), this.draw(), this;
      }, e.update = function (t, e) {
        var n = this.get("_itemMap");

        if ((t = this.getItem(t)) && !t.destroyed && e) {
          var r = this.get("animate"),
              i = [],
              a = [],
              o = [],
              u = t.getModel(),
              c = s.mix({}, u),
              h = {
            action: "update",
            item: t,
            originModel: c,
            updateModel: e,
            affectedItemIds: o
          },
              f = n[c.parent];

          if (i.push(t), a.push(e), o.push(t.id), f && f !== parent && s.isGroup(f) && t.getAllParents().forEach(function (t) {
            i.push(t), a.push(null), o.push(t.id);
          }), e.parent) {
            var l = n[e.parent];
            if (!l) throw new Error("there is no " + e.parent + " exist, please add a new one!");
            i.push(l), a.push(null), o.push(l.id), l.getAllParents().forEach(function (t) {
              i.push(t), a.push(null), o.push(t.id);
            });
          }

          if (t.isNode || t.isGroup) t.getEdges().forEach(function (t) {
            i.push(t), a.push(null), o.push(t.id);
          });
          return t.isGroup && !s.isNil(e.collapsed) && (r && t.deepEach(function (t) {
            o.push(t.id);
          }), t.getCrossEdges().forEach(function (t) {
            i.push(t), a.push(null), o.push(t.id);
          })), this.emit("beforechange", h), this._updateItems(i, a), this.emit("afterchange", h), this;
        }
      }, e.read = function (t) {
        var e = this;
        if (!t) throw new Error("please read valid data!");
        var n = {
          action: "changeData",
          data: t
        };
        return this.emit("beforechange", n), this.preventAnimate(function () {
          e.clear(), e.source(t), e.render();
        }), this.emit("afterchange", n), this;
      }, e.clear = function () {
        return this.emit("beforeclear"), this._clearInner(), this._initData(), this.emit("afterclear"), this;
      }, e.hide = function (t) {
        var e = [],
            n = [],
            r = {
          item: t = this.getItem(t),
          affectedItemIds: n
        };
        return e.push(t), t.isNode && t.getEdges().forEach(function (t) {
          e.push(t);
        }), t.isGroup && (t.getEdges().forEach(function (t) {
          e.push(t);
        }), t.deepEach(function (t) {
          e.push(t);
        })), (e = s.uniq(e)).forEach(function (t) {
          n.push(t.id);
        }), this.emit("beforehide", r), e.forEach(function (t) {
          t.hide();
        }), this.emit("afterhide", r), this;
      }, e.show = function (t) {
        var e = this,
            n = [],
            r = [],
            i = {
          item: t = this.getItem(t),
          affectedItemIds: r
        };

        if (t.visible = !0, t.isEdge) {
          var a = this._getShowEdge(t);

          a && n.push(a);
        } else n.push(t);

        return t.isNode && t.getEdges().forEach(function (t) {
          (t = e._getShowEdge(t)) && n.push(t);
        }), t.isGroup && (t.getEdges().forEach(function (t) {
          (t = e._getShowEdge(t)) && n.push(t);
        }), t.deepEach(function (t) {
          n.push(t);
        })), (n = s.uniq(n)).forEach(function (t) {
          r.push(t.id);
        }), this.emit("beforeshow", i), n.forEach(function (t) {
          t.show();
        }), this.emit("aftershow", i), this;
      }, e.getWidth = function () {
        return this.get("width");
      }, e.getHeight = function () {
        return this.get("height");
      }, e.changeSize = function (t, e) {
        if (!(Math.abs(t) >= 1 / 0 || Math.abs(e) >= 1 / 0)) {
          var n = this.get("_canvas");
          return t === this.get("width") && e === this.get("height") || (this.emit("beforechangesize"), n.changeSize(t, e), this.set("width", t), this.set("height", e), this.emit("afterchangesize"), this.draw()), this;
        }

        console.warn("size parameter more than the maximum");
      }, e.toFront = function (t) {
        t = this.getItem(t);
        var e = this.get("_itemGroup"),
            n = t.getGraphicGroup();
        s.toFront(n, e), this.draw();
      }, e.toBack = function (t) {
        t = this.getItem(t);
        var e = this.get("_itemGroup"),
            n = t.getGraphicGroup();
        s.toBack(n, e), this.draw();
      }, e.css = function (t) {
        var e = this.getGraphContainer();
        s.modifyCSS(e, t);
      }, e.saveImage = function (t) {
        var e = this.getBBox(),
            n = this.getFitViewPadding();
        return new u(function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = null != arguments[e] ? arguments[e] : {},
                i = Object.keys(n);
            "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter(function (t) {
              return Object.getOwnPropertyDescriptor(n, t).enumerable;
            }))), i.forEach(function (e) {
              r(t, e, n[e]);
            });
          }

          return t;
        }({
          graph: this,
          width: e.width + n[1] + n[3],
          height: e.height + n[0] + n[2]
        }, t)).toCanvas();
      }, n;
    }(i);

    y.forEach(function (t) {
      s.mix(b.prototype, t.AUGMENT);
    }), t.exports = b;
  }, function (t, e) {
    var n = {
      registerBehaviour: function registerBehaviour(t, e, r) {
        e.dependences = r, n[t] = e;
      },
      resetMode: function resetMode(t, e) {
        var r,
            i = [];

        e._off();

        for (var a = 0; a < t.length; a++) {
          (r = n[t[a]]) && (r.dependences && r.dependences.forEach(function (t) {
            t && -1 === i.indexOf(t) && (n[t](e), i.push(t));
          }), r && -1 === i.indexOf(r) && r(e));
        }
      }
    };
    t.exports = n;
  }, function (t, e, n) {
    var r = n(19),
        i = n(58),
        a = function t(e) {
      t.superclass.constructor.call(this, e);
    };

    a.ATTRS = {
      x: 0,
      y: 0,
      text: null,
      fontSize: 12,
      fontFamily: "sans-serif",
      fontStyle: "normal",
      fontWeight: "normal",
      fontVariant: "normal",
      textAlign: "start",
      textBaseline: "bottom",
      lineHeight: null,
      textArr: null
    }, r.extend(a, i), r.augment(a, {
      canFill: !0,
      canStroke: !0,
      type: "text",
      getDefaultAttrs: function getDefaultAttrs() {
        return {
          lineWidth: 1,
          lineCount: 1,
          fontSize: 12,
          fontFamily: "sans-serif",
          fontStyle: "normal",
          fontWeight: "normal",
          fontVariant: "normal",
          textAlign: "start",
          textBaseline: "bottom"
        };
      },
      initTransform: function initTransform() {
        var t = this._attrs.fontSize;
        t && +t < 12 && this.transform([["t", -1 * this._attrs.x, -1 * this._attrs.y], ["s", +t / 12, +t / 12], ["t", this._attrs.x, this._attrs.y]]);
      },
      _assembleFont: function _assembleFont() {
        var t = this._attrs,
            e = t.fontSize,
            n = t.fontFamily,
            r = t.fontWeight,
            i = t.fontStyle,
            a = t.fontVariant;
        t.font = [i, a, r, e + "px", n].join(" ");
      },
      _setAttrText: function _setAttrText() {
        var t = this._attrs,
            e = t.text,
            n = null;

        if (r.isString(e) && -1 !== e.indexOf("\n")) {
          var i = (n = e.split("\n")).length;
          t.lineCount = i;
        }

        t.textArr = n;
      },
      _getTextHeight: function _getTextHeight() {
        var t = this._attrs,
            e = t.lineCount,
            n = 1 * t.fontSize;
        return e > 1 ? n * e + this._getSpaceingY() * (e - 1) : n;
      },
      isHitBox: function isHitBox() {
        return !1;
      },
      calculateBox: function calculateBox() {
        var t = this._attrs,
            e = this._cfg;
        e.attrs && !e.hasUpdate || (this._assembleFont(), this._setAttrText()), t.textArr || this._setAttrText();
        var n = t.x,
            r = t.y,
            i = this.measureText();
        if (!i) return {
          minX: n,
          minY: r,
          maxX: n,
          maxY: r
        };

        var a = this._getTextHeight(),
            o = t.textAlign,
            s = t.textBaseline,
            u = this.getHitLineWidth(),
            c = {
          x: n,
          y: r - a
        };

        o && ("end" === o || "right" === o ? c.x -= i : "center" === o && (c.x -= i / 2)), s && ("top" === s ? c.y += a : "middle" === s && (c.y += a / 2)), this.set("startPoint", c);
        var h = u / 2;
        return {
          minX: c.x - h,
          minY: c.y - h,
          maxX: c.x + i + h,
          maxY: c.y + a + h
        };
      },
      _getSpaceingY: function _getSpaceingY() {
        var t = this._attrs,
            e = t.lineHeight,
            n = 1 * t.fontSize;
        return e ? e - n : .14 * n;
      },
      drawInner: function drawInner(t) {
        var e = this._attrs,
            n = this._cfg;
        n.attrs && !n.hasUpdate || (this._assembleFont(), this._setAttrText()), t.font = e.font;
        var i = e.text;

        if (i) {
          var a = e.textArr,
              o = e.x,
              s = e.y;

          if (t.beginPath(), this.hasStroke()) {
            var u = e.strokeOpacity;
            r.isNil(u) || 1 === u || (t.globalAlpha = u), a ? this._drawTextArr(t, !1) : t.strokeText(i, o, s), t.globalAlpha = 1;
          }

          if (this.hasFill()) {
            var c = e.fillOpacity;
            r.isNil(c) || 1 === c || (t.globalAlpha = c), a ? this._drawTextArr(t, !0) : t.fillText(i, o, s);
          }

          n.hasUpdate = !1;
        }
      },
      _drawTextArr: function _drawTextArr(t, e) {
        var n,
            i = this._attrs.textArr,
            a = this._attrs.textBaseline,
            o = 1 * this._attrs.fontSize,
            s = this._getSpaceingY(),
            u = this._attrs.x,
            c = this._attrs.y,
            h = this.getBBox(),
            f = h.maxY - h.minY;

        r.each(i, function (r, i) {
          n = c + i * (s + o) - f + o, "middle" === a && (n += f - o - (f - o) / 2), "top" === a && (n += f - o), e ? t.fillText(r, u, n) : t.strokeText(r, u, n);
        });
      },
      measureText: function measureText() {
        var t,
            e = this._attrs,
            n = e.text,
            i = e.font,
            a = e.textArr,
            o = 0;

        if (!r.isNil(n)) {
          var s = document.createElement("canvas").getContext("2d");
          return s.save(), s.font = i, a ? r.each(a, function (e) {
            t = s.measureText(e).width, o < t && (o = t), s.restore();
          }) : (o = s.measureText(n).width, s.restore()), o;
        }
      }
    }), t.exports = a;
  }, function (t, e, n) {
    var r = n(19),
        i = n(593).parseRadius,
        a = n(58),
        o = function t(e) {
      t.superclass.constructor.call(this, e);
    };

    o.ATTRS = {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      radius: 0,
      lineWidth: 1
    }, r.extend(o, a), r.augment(o, {
      canFill: !0,
      canStroke: !0,
      type: "rect",
      getDefaultAttrs: function getDefaultAttrs() {
        return {
          lineWidth: 1,
          radius: 0
        };
      },
      calculateBox: function calculateBox() {
        var t = this._attrs,
            e = t.x,
            n = t.y,
            r = t.width,
            i = t.height,
            a = this.getHitLineWidth() / 2;
        return {
          minX: e - a,
          minY: n - a,
          maxX: e + r + a,
          maxY: n + i + a
        };
      },
      createPath: function createPath(t) {
        var e = this._attrs,
            n = e.x,
            r = e.y,
            a = e.width,
            o = e.height,
            s = e.radius;
        if ((t = t || this.get("context")).beginPath(), 0 === s) t.rect(n, r, a, o);else {
          var u = i(s);
          t.moveTo(n + u.r1, r), t.lineTo(n + a - u.r2, r), 0 !== u.r2 && t.arc(n + a - u.r2, r + u.r2, u.r2, -Math.PI / 2, 0), t.lineTo(n + a, r + o - u.r3), 0 !== u.r3 && t.arc(n + a - u.r3, r + o - u.r3, u.r3, 0, Math.PI / 2), t.lineTo(n + u.r4, r + o), 0 !== u.r4 && t.arc(n + u.r4, r + o - u.r4, u.r4, Math.PI / 2, Math.PI), t.lineTo(n, r + u.r1), 0 !== u.r1 && t.arc(n + u.r1, r + u.r1, u.r1, Math.PI, 1.5 * Math.PI), t.closePath();
        }
      }
    }), t.exports = o;
  }, function (t, e, n) {
    var r = n(19),
        i = n(58),
        a = n(601),
        o = n(603),
        s = function t(e) {
      t.superclass.constructor.call(this, e);
    };

    s.ATTRS = {
      points: null,
      lineWidth: 1,
      startArrow: !1,
      endArrow: !1,
      tCache: null
    }, r.extend(s, i), r.augment(s, {
      canStroke: !0,
      type: "polyline",
      tCache: null,
      getDefaultAttrs: function getDefaultAttrs() {
        return {
          lineWidth: 1,
          startArrow: !1,
          endArrow: !1
        };
      },
      calculateBox: function calculateBox() {
        var t = this._attrs,
            e = this.getHitLineWidth(),
            n = t.points;
        if (!n || 0 === n.length) return null;
        var i = 1 / 0,
            a = 1 / 0,
            o = -1 / 0,
            s = -1 / 0;
        r.each(n, function (t) {
          var e = t[0],
              n = t[1];
          e < i && (i = e), e > o && (o = e), n < a && (a = n), n > s && (s = n);
        });
        var u = e / 2;
        return {
          minX: i - u,
          minY: a - u,
          maxX: o + u,
          maxY: s + u
        };
      },
      _setTcache: function _setTcache() {
        var t,
            e,
            n = this._attrs.points,
            i = 0,
            a = 0,
            s = [];
        n && 0 !== n.length && (r.each(n, function (t, e) {
          n[e + 1] && (i += o.len(t[0], t[1], n[e + 1][0], n[e + 1][1]));
        }), i <= 0 || (r.each(n, function (r, u) {
          n[u + 1] && ((t = [])[0] = a / i, e = o.len(r[0], r[1], n[u + 1][0], n[u + 1][1]), a += e, t[1] = a / i, s.push(t));
        }), this.tCache = s));
      },
      createPath: function createPath(t) {
        var e,
            n,
            r = this._attrs.points;

        if (!(r.length < 2)) {
          for ((t = t || this.get("context")).beginPath(), t.moveTo(r[0][0], r[0][1]), n = 1, e = r.length - 1; n < e; n++) {
            t.lineTo(r[n][0], r[n][1]);
          }

          t.lineTo(r[e][0], r[e][1]);
        }
      },
      getStartTangent: function getStartTangent() {
        var t = this.__attrs.points,
            e = [];
        return e.push([t[1][0], t[1][1]]), e.push([t[0][0], t[0][1]]), e;
      },
      getEndTangent: function getEndTangent() {
        var t = this.__attrs.points,
            e = t.length - 1,
            n = [];
        return n.push([t[e - 1][0], t[e - 1][1]]), n.push([t[e][0], t[e][1]]), n;
      },
      afterPath: function afterPath(t) {
        var e = this._attrs,
            n = e.points,
            r = n.length - 1;
        t = t || this.get("context"), e.startArrow && a.addStartArrow(t, e, n[1][0], n[1][1], n[0][0], n[0][1]), e.endArrow && a.addEndArrow(t, e, n[r - 1][0], n[r - 1][1], n[r][0], n[r][1]);
      },
      getPoint: function getPoint(t) {
        var e,
            n,
            i = this._attrs.points,
            a = this.tCache;
        return a || (this._setTcache(), a = this.tCache), r.each(a, function (r, i) {
          t >= r[0] && t <= r[1] && (e = (t - r[0]) / (r[1] - r[0]), n = i);
        }), {
          x: o.at(i[n][0], i[n + 1][0], e),
          y: o.at(i[n][1], i[n + 1][1], e)
        };
      }
    }), t.exports = s;
  }, function (t, e, n) {
    var r = n(19),
        i = n(58),
        a = function t(e) {
      t.superclass.constructor.call(this, e);
    };

    a.ATTRS = {
      points: null,
      lineWidth: 1
    }, r.extend(a, i), r.augment(a, {
      canFill: !0,
      canStroke: !0,
      type: "polygon",
      getDefaultAttrs: function getDefaultAttrs() {
        return {
          lineWidth: 1
        };
      },
      calculateBox: function calculateBox() {
        var t = this._attrs.points,
            e = this.getHitLineWidth();
        if (!t || 0 === t.length) return null;
        var n = 1 / 0,
            i = 1 / 0,
            a = -1 / 0,
            o = -1 / 0;
        r.each(t, function (t) {
          var e = t[0],
              r = t[1];
          e < n && (n = e), e > a && (a = e), r < i && (i = r), r > o && (o = r);
        });
        var s = e / 2;
        return {
          minX: n - s,
          minY: i - s,
          maxX: a + s,
          maxY: o + s
        };
      },
      createPath: function createPath(t) {
        var e = this._attrs.points;
        e.length < 2 || ((t = t || this.get("context")).beginPath(), r.each(e, function (e, n) {
          0 === n ? t.moveTo(e[0], e[1]) : t.lineTo(e[0], e[1]);
        }), t.closePath());
      }
    }), t.exports = a;
  }, function (t, e, n) {
    var r = n(19),
        i = n(58),
        a = n(600),
        o = n(593),
        s = n(601),
        u = n(610),
        c = n(612),
        h = function t(e) {
      t.superclass.constructor.call(this, e);
    };

    h.ATTRS = {
      path: null,
      lineWidth: 1,
      startArrow: !1,
      endArrow: !1
    }, r.extend(h, i), r.augment(h, {
      canFill: !0,
      canStroke: !0,
      type: "path",
      getDefaultAttrs: function getDefaultAttrs() {
        return {
          lineWidth: 1,
          startArrow: !1,
          endArrow: !1
        };
      },
      _afterSetAttrPath: function _afterSetAttrPath(t) {
        if (r.isNil(t)) return this.setSilent("segments", null), void this.setSilent("box", void 0);
        var e,
            n = o.parsePath(t),
            i = [];

        if (r.isArray(n) && 0 !== n.length && ("M" === n[0][0] || "m" === n[0][0])) {
          for (var s = n.length, u = 0; u < n.length; u++) {
            var c = n[u];
            e = new a(c, e, u === s - 1), i.push(e);
          }

          this.setSilent("segments", i), this.setSilent("tCache", null), this.setSilent("box", null);
        }
      },
      calculateBox: function calculateBox() {
        var t = this.get("segments");
        if (!t) return null;
        var e = this.getHitLineWidth(),
            n = 1 / 0,
            i = -1 / 0,
            a = 1 / 0,
            o = -1 / 0;
        return r.each(t, function (t) {
          t.getBBox(e);
          var r = t.box;
          r && (r.minX < n && (n = r.minX), r.maxX > i && (i = r.maxX), r.minY < a && (a = r.minY), r.maxY > o && (o = r.maxY));
        }), n === 1 / 0 || a === 1 / 0 ? {
          minX: 0,
          minY: 0,
          maxX: 0,
          maxY: 0
        } : {
          minX: n,
          minY: a,
          maxX: i,
          maxY: o
        };
      },
      _setTcache: function _setTcache() {
        var t,
            e,
            n,
            i,
            a = 0,
            o = 0,
            s = [],
            u = this._cfg.curve;
        u && (r.each(u, function (t, e) {
          n = u[e + 1], i = t.length, n && (a += c.len(t[i - 2], t[i - 1], n[1], n[2], n[3], n[4], n[5], n[6]));
        }), r.each(u, function (r, h) {
          n = u[h + 1], i = r.length, n && ((t = [])[0] = o / a, e = c.len(r[i - 2], r[i - 1], n[1], n[2], n[3], n[4], n[5], n[6]), o += e, t[1] = o / a, s.push(t));
        }), this._cfg.tCache = s);
      },
      _calculateCurve: function _calculateCurve() {
        var t = this._attrs.path;
        this._cfg.curve = u.pathTocurve(t);
      },
      getStartTangent: function getStartTangent() {
        var t,
            e,
            n,
            i,
            a = this.get("segments");
        if (a.length > 1) if (t = a[0].endPoint, e = a[1].endPoint, n = a[1].startTangent, i = [], r.isFunction(n)) {
          var o = n();
          i.push([t.x - o[0], t.y - o[1]]), i.push([t.x, t.y]);
        } else i.push([e.x, e.y]), i.push([t.x, t.y]);
        return i;
      },
      getEndTangent: function getEndTangent() {
        var t,
            e,
            n,
            i,
            a = this.get("segments"),
            o = a.length;
        if (o > 1) if (t = a[o - 2].endPoint, e = a[o - 1].endPoint, n = a[o - 1].endTangent, i = [], r.isFunction(n)) {
          var s = n();
          i.push([e.x - s[0], e.y - s[1]]), i.push([e.x, e.y]);
        } else i.push([t.x, t.y]), i.push([e.x, e.y]);
        return i;
      },
      getPoint: function getPoint(t) {
        var e,
            n,
            i = this._cfg.tCache;
        i || (this._calculateCurve(), this._setTcache(), i = this._cfg.tCache);
        var a = this._cfg.curve;
        if (!i) return a ? {
          x: a[0][1],
          y: a[0][2]
        } : null;
        r.each(i, function (r, i) {
          t >= r[0] && t <= r[1] && (e = (t - r[0]) / (r[1] - r[0]), n = i);
        });
        var o = a[n];
        if (r.isNil(o) || r.isNil(n)) return null;
        var s = o.length,
            u = a[n + 1];
        return {
          x: c.at(o[s - 2], u[1], u[3], u[5], 1 - e),
          y: c.at(o[s - 1], u[2], u[4], u[6], 1 - e)
        };
      },
      createPath: function createPath(t) {
        var e = this.get("segments");

        if (r.isArray(e)) {
          (t = t || this.get("context")).beginPath();

          for (var n = e.length, i = 0; i < n; i++) {
            e[i].draw(t);
          }
        }
      },
      afterPath: function afterPath(t) {
        var e = this._attrs,
            n = this.get("segments"),
            i = e.path;

        if (t = t || this.get("context"), r.isArray(n) && 1 !== n.length && (e.startArrow || e.endArrow) && "z" !== i[i.length - 1] && "Z" !== i[i.length - 1] && !e.fill) {
          var a = this.getStartTangent();
          s.addStartArrow(t, e, a[0][0], a[0][1], a[1][0], a[1][1]);
          var o = this.getEndTangent();
          s.addEndArrow(t, e, o[0][0], o[0][1], o[1][0], o[1][1]);
        }
      }
    }), t.exports = h;
  }, function (t, e, n) {
    var r = n(19),
        i = n(58),
        a = n(601),
        o = n(603),
        s = function t(e) {
      t.superclass.constructor.call(this, e);
    };

    s.ATTRS = {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0,
      lineWidth: 1,
      startArrow: !1,
      endArrow: !1
    }, r.extend(s, i), r.augment(s, {
      canStroke: !0,
      type: "line",
      getDefaultAttrs: function getDefaultAttrs() {
        return {
          lineWidth: 1,
          startArrow: !1,
          endArrow: !1
        };
      },
      calculateBox: function calculateBox() {
        var t = this._attrs,
            e = t.x1,
            n = t.y1,
            r = t.x2,
            i = t.y2,
            a = this.getHitLineWidth();
        return o.box(e, n, r, i, a);
      },
      createPath: function createPath(t) {
        var e = this._attrs,
            n = e.x1,
            r = e.y1,
            i = e.x2,
            a = e.y2;
        (t = t || self.get("context")).beginPath(), t.moveTo(n, r), t.lineTo(i, a);
      },
      afterPath: function afterPath(t) {
        var e = this._attrs,
            n = e.x1,
            r = e.y1,
            i = e.x2,
            o = e.y2;
        t = t || this.get("context"), e.startArrow && a.addStartArrow(t, e, i, o, n, r), e.endArrow && a.addEndArrow(t, e, n, r, i, o);
      },
      getPoint: function getPoint(t) {
        var e = this._attrs;
        return {
          x: o.at(e.x1, e.x2, t),
          y: o.at(e.y1, e.y2, t)
        };
      }
    }), t.exports = s;
  }, function (t, e, n) {
    var r = n(19),
        i = n(58),
        a = function t(e) {
      t.superclass.constructor.call(this, e);
    };

    a.ATTRS = {
      x: 0,
      y: 0,
      img: void 0,
      width: 0,
      height: 0,
      sx: null,
      sy: null,
      swidth: null,
      sheight: null
    }, r.extend(a, i), r.augment(a, {
      type: "image",
      isHitBox: function isHitBox() {
        return !1;
      },
      calculateBox: function calculateBox() {
        var t = this._attrs;
        this._cfg.attrs && this._cfg.attrs.img === t.img || this._setAttrImg();
        var e = t.x,
            n = t.y;
        return {
          minX: e,
          minY: n,
          maxX: e + t.width,
          maxY: n + t.height
        };
      },
      _beforeSetLoading: function _beforeSetLoading(t) {
        var e = this.get("canvas");
        return !1 === t && !0 === this.get("toDraw") && (this._cfg.loading = !1, e.draw()), t;
      },
      _setAttrImg: function _setAttrImg() {
        var t = this,
            e = t._attrs,
            n = e.img;
        if (!r.isString(n)) return n instanceof Image ? (e.width || t.attr("width", n.width), e.height || t.attr("height", n.height), n) : n instanceof HTMLElement && r.isString(n.nodeName) && "CANVAS" === n.nodeName.toUpperCase() ? (e.width || t.attr("width", Number(n.getAttribute("width"))), e.height || t.attr("height", Number(n.getAttribute("height"))), n) : n instanceof ImageData ? (e.width || t.attr("width", n.width), e.height || t.attr("height", n.height), n) : null;
        var i = new Image();
        i.onload = function () {
          if (t.get("destroyed")) return !1;
          t.attr("imgSrc", n), t.attr("img", i);
          var e = t.get("callback");
          e && e.call(t), t.set("loading", !1);
        }, i.src = n, i.crossOrigin = "Anonymous", t.set("loading", !0);
      },
      drawInner: function drawInner(t) {
        this._cfg.hasUpdate && this._setAttrImg(), this.get("loading") ? this.set("toDraw", !0) : (this._drawImage(t), this._cfg.hasUpdate = !1);
      },
      _drawImage: function _drawImage(t) {
        var e = this._attrs,
            n = e.x,
            i = e.y,
            a = e.img,
            o = e.width,
            s = e.height,
            u = e.sx,
            c = e.sy,
            h = e.swidth,
            f = e.sheight;
        this.set("toDraw", !1);
        var l = a;

        if (l instanceof ImageData && ((l = new Image()).src = a), l instanceof Image || l instanceof HTMLElement && r.isString(l.nodeName) && "CANVAS" === l.nodeName.toUpperCase()) {
          if (r.isNil(u) || r.isNil(c) || r.isNil(h) || r.isNil(f)) return void t.drawImage(l, n, i, o, s);
          if (!(r.isNil(u) || r.isNil(c) || r.isNil(h) || r.isNil(f))) return void t.drawImage(l, u, c, h, f, n, i, o, s);
        }
      }
    }), t.exports = a;
  }, function (t, e, n) {
    var r = n(19),
        i = n(58),
        a = n(602),
        o = function t(e) {
      t.superclass.constructor.call(this, e);
    };

    o.ATTRS = {
      x: 0,
      y: 0,
      rs: 0,
      re: 0,
      startAngle: 0,
      endAngle: 0,
      clockwise: !1,
      lineWidth: 1
    }, r.extend(o, i), r.augment(o, {
      canFill: !0,
      canStroke: !0,
      type: "fan",
      getDefaultAttrs: function getDefaultAttrs() {
        return {
          clockwise: !1,
          lineWidth: 1,
          rs: 0,
          re: 0
        };
      },
      calculateBox: function calculateBox() {
        var t = this._attrs,
            e = t.x,
            n = t.y,
            r = t.rs,
            i = t.re,
            o = t.startAngle,
            s = t.endAngle,
            u = t.clockwise,
            c = this.getHitLineWidth(),
            h = a.box(e, n, r, o, s, u),
            f = a.box(e, n, i, o, s, u),
            l = c / 2;
        return {
          minX: Math.min(h.minX, f.minX) - l,
          minY: Math.min(h.minY, f.minY) - l,
          maxX: Math.max(h.maxX, f.maxX) + l,
          maxY: Math.max(h.maxY, f.maxY) + l
        };
      },
      createPath: function createPath(t) {
        var e = this._attrs,
            n = e.x,
            r = e.y,
            i = e.rs,
            a = e.re,
            o = e.startAngle,
            s = e.endAngle,
            u = e.clockwise,
            c = {
          x: Math.cos(o) * i + n,
          y: Math.sin(o) * i + r
        },
            h = {
          x: Math.cos(o) * a + n,
          y: Math.sin(o) * a + r
        },
            f = {
          x: Math.cos(s) * i + n,
          y: Math.sin(s) * i + r
        };
        (t = t || self.get("context")).beginPath(), t.moveTo(c.x, c.y), t.lineTo(h.x, h.y), t.arc(n, r, a, o, s, u), t.lineTo(f.x, f.y), t.arc(n, r, i, s, o, !u), t.closePath();
      }
    }), t.exports = o;
  }, function (t, e, n) {
    var r = n(19),
        i = n(58),
        a = function t(e) {
      t.superclass.constructor.call(this, e);
    };

    a.ATTRS = {
      x: 0,
      y: 0,
      rx: 1,
      ry: 1,
      lineWidth: 1
    }, r.extend(a, i), r.augment(a, {
      canFill: !0,
      canStroke: !0,
      type: "ellipse",
      getDefaultAttrs: function getDefaultAttrs() {
        return {
          lineWidth: 1
        };
      },
      calculateBox: function calculateBox() {
        var t = this._attrs,
            e = t.x,
            n = t.y,
            r = t.rx,
            i = t.ry,
            a = this.getHitLineWidth(),
            o = r + a / 2,
            s = i + a / 2;
        return {
          minX: e - o,
          minY: n - s,
          maxX: e + o,
          maxY: n + s
        };
      },
      createPath: function createPath(t) {
        var e = this._attrs,
            n = e.x,
            i = e.y,
            a = e.rx,
            o = e.ry;
        t = t || self.get("context");
        var s = a > o ? a : o,
            u = a > o ? 1 : a / o,
            c = a > o ? o / a : 1,
            h = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        r.mat3.scale(h, h, [u, c]), r.mat3.translate(h, h, [n, i]), t.beginPath(), t.save(), t.transform(h[0], h[1], h[3], h[4], h[6], h[7]), t.arc(0, 0, s, 0, 2 * Math.PI), t.restore(), t.closePath();
      }
    }), t.exports = a;
  }, function (t, e, n) {
    var r = n(19),
        i = n(58),
        a = function t(e) {
      t.superclass.constructor.call(this, e);
    };

    r.extend(a, i), r.augment(a, {
      canFill: !0,
      canStroke: !0,
      type: "dom",
      calculateBox: function calculateBox() {
        var t = this._attrs,
            e = t.x,
            n = t.y,
            r = t.width,
            i = t.height,
            a = this.getHitLineWidth() / 2;
        return {
          minX: e - a,
          minY: n - a,
          maxX: e + r + a,
          maxY: n + i + a
        };
      }
    }), t.exports = a;
  }, function (t, e, n) {
    var r = n(19),
        i = n(58),
        a = function t(e) {
      t.superclass.constructor.call(this, e);
    };

    a.ATTRS = {
      x: 0,
      y: 0,
      r: 0,
      lineWidth: 1
    }, r.extend(a, i), r.augment(a, {
      canFill: !0,
      canStroke: !0,
      type: "circle",
      getDefaultAttrs: function getDefaultAttrs() {
        return {
          lineWidth: 1
        };
      },
      calculateBox: function calculateBox() {
        var t = this._attrs,
            e = t.x,
            n = t.y,
            r = t.r,
            i = this.getHitLineWidth() / 2 + r;
        return {
          minX: e - i,
          minY: n - i,
          maxX: e + i,
          maxY: n + i
        };
      },
      createPath: function createPath(t) {
        var e = this._attrs,
            n = e.x,
            r = e.y,
            i = e.r;
        t.beginPath(), t.arc(n, r, i, 0, 2 * Math.PI, !1), t.closePath();
      }
    }), t.exports = a;
  }, function (t, e, n) {
    var r = n(19),
        i = n(58),
        a = n(602),
        o = n(601);

    function s(t, e, n) {
      return t + e * Math.cos(n);
    }

    function u(t, e, n) {
      return t + e * Math.sin(n);
    }

    var c = function t(e) {
      t.superclass.constructor.call(this, e);
    };

    c.ATTRS = {
      x: 0,
      y: 0,
      r: 0,
      startAngle: 0,
      endAngle: 0,
      clockwise: !1,
      lineWidth: 1,
      startArrow: !1,
      endArrow: !1
    }, r.extend(c, i), r.augment(c, {
      canStroke: !0,
      type: "arc",
      getDefaultAttrs: function getDefaultAttrs() {
        return {
          x: 0,
          y: 0,
          r: 0,
          startAngle: 0,
          endAngle: 0,
          clockwise: !1,
          lineWidth: 1,
          startArrow: !1,
          endArrow: !1
        };
      },
      calculateBox: function calculateBox() {
        var t = this._attrs,
            e = t.x,
            n = t.y,
            r = t.r,
            i = t.startAngle,
            o = t.endAngle,
            s = t.clockwise,
            u = this.getHitLineWidth() / 2,
            c = a.box(e, n, r, i, o, s);
        return c.minX -= u, c.minY -= u, c.maxX += u, c.maxY += u, c;
      },
      getStartTangent: function getStartTangent() {
        var t = this._attrs,
            e = t.x,
            n = t.y,
            r = t.startAngle,
            i = t.r,
            a = t.clockwise,
            o = Math.PI / 180;
        a && (o *= -1);
        var c = [],
            h = s(e, i, r + o),
            f = u(n, i, r + o),
            l = s(e, i, r),
            p = u(n, i, r);
        return c.push([h, f]), c.push([l, p]), c;
      },
      getEndTangent: function getEndTangent() {
        var t = this._attrs,
            e = t.x,
            n = t.y,
            r = t.endAngle,
            i = t.r,
            a = t.clockwise,
            o = Math.PI / 180,
            c = [];
        a && (o *= -1);
        var h = s(e, i, r + o),
            f = u(n, i, r + o),
            l = s(e, i, r),
            p = u(n, i, r);
        return c.push([l, p]), c.push([h, f]), c;
      },
      createPath: function createPath(t) {
        var e = this._attrs,
            n = e.x,
            r = e.y,
            i = e.r,
            a = e.startAngle,
            o = e.endAngle,
            s = e.clockwise;
        (t = t || self.get("context")).beginPath(), t.arc(n, r, i, a, o, s);
      },
      afterPath: function afterPath(t) {
        var e = this._attrs;

        if (t = t || this.get("context"), e.startArrow) {
          var n = this.getStartTangent();
          o.addStartArrow(t, e, n[0][0], n[0][1], n[1][0], n[1][1]);
        }

        if (e.endArrow) {
          var r = this.getEndTangent();
          o.addEndArrow(t, e, r[0][0], r[0][1], r[1][0], r[1][1]);
        }
      }
    }), t.exports = c;
  }, function (t, e) {
    t.exports = {
      xAt: function xAt(t, e, n, r, i) {
        return e * Math.cos(t) * Math.cos(i) - n * Math.sin(t) * Math.sin(i) + r;
      },
      yAt: function yAt(t, e, n, r, i) {
        return e * Math.sin(t) * Math.cos(i) + n * Math.cos(t) * Math.sin(i) + r;
      },
      xExtrema: function xExtrema(t, e, n) {
        return Math.atan(-n / e * Math.tan(t));
      },
      yExtrema: function yExtrema(t, e, n) {
        return Math.atan(n / (e * Math.tan(t)));
      }
    };
  }, function (t, e, n) {
    var r = n(19),
        i = r.vec2;

    function a(t, e, n, r) {
      var i = 1 - r;
      return i * (i * t + 2 * r * e) + r * r * n;
    }

    function o(t, e, n, r, o, s, u, c, h) {
      var f,
          l,
          p,
          d,
          g,
          v,
          m,
          x = .005,
          y = 1 / 0,
          b = [u, c];

      for (g = 0; g < 1; g += .05) {
        p = [a(t, n, o, g), a(e, r, s, g)], (l = i.squaredDistance(b, p)) < y && (f = g, y = l);
      }

      for (y = 1 / 0, m = 0; m < 32 && !(x < 1e-4); m++) {
        var M = f - x,
            w = f + x;
        p = [a(t, n, o, M), a(e, r, s, M)], l = i.squaredDistance(b, p), M >= 0 && l < y ? (f = M, y = l) : (d = [a(t, n, o, w), a(e, r, s, w)], v = i.squaredDistance(b, d), w <= 1 && v < y ? (f = w, y = v) : x *= .5);
      }

      return h && (h.x = a(t, n, o, f), h.y = a(e, r, s, f)), Math.sqrt(y);
    }

    t.exports = {
      at: a,
      projectPoint: function projectPoint(t, e, n, r, i, a, s, u) {
        var c = {};
        return o(t, e, n, r, i, a, s, u, c), c;
      },
      pointDistance: o,
      extrema: function extrema(t, e, n) {
        var i = t + n - 2 * e;
        if (r.isNumberEqual(i, 0)) return [.5];
        var a = (t - e) / i;
        return a <= 1 && a >= 0 ? [a] : [];
      }
    };
  }, function (t, e, n) {
    var r = n(19),
        i = n(746),
        a = n(745),
        o = n(744),
        s = n(116),
        u = function u(t) {
      this._cfg = {
        zIndex: 0,
        capture: !0,
        visible: !0,
        destroyed: !1
      }, r.assign(this._cfg, this.getDefaultCfg(), t), this.initAttrs(this._cfg.attrs), this._cfg.attrs = {}, this.initTransform(), this.init();
    };

    u.CFG = {
      id: null,
      zIndex: 0,
      canvas: null,
      parent: null,
      capture: !0,
      context: null,
      visible: !0,
      destroyed: !1
    }, r.augment(u, i, a, s, o, {
      init: function init() {
        this.setSilent("animable", !0), this.setSilent("animating", !1);
      },
      getParent: function getParent() {
        return this._cfg.parent;
      },
      getDefaultCfg: function getDefaultCfg() {
        return {};
      },
      set: function set(t, e) {
        return "zIndex" === t && this._beforeSetZIndex && this._beforeSetZIndex(e), "loading" === t && this._beforeSetLoading && this._beforeSetLoading(e), this._cfg[t] = e, this;
      },
      setSilent: function setSilent(t, e) {
        this._cfg[t] = e;
      },
      get: function get(t) {
        return this._cfg[t];
      },
      show: function show() {
        return this._cfg.visible = !0, this;
      },
      hide: function hide() {
        return this._cfg.visible = !1, this;
      },
      remove: function remove(t, e) {
        var n = this._cfg,
            i = n.parent,
            a = n.el;
        return i && r.remove(i.get("children"), this), a && (e ? i && i._cfg.tobeRemoved.push(a) : a.parentNode.removeChild(a)), (t || void 0 === t) && this.destroy(), this;
      },
      destroy: function destroy() {
        this.get("destroyed") || (this._attrs = null, this.removeEvent(), this._cfg = {
          destroyed: !0
        });
      },
      toFront: function toFront() {
        var t = this._cfg,
            e = t.parent;

        if (e) {
          var n = e._cfg.children,
              r = t.el,
              i = n.indexOf(this);
          n.splice(i, 1), n.push(this), r && (r.parentNode.removeChild(r), t.el = null);
        }
      },
      toBack: function toBack() {
        var t = this._cfg,
            e = t.parent;

        if (e) {
          var n = e._cfg.children,
              r = t.el,
              i = n.indexOf(this);

          if (n.splice(i, 1), n.unshift(this), r) {
            var a = r.parentNode;
            a.removeChild(r), a.insertBefore(r, a.firstChild);
          }
        }
      },
      _beforeSetZIndex: function _beforeSetZIndex(t) {
        var e = this._cfg.parent;
        this._cfg.zIndex = t, r.isNil(e) || e.sort();
        var n = this._cfg.el;

        if (n) {
          var i = e._cfg.children,
              a = i.indexOf(this),
              o = n.parentNode;
          o.removeChild(n), a === i.length - 1 ? o.appendChild(n) : o.insertBefore(n, o.childNodes[a]);
        }

        return t;
      },
      _setAttrs: function _setAttrs(t) {
        return this.attr(t), t;
      },
      setZIndex: function setZIndex(t) {
        return this._cfg.zIndex = t, this._beforeSetZIndex(t);
      },
      clone: function clone() {
        return r.clone(this);
      },
      getBBox: function getBBox() {}
    }), t.exports = u;
  }, function (t, e, n) {
    var r = n(19),
        i = n(641),
        a = n(743),
        o = {},
        s = "_INDEX";

    function u(t, e, n) {
      for (var r, i = t.length - 1; i >= 0; i--) {
        var a = t[i];
        if (a._cfg.visible && a._cfg.capture && (a.isGroup ? r = a.getShape(e, n) : a.isHit(e, n) && (r = a)), r) break;
      }

      return r;
    }

    var c = function t(e) {
      t.superclass.constructor.call(this, e), this.set("children", []), this.set("tobeRemoved", []), this._beforeRenderUI(), this._renderUI(), this._bindUI();
    };

    r.extend(c, i), r.augment(c, {
      isGroup: !0,
      type: "group",
      canFill: !0,
      canStroke: !0,
      getDefaultCfg: function getDefaultCfg() {
        return function t(e) {
          if (!e._cfg && e !== c) {
            var n = e.superclass.constructor;
            n && !n._cfg && t(n), e._cfg = {}, r.merge(e._cfg, n._cfg), r.merge(e._cfg, e.CFG);
          }
        }(this.constructor), r.merge({}, this.constructor._cfg);
      },
      _beforeRenderUI: function _beforeRenderUI() {},
      _renderUI: function _renderUI() {},
      _bindUI: function _bindUI() {},
      addShape: function addShape(t, e) {
        var n = this.get("canvas");
        e = e || {};
        var i = o[t];

        if (i || (i = r.upperFirst(t), o[t] = i), e.attrs && n) {
          var s = e.attrs;

          if ("text" === t) {
            var u = n.get("fontFamily");
            u && (s.fontFamily = s.fontFamily ? s.fontFamily : u);
          }
        }

        e.canvas = n, e.type = t;
        var c = new a[i](e);
        return this.add(c), c;
      },
      addGroup: function addGroup(t, e) {
        var n,
            i = this.get("canvas");
        if (e = r.merge({}, e), r.isFunction(t)) e ? (e.canvas = i, e.parent = this, n = new t(e)) : n = new t({
          canvas: i,
          parent: this
        }), this.add(n);else if (r.isObject(t)) t.canvas = i, n = new c(t), this.add(n);else {
          if (void 0 !== t) return !1;
          n = new c(), this.add(n);
        }
        return n;
      },
      renderBack: function renderBack(t, e) {
        var n = this.get("backShape"),
            i = this.getBBox();
        return r.merge(e, {
          x: i.minX - t[3],
          y: i.minY - t[0],
          width: i.width + t[1] + t[3],
          height: i.height + t[0] + t[2]
        }), n ? n.attr(e) : n = this.addShape("rect", {
          zIndex: -1,
          attrs: e
        }), this.set("backShape", n), this.sort(), n;
      },
      removeChild: function removeChild(t, e) {
        if (arguments.length >= 2) this.contain(t) && t.remove(e);else {
          if (1 === arguments.length) {
            if (!r.isBoolean(t)) return this.contain(t) && t.remove(!0), this;
            e = t;
          }

          0 === arguments.length && (e = !0), c.superclass.remove.call(this, e);
        }
        return this;
      },
      add: function add(t) {
        var e = this,
            n = e.get("children");
        if (r.isArray(t)) r.each(t, function (t) {
          var n = t.get("parent");
          n && n.removeChild(t, !1), e._setCfgProperty(t);
        }), e._cfg.children = n.concat(t);else {
          var i = t,
              a = i.get("parent");
          a && a.removeChild(i, !1), e._setCfgProperty(i), n.push(i);
        }
        return e;
      },
      _setCfgProperty: function _setCfgProperty(t) {
        var e = this._cfg;
        t.set("parent", this), t.set("canvas", e.canvas), e.timeline && t.set("timeline", e.timeline);
      },
      contain: function contain(t) {
        return this.get("children").indexOf(t) > -1;
      },
      getChildByIndex: function getChildByIndex(t) {
        return this.get("children")[t];
      },
      getFirst: function getFirst() {
        return this.getChildByIndex(0);
      },
      getLast: function getLast() {
        var t = this.get("children").length - 1;
        return this.getChildByIndex(t);
      },
      getBBox: function getBBox() {
        var t = 1 / 0,
            e = -1 / 0,
            n = 1 / 0,
            i = -1 / 0,
            a = this.get("children");
        a.length > 0 ? r.each(a, function (r) {
          if (r.get("visible")) {
            if (r.isGroup && 0 === r.get("children").length) return;
            var a = r.getBBox();
            if (!a) return !0;
            var o = [a.minX, a.minY, 1],
                s = [a.minX, a.maxY, 1],
                u = [a.maxX, a.minY, 1],
                c = [a.maxX, a.maxY, 1];
            r.apply(o), r.apply(s), r.apply(u), r.apply(c);
            var h = Math.min(o[0], s[0], u[0], c[0]),
                f = Math.max(o[0], s[0], u[0], c[0]),
                l = Math.min(o[1], s[1], u[1], c[1]),
                p = Math.max(o[1], s[1], u[1], c[1]);
            h < t && (t = h), f > e && (e = f), l < n && (n = l), p > i && (i = p);
          }
        }) : (t = 0, e = 0, n = 0, i = 0);
        var o = {
          minX: t,
          minY: n,
          maxX: e,
          maxY: i
        };
        return o.x = o.minX, o.y = o.minY, o.width = o.maxX - o.minX, o.height = o.maxY - o.minY, o;
      },
      getCount: function getCount() {
        return this.get("children").length;
      },
      sort: function sort() {
        var t = this.get("children");
        return r.each(t, function (t, e) {
          return t[s] = e, t;
        }), t.sort(function (t) {
          return function (e, n) {
            var r = t(e, n);
            return 0 === r ? e[s] - n[s] : r;
          };
        }(function (t, e) {
          return t.get("zIndex") - e.get("zIndex");
        })), this;
      },
      findById: function findById(t) {
        return this.find(function (e) {
          return e.get("id") === t;
        });
      },
      find: function find(t) {
        if (r.isString(t)) return this.findById(t);
        var e = this.get("children"),
            n = null;
        return r.each(e, function (e) {
          if (t(e) ? n = e : e.find && (n = e.find(t)), n) return !1;
        }), n;
      },
      findAll: function findAll(t) {
        var e = this.get("children"),
            n = [],
            i = [];
        return r.each(e, function (e) {
          t(e) && n.push(e), e.findAllBy && (i = e.findAllBy(t), n = n.concat(i));
        }), n;
      },
      findBy: function findBy(t) {
        var e = this.get("children"),
            n = null;
        return r.each(e, function (e) {
          if (t(e) ? n = e : e.findBy && (n = e.findBy(t)), n) return !1;
        }), n;
      },
      findAllBy: function findAllBy(t) {
        var e = this.get("children"),
            n = [],
            i = [];
        return r.each(e, function (e) {
          t(e) && n.push(e), e.findAllBy && (i = e.findAllBy(t), n = n.concat(i));
        }), n;
      },
      getShape: function getShape(t, e) {
        var n,
            r = this._attrs.clip,
            i = this._cfg.children;

        if (r) {
          var a = [t, e, 1];
          r.invert(a, this.get("canvas")), r.isPointInPath(a[0], a[1]) && (n = u(i, t, e));
        } else n = u(i, t, e);

        return n;
      },
      clearTotalMatrix: function clearTotalMatrix() {
        if (this.get("totalMatrix")) {
          this.setSilent("totalMatrix", null);

          for (var t = this._cfg.children, e = 0; e < t.length; e++) {
            t[e].clearTotalMatrix();
          }
        }
      },
      clear: function clear(t) {
        for (var e = this._cfg.children, n = e.length - 1; n >= 0; n--) {
          e[n].remove(!0, t);
        }

        return this._cfg.children = [], this;
      },
      destroy: function destroy() {
        this.get("destroyed") || (this.clear(), c.superclass.destroy.call(this));
      },
      clone: function clone() {
        var t = this._cfg.children,
            e = new c();
        return r.each(t, function (t) {
          e.add(t.clone());
        }), e;
      }
    }), t.exports = c;
  }, function (t, e, n) {
    var r = n(19),
        i = function i(t, e, n, r) {
      this.type = t, this.target = null, this.currentTarget = null, this.bubbles = n, this.cancelable = r, this.timeStamp = new Date().getTime(), this.defaultPrevented = !1, this.propagationStopped = !1, this.removed = !1, this.event = e;
    };

    r.augment(i, {
      preventDefault: function preventDefault() {
        this.defaultPrevented = this.cancelable && !0;
      },
      stopPropagation: function stopPropagation() {
        this.propagationStopped = !0;
      },
      remove: function remove() {
        this.remove = !0;
      },
      clone: function clone() {
        return r.clone(this);
      },
      toString: function toString() {
        return "[Event (type=" + this.type + ")]";
      }
    }), t.exports = i;
  }, function (t, e, n) {
    t.exports = {
      isFunction: n(84),
      isObject: n(621),
      isBoolean: n(653),
      isNil: n(237),
      isString: n(595),
      isArray: n(45),
      isNumber: n(236),
      isEmpty: n(647),
      uniqueId: n(646),
      clone: n(616),
      deepMix: n(615),
      assign: n(606),
      merge: n(615),
      upperFirst: n(655),
      each: n(46),
      isEqual: n(614),
      toArray: n(604),
      extend: n(650),
      augment: n(651),
      remove: n(676),
      isNumberEqual: n(673),
      toRadian: n(669),
      toDegree: n(671),
      mod: n(672),
      clamp: n(618),
      createDom: n(681),
      modifyCSS: n(680),
      requestAnimationFrame: n(679),
      getRatio: function getRatio() {
        return window.devicePixelRatio ? window.devicePixelRatio : 2;
      },
      mat3: n(617),
      vec2: n(668),
      vec3: n(667),
      transform: n(666)
    };
  }, function (t, e, n) {
    var r = n(16),
        i = n(253),
        a = n(251),
        o = "Expected a function",
        s = Math.max,
        u = Math.min;

    t.exports = function (t, e, n) {
      var c,
          h,
          f,
          l,
          p,
          d,
          g = 0,
          v = !1,
          m = !1,
          x = !0;
      if ("function" != typeof t) throw new TypeError(o);

      function y(e) {
        var n = c,
            r = h;
        return c = h = void 0, g = e, l = t.apply(r, n);
      }

      function b(t) {
        var n = t - d;
        return void 0 === d || n >= e || n < 0 || m && t - g >= f;
      }

      function M() {
        var t = i();
        if (b(t)) return w(t);
        p = setTimeout(M, function (t) {
          var n = e - (t - d);
          return m ? u(n, f - (t - g)) : n;
        }(t));
      }

      function w(t) {
        return p = void 0, x && c ? y(t) : (c = h = void 0, l);
      }

      function _() {
        var t = i(),
            n = b(t);

        if (c = arguments, h = this, d = t, n) {
          if (void 0 === p) return function (t) {
            return g = t, p = setTimeout(M, e), v ? y(t) : l;
          }(d);
          if (m) return p = setTimeout(M, e), y(d);
        }

        return void 0 === p && (p = setTimeout(M, e)), l;
      }

      return e = a(e) || 0, r(n) && (v = !!n.leading, f = (m = "maxWait" in n) ? s(a(n.maxWait) || 0, e) : f, x = "trailing" in n ? !!n.trailing : x), _.cancel = function () {
        void 0 !== p && clearTimeout(p), g = 0, c = d = h = p = void 0;
      }, _.flush = function () {
        return void 0 === p ? l : w(i());
      }, _;
    };
  }, function (t, e) {
    var n = function () {
      var t = {};
      return function (e) {
        return t[e = e || "g"] ? t[e] += 1 : t[e] = 1, e + t[e];
      };
    }();

    t.exports = n;
  }, function (t, e, n) {
    var r = n(237),
        i = n(118),
        a = n(654),
        o = n(652),
        s = Object.prototype.hasOwnProperty;

    t.exports = function (t) {
      if (r(t)) return !0;
      if (i(t)) return !t.length;
      var e = a(t);
      if ("Map" === e || "Set" === e) return !t.size;
      if (o(t)) return !Object.keys(t).length;

      for (var n in t) {
        if (s.call(t, n)) return !1;
      }

      return !0;
    };
  }, function (t, e, n) {
    var r = n(46),
        i = n(45),
        a = Object.prototype.hasOwnProperty;

    t.exports = function (t, e) {
      if (!e || !i(t)) return t;
      var n = {},
          o = null;
      return r(t, function (t) {
        o = e(t), a.call(n, o) ? n[o].push(t) : n[o] = [t];
      }), n;
    };
  }, function (t, e, n) {
    var r = n(84),
        i = n(45),
        a = n(648);

    t.exports = function (t, e) {
      if (!e) return {
        0: t
      };

      if (!r(e)) {
        var n = i(e) ? e : e.replace(/\s+/g, "").split("*");

        e = function e(t) {
          for (var e = "_", r = 0, i = n.length; r < i; r++) {
            e += t[n[r]] && t[n[r]].toString();
          }

          return e;
        };
      }

      return a(t, e);
    };
  }, function (t, e, n) {
    var r = n(84),
        i = n(606);

    t.exports = function (t, e, n, a) {
      r(e) || (n = e, e = t, t = function t() {});
      var o = Object.create ? function (t, e) {
        return Object.create(t, {
          constructor: {
            value: e
          }
        });
      } : function (t, e) {
        function n() {}

        n.prototype = t;
        var r = new n();
        return r.constructor = e, r;
      },
          s = o(e.prototype, t);
      return t.prototype = i(s, t.prototype), t.superclass = o(e.prototype, e), i(s, n), i(t, a), t;
    };
  }, function (t, e, n) {
    var r = n(84),
        i = n(604),
        a = n(606);

    t.exports = function (t) {
      for (var e = i(arguments), n = 1; n < e.length; n++) {
        var o = e[n];
        r(o) && (o = o.prototype), a(t.prototype, o);
      }
    };
  }, function (t, e) {
    var n = Object.prototype;

    t.exports = function (t) {
      var e = t && t.constructor;
      return t === ("function" == typeof e && e.prototype || n);
    };
  }, function (t, e, n) {
    var r = n(115);

    t.exports = function (t) {
      return r(t, "Boolean");
    };
  }, function (t, e) {
    var n = {}.toString;

    t.exports = function (t) {
      return n.call(t).replace(/^\[object /, "").replace(/\]$/, "");
    };
  }, function (t, e, n) {
    var r = n(594);

    t.exports = function (t) {
      var e = r(t);
      return e.charAt(0).toUpperCase() + e.substring(1);
    };
  }, function (t, e, n) {
    var r = n(594);

    t.exports = function (t) {
      return r(t).toUpperCase();
    };
  }, function (t, e, n) {
    var r = n(594);

    t.exports = function (t) {
      return r(t).toLowerCase();
    };
  }, function (t, e) {
    t.exports = function (t, e) {
      for (var n = [], r = 0, i = t.length; i - 2 * !e > r; r += 2) {
        var a = [{
          x: +t[r - 2],
          y: +t[r - 1]
        }, {
          x: +t[r],
          y: +t[r + 1]
        }, {
          x: +t[r + 2],
          y: +t[r + 3]
        }, {
          x: +t[r + 4],
          y: +t[r + 5]
        }];
        e ? r ? i - 4 === r ? a[3] = {
          x: +t[0],
          y: +t[1]
        } : i - 2 === r && (a[2] = {
          x: +t[0],
          y: +t[1]
        }, a[3] = {
          x: +t[2],
          y: +t[3]
        }) : a[0] = {
          x: +t[i - 2],
          y: +t[i - 1]
        } : i - 4 === r ? a[3] = a[2] : r || (a[0] = {
          x: +t[r],
          y: +t[r + 1]
        }), n.push(["C", (-a[0].x + 6 * a[1].x + a[2].x) / 6, (-a[0].y + 6 * a[1].y + a[2].y) / 6, (a[1].x + 6 * a[2].x - a[3].x) / 6, (a[1].y + 6 * a[2].y - a[3].y) / 6, a[2].x, a[2].y]);
      }

      return n;
    };
  }, function (t, e) {
    var n = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (t) {
      return _typeof(t);
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : _typeof(t);
    },
        r = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029",
        i = new RegExp("([a-z])[" + r + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + r + "]*,?[" + r + "]*)+)", "ig"),
        a = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + r + "]*,?[" + r + "]*", "ig");

    t.exports = function (t) {
      if (!t) return null;
      if ((void 0 === t ? "undefined" : n(t)) === n([])) return t;
      var e = {
        a: 7,
        c: 6,
        o: 2,
        h: 1,
        l: 2,
        m: 2,
        r: 4,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        u: 3,
        z: 0
      },
          r = [];
      return String(t).replace(i, function (t, n, i) {
        var o = [],
            s = n.toLowerCase();
        if (i.replace(a, function (t, e) {
          e && o.push(+e);
        }), "m" === s && o.length > 2 && (r.push([n].concat(o.splice(0, 2))), s = "l", n = "m" === n ? "l" : "L"), "o" === s && 1 === o.length && r.push([n, o[0]]), "r" === s) r.push([n].concat(o));else for (; o.length >= e[s] && (r.push([n].concat(o.splice(0, e[s]))), e[s]);) {
          ;
        }
      }), r;
    };
  }, function (t, e, n) {
    var r = n(659),
        i = n(658);

    function a(t, e, n, r, i) {
      var a = [];

      if (null === i && null === r && (r = n), t = +t, e = +e, n = +n, r = +r, null !== i) {
        var o = Math.PI / 180,
            s = t + n * Math.cos(-r * o),
            u = t + n * Math.cos(-i * o);
        a = [["M", s, e + n * Math.sin(-r * o)], ["A", n, n, 0, +(i - r > 180), 0, u, e + n * Math.sin(-i * o)]];
      } else a = [["M", t, e], ["m", 0, -r], ["a", n, r, 0, 1, 1, 0, 2 * r], ["a", n, r, 0, 1, 1, 0, -2 * r], ["z"]];

      return a;
    }

    t.exports = function (t) {
      if (!(t = r(t)) || !t.length) return [["M", 0, 0]];
      var e = [],
          n = 0,
          o = 0,
          s = 0,
          u = 0,
          c = 0,
          h = void 0,
          f = void 0;
      "M" === t[0][0] && (s = n = +t[0][1], u = o = +t[0][2], c++, e[0] = ["M", n, o]);

      for (var l, p, d = 3 === t.length && "M" === t[0][0] && "R" === t[1][0].toUpperCase() && "Z" === t[2][0].toUpperCase(), g = c, v = t.length; g < v; g++) {
        if (e.push(l = []), (h = (p = t[g])[0]) !== h.toUpperCase()) switch (l[0] = h.toUpperCase(), l[0]) {
          case "A":
            l[1] = p[1], l[2] = p[2], l[3] = p[3], l[4] = p[4], l[5] = p[5], l[6] = +p[6] + n, l[7] = +p[7] + o;
            break;

          case "V":
            l[1] = +p[1] + o;
            break;

          case "H":
            l[1] = +p[1] + n;
            break;

          case "R":
            for (var m = 2, x = (f = [n, o].concat(p.slice(1))).length; m < x; m++) {
              f[m] = +f[m] + n, f[++m] = +f[m] + o;
            }

            e.pop(), e = e.concat(i(f, d));
            break;

          case "O":
            e.pop(), (f = a(n, o, p[1], p[2])).push(f[0]), e = e.concat(f);
            break;

          case "U":
            e.pop(), e = e.concat(a(n, o, p[1], p[2], p[3])), l = ["U"].concat(e[e.length - 1].slice(-2));
            break;

          case "M":
            s = +p[1] + n, u = +p[2] + o;
            break;

          default:
            for (var y = 1, b = p.length; y < b; y++) {
              l[y] = +p[y] + (y % 2 ? n : o);
            }

        } else if ("R" === h) f = [n, o].concat(p.slice(1)), e.pop(), e = e.concat(i(f, d)), l = ["R"].concat(p.slice(-2));else if ("O" === h) e.pop(), (f = a(n, o, p[1], p[2])).push(f[0]), e = e.concat(f);else if ("U" === h) e.pop(), e = e.concat(a(n, o, p[1], p[2], p[3])), l = ["U"].concat(e[e.length - 1].slice(-2));else for (var M = 0, w = p.length; M < w; M++) {
          l[M] = p[M];
        }
        if ("O" !== (h = h.toUpperCase())) switch (l[0]) {
          case "Z":
            n = +s, o = +u;
            break;

          case "H":
            n = l[1];
            break;

          case "V":
            o = l[1];
            break;

          case "M":
            s = l[l.length - 2], u = l[l.length - 1];
            break;

          default:
            n = l[l.length - 2], o = l[l.length - 1];
        }
      }

      return e;
    };
  }, function (t, e, n) {
    var r = n(660),
        i = function i(t, e, n, r) {
      return [t, e, n, r, n, r];
    },
        a = function a(t, e, n, r, i, _a) {
      return [1 / 3 * t + 2 / 3 * n, 1 / 3 * e + 2 / 3 * r, 1 / 3 * i + 2 / 3 * n, 1 / 3 * _a + 2 / 3 * r, i, _a];
    };

    t.exports = function (t, e) {
      var n = r(t),
          o = e && r(e),
          s = {
        x: 0,
        y: 0,
        bx: 0,
        by: 0,
        X: 0,
        Y: 0,
        qx: null,
        qy: null
      },
          u = {
        x: 0,
        y: 0,
        bx: 0,
        by: 0,
        X: 0,
        Y: 0,
        qx: null,
        qy: null
      },
          c = [],
          h = [],
          f = "",
          l = "",
          p = void 0,
          d = function d(t, e, n) {
        var r = void 0,
            o = void 0;
        if (!t) return ["C", e.x, e.y, e.x, e.y, e.x, e.y];

        switch (!(t[0] in {
          T: 1,
          Q: 1
        }) && (e.qx = e.qy = null), t[0]) {
          case "M":
            e.X = t[1], e.Y = t[2];
            break;

          case "A":
            t = ["C"].concat(function t(e, n, r, i, a, o, s, u, c, h) {
              r === i && (r += 1);

              var f = 120 * Math.PI / 180,
                  l = Math.PI / 180 * (+a || 0),
                  p = [],
                  d = void 0,
                  g = void 0,
                  v = void 0,
                  m = void 0,
                  x = void 0,
                  y = function y(t, e, n) {
                return {
                  x: t * Math.cos(n) - e * Math.sin(n),
                  y: t * Math.sin(n) + e * Math.cos(n)
                };
              };

              if (h) g = h[0], v = h[1], m = h[2], x = h[3];else {
                e = (d = y(e, n, -l)).x, n = d.y, u = (d = y(u, c, -l)).x, c = d.y, e === u && n === c && (u += 1, c += 1);
                var b = (e - u) / 2,
                    M = (n - c) / 2,
                    w = b * b / (r * r) + M * M / (i * i);
                w > 1 && (r *= w = Math.sqrt(w), i *= w);

                var _ = r * r,
                    E = i * i,
                    S = (o === s ? -1 : 1) * Math.sqrt(Math.abs((_ * E - _ * M * M - E * b * b) / (_ * M * M + E * b * b)));

                m = S * r * M / i + (e + u) / 2, x = S * -i * b / r + (n + c) / 2, g = Math.asin(((n - x) / i).toFixed(9)), v = Math.asin(((c - x) / i).toFixed(9)), g = e < m ? Math.PI - g : g, v = u < m ? Math.PI - v : v, g < 0 && (g = 2 * Math.PI + g), v < 0 && (v = 2 * Math.PI + v), s && g > v && (g -= 2 * Math.PI), !s && v > g && (v -= 2 * Math.PI);
              }
              var A = v - g;

              if (Math.abs(A) > f) {
                var P = v,
                    O = u,
                    C = c;
                v = g + f * (s && v > g ? 1 : -1), p = t(u = m + r * Math.cos(v), c = x + i * Math.sin(v), r, i, a, 0, s, O, C, [v, P, m, x]);
              }

              A = v - g;
              var I = Math.cos(g),
                  T = Math.sin(g),
                  k = Math.cos(v),
                  N = Math.sin(v),
                  L = Math.tan(A / 4),
                  B = 4 / 3 * r * L,
                  j = 4 / 3 * i * L,
                  D = [e, n],
                  R = [e + B * T, n - j * I],
                  F = [u + B * N, c - j * k],
                  Y = [u, c];
              if (R[0] = 2 * D[0] - R[0], R[1] = 2 * D[1] - R[1], h) return [R, F, Y].concat(p);

              for (var X = [], G = 0, q = (p = [R, F, Y].concat(p).join().split(",")).length; G < q; G++) {
                X[G] = G % 2 ? y(p[G - 1], p[G], l).y : y(p[G], p[G + 1], l).x;
              }

              return X;
            }.apply(0, [e.x, e.y].concat(t.slice(1))));
            break;

          case "S":
            "C" === n || "S" === n ? (r = 2 * e.x - e.bx, o = 2 * e.y - e.by) : (r = e.x, o = e.y), t = ["C", r, o].concat(t.slice(1));
            break;

          case "T":
            "Q" === n || "T" === n ? (e.qx = 2 * e.x - e.qx, e.qy = 2 * e.y - e.qy) : (e.qx = e.x, e.qy = e.y), t = ["C"].concat(a(e.x, e.y, e.qx, e.qy, t[1], t[2]));
            break;

          case "Q":
            e.qx = t[1], e.qy = t[2], t = ["C"].concat(a(e.x, e.y, t[1], t[2], t[3], t[4]));
            break;

          case "L":
            t = ["C"].concat(i(e.x, e.y, t[1], t[2]));
            break;

          case "H":
            t = ["C"].concat(i(e.x, e.y, t[1], e.y));
            break;

          case "V":
            t = ["C"].concat(i(e.x, e.y, e.x, t[1]));
            break;

          case "Z":
            t = ["C"].concat(i(e.x, e.y, e.X, e.Y));
        }

        return t;
      },
          g = function g(t, e) {
        if (t[e].length > 7) {
          t[e].shift();

          for (var r = t[e]; r.length;) {
            c[e] = "A", o && (h[e] = "A"), t.splice(e++, 0, ["C"].concat(r.splice(0, 6)));
          }

          t.splice(e, 1), p = Math.max(n.length, o && o.length || 0);
        }
      },
          v = function v(t, e, r, i, a) {
        t && e && "M" === t[a][0] && "M" !== e[a][0] && (e.splice(a, 0, ["M", i.x, i.y]), r.bx = 0, r.by = 0, r.x = t[a][1], r.y = t[a][2], p = Math.max(n.length, o && o.length || 0));
      };

      p = Math.max(n.length, o && o.length || 0);

      for (var m = 0; m < p; m++) {
        n[m] && (f = n[m][0]), "C" !== f && (c[m] = f, m && (l = c[m - 1])), n[m] = d(n[m], s, l), "A" !== c[m] && "C" === f && (c[m] = "C"), g(n, m), o && (o[m] && (f = o[m][0]), "C" !== f && (h[m] = f, m && (l = h[m - 1])), o[m] = d(o[m], u, l), "A" !== h[m] && "C" === f && (h[m] = "C"), g(o, m)), v(n, o, s, u, m), v(o, n, u, s, m);
        var x = n[m],
            y = o && o[m],
            b = x.length,
            M = o && y.length;
        s.x = x[b - 2], s.y = x[b - 1], s.bx = parseFloat(x[b - 4]) || s.x, s.by = parseFloat(x[b - 3]) || s.y, u.bx = o && (parseFloat(y[M - 4]) || u.x), u.by = o && (parseFloat(y[M - 3]) || u.y), u.x = o && y[M - 2], u.y = o && y[M - 1];
      }

      return o ? [n, o] : n;
    };
  }, function (t, e) {
    var n = /,?([a-z]),?/gi;

    t.exports = function (t) {
      return t.join(",").replace(n, "$1");
    };
  }, function (t, e, n) {
    var r = n(662);

    t.exports = function (t, e, n, i, a) {
      if (a) return [["M", +t + +a, e], ["l", n - 2 * a, 0], ["a", a, a, 0, 0, 1, a, a], ["l", 0, i - 2 * a], ["a", a, a, 0, 0, 1, -a, a], ["l", 2 * a - n, 0], ["a", a, a, 0, 0, 1, -a, -a], ["l", 0, 2 * a - i], ["a", a, a, 0, 0, 1, a, -a], ["z"]];
      var o = [["M", t, e], ["l", n, 0], ["l", 0, i], ["l", -n, 0], ["z"]];
      return o.parsePathArray = r, o;
    };
  }, function (t, e, n) {
    var r = n(46),
        i = n(84),
        a = Object.values ? function (t) {
      return Object.values(t);
    } : function (t) {
      var e = [];
      return r(t, function (n, r) {
        i(t) && "prototype" === r || e.push(n);
      }), e;
    };
    t.exports = a;
  }, function (t, e) {
    t.exports = function (t, e) {
      return t.hasOwnProperty(e);
    };
  }, function (t, e, n) {
    var r = n(616),
        i = n(46),
        a = n(617);

    t.exports = function (t, e) {
      return t = r(t), i(e, function (e) {
        switch (e[0]) {
          case "t":
            a.translate(t, t, [e[1], e[2]]);
            break;

          case "s":
            a.scale(t, t, [e[1], e[2]]);
            break;

          case "r":
            a.rotate(t, t, e[1]);
            break;

          case "m":
            a.multiply(t, t, e[1]);
            break;

          default:
            return !1;
        }
      }), t;
    };
  }, function (t, e, n) {
    var r = n(254);
    t.exports = r;
  }, function (t, e, n) {
    var r = n(255),
        i = n(618);
    r.angle = function (t, e) {
      var n = r.dot(t, e) / (r.length(t) * r.length(e));
      return Math.acos(i(n, -1, 1));
    }, r.direction = function (t, e) {
      return t[0] * e[1] - e[0] * t[1];
    }, r.angleTo = function (t, e, n) {
      var i = r.angle(t, e),
          a = r.direction(t, e) >= 0;
      return n ? a ? 2 * Math.PI - i : i : a ? i : 2 * Math.PI - i;
    }, r.vertical = function (t, e, n) {
      return n ? (t[0] = e[1], t[1] = -1 * e[0]) : (t[0] = -1 * e[1], t[1] = e[0]), t;
    }, t.exports = r;
  }, function (t, e) {
    var n = Math.PI / 180;

    t.exports = function (t) {
      return n * t;
    };
  }, function (t, e) {
    t.exports = parseInt;
  }, function (t, e) {
    var n = 180 / Math.PI;

    t.exports = function (t) {
      return n * t;
    };
  }, function (t, e) {
    t.exports = function (t, e) {
      return (t % e + e) % e;
    };
  }, function (t, e) {
    t.exports = function (t, e) {
      var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e-5;
      return Math.abs(t - e) < n;
    };
  }, function (t, e, n) {
    var r = n(46),
        i = n(605);

    t.exports = function (t) {
      var e = [];
      return r(t, function (t) {
        i(e, t) || e.push(t);
      }), e;
    };
  }, function (t, e, n) {
    var r = n(118),
        i = Array.prototype.splice;

    t.exports = function (t, e) {
      if (!r(t)) return [];

      for (var n = t ? e.length : 0, a = n - 1; n--;) {
        var o = void 0,
            s = e[n];
        n !== a && s === o || (o = s, i.call(t, s, 1));
      }

      return t;
    };
  }, function (t, e) {
    var n = Array.prototype,
        r = n.splice,
        i = n.indexOf,
        a = n.slice;

    t.exports = function (t) {
      for (var e = a.call(arguments, 1), n = 0; n < e.length; n++) {
        for (var o = e[n], s = -1; (s = i.call(t, o)) > -1;) {
          r.call(t, s, 1);
        }
      }

      return t;
    };
  }, function (t, e, n) {
    var r = n(46),
        i = n(84),
        a = Object.keys ? function (t) {
      return Object.keys(t);
    } : function (t) {
      var e = [];
      return r(t, function (n, r) {
        i(t) && "prototype" === r || e.push(r);
      }), e;
    };
    t.exports = a;
  }, function (t, e, n) {
    var r = n(677),
        i = n(237);

    t.exports = function (t, e) {
      var n = r(e),
          a = n.length;
      if (i(t)) return !a;

      for (var o = 0; o < a; o += 1) {
        var s = n[o];
        if (e[s] !== t[s] || !(s in t)) return !1;
      }

      return !0;
    };
  }, function (t, e) {
    t.exports = function (t) {
      return (window.requestAnimationFrame || window.webkitRequestAnimationFrame || function (t) {
        return setTimeout(t, 16);
      })(t);
    };
  }, function (t, e) {
    t.exports = function (t, e) {
      if (t) for (var n in e) {
        e.hasOwnProperty(n) && (t.style[n] = e[n]);
      }
      return t;
    };
  }, function (t, e) {
    var n = document.createElement("table"),
        r = document.createElement("tr"),
        i = /^\s*<(\w+|!)[^>]*>/,
        a = {
      tr: document.createElement("tbody"),
      tbody: n,
      thead: n,
      tfoot: n,
      td: r,
      th: r,
      "*": document.createElement("div")
    };

    t.exports = function (t) {
      var e = i.test(t) && RegExp.$1;
      e in a || (e = "*");
      var n = a[e];
      t = t.replace(/(^\s*)|(\s*$)/g, ""), n.innerHTML = "" + t;
      var r = n.childNodes[0];
      return n.removeChild(r), r;
    };
  }, function (t, e, n) {
    var r = n(257),
        i = {
      isBetween: function isBetween(t, e, n) {
        return t >= e && t <= n;
      },
      getLineIntersect: function getLineIntersect(t, e, n, r) {
        var a = n.x - t.x,
            o = n.y - t.y,
            s = e.x - t.x,
            u = e.y - t.y,
            c = r.x - n.x,
            h = r.y - n.y,
            f = s * h - u * c,
            l = null;

        if (f * f > .001 * (s * s + u * u) * (c * c + h * h)) {
          var p = (a * h - o * c) / f,
              d = (a * u - o * s) / f;
          i.isBetween(p, 0, 1) && i.isBetween(d, 0, 1) && (l = {
            x: t.x + p * s,
            y: t.y + p * u
          });
        }

        return l;
      },
      getIntersectPointRect: function getIntersectPointRect(t, e) {
        var n = t.minX,
            r = t.minY,
            a = t.maxX - t.minX,
            o = t.maxY - t.minY,
            s = [],
            u = {
          x: n + a / 2,
          y: r + o / 2
        };
        s.push({
          x: n,
          y: r
        }), s.push({
          x: n + a,
          y: r
        }), s.push({
          x: n + a,
          y: r + o
        }), s.push({
          x: n,
          y: r + o
        }), s.push({
          x: n,
          y: r
        });

        for (var c = null, h = 1; h < s.length && !(c = i.getLineIntersect(s[h - 1], s[h], u, e)); h++) {
          ;
        }

        return c;
      },
      getIntersectPointCircle: function getIntersectPointCircle(t, e, n, r, i) {
        if (Math.sqrt(Math.pow(t - n, 2) + Math.pow(e - r, 2)) < i) return null;
        var a = t - n,
            o = e - r,
            s = Math.sign(a),
            u = Math.sign(o),
            c = Math.atan(o / a);
        return {
          x: n + Math.abs(i * Math.cos(c)) * s,
          y: r + Math.abs(i * Math.sin(c)) * u
        };
      },
      applyMatrix: function applyMatrix(t, e, n) {
        void 0 === n && (n = 1);
        var i = [t.x, t.y, n];
        return r.vec3.transformMat3(i, i, e), {
          x: i[0],
          y: i[1]
        };
      },
      invertMatrix: function invertMatrix(t, e, n) {
        void 0 === n && (n = 1);
        var i = r.mat3.invert([], e),
            a = [t.x, t.y, n];
        return r.vec3.transformMat3(a, a, i), {
          x: a[0],
          y: a[1]
        };
      },
      radixSort: function radixSort(t, e) {
        var n,
            r,
            i,
            a,
            o,
            s,
            u,
            c = 10,
            h = 1,
            f = [],
            l = 1;

        for (i = 0; i < t.length; i++) {
          n = e(t[i]), r = (n = parseInt(n, 10)).toString().length, n.toString().length > l && (l = r);
        }

        for (i = 0; i < l; i++, h *= 10, c *= 10) {
          for (a = 0; a < t.length; a++) {
            o = e(t[a]), void 0 === f[o = parseInt(o % c / h, 10)] && (f[o] = []), f[o].push(t[a]);
          }

          for (s = 0, a = 0; a < f.length; a++) {
            if (u = void 0, void 0 !== f[a]) for (u = f[a].shift(); void 0 !== u;) {
              t[s++] = u, u = f[a].shift();
            }
          }
        }

        return t;
      },
      getArcOfVectors: function getArcOfVectors(t, e) {
        var n = t.x,
            r = t.y,
            i = e.x,
            a = e.y,
            o = Math.sqrt(n * n + r * r),
            s = Math.sqrt(i * i + a * a);
        return Math.acos((n * i + r * a) / (o * s));
      }
    };
    t.exports = r.mix({}, r, i);
  }, function (t, e, n) {
    var r = n(258);
    r.registerShapeManager("node", {
      defaultShapeType: "common"
    }), r.registerShapeManager("edge", {
      defaultShapeType: "common"
    }), r.registerShapeManager("group", {
      defaultShapeType: "common"
    }), r.registerShapeManager("guide", {
      defaultShapeType: "common"
    }), n(724), n(721), n(719), n(717), t.exports = r;
  }, function (t, e, n) {
    var r = n(247),
        i = n(609),
        a = n(26);
    setTimeout(function () {
      var t = r.track;

      if (r.track) {
        var e = new Image(),
            n = {
          pg: document.URL,
          r: new Date().getTime(),
          g6: !0,
          version: i,
          page_type: "syslog"
        };
        a.isObject(t) && a.mix(n, t);
        var o = encodeURIComponent(JSON.stringify([n]));
        e.src = "https://kcart.alipay.com/web/bi.do?BIProfile=merge&d=" + o;
      }
    }, 2e3);
  }, function (t, e, n) {
    var r = n(598),
        i = function (t) {
      function e(e) {
        var n;
        return (n = t.call(this, e) || this).layout = r.mindmap, n;
      }

      return function (t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
      }(e, t), e;
    }(n(597));

    t.exports = i;
  }, function (t, e, n) {
    var r = n(598),
        i = function (t) {
      function e(e) {
        var n;
        return (n = t.call(this, e) || this).layout = r.indented, n;
      }

      return function (t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
      }(e, t), e;
    }(n(597));

    t.exports = i;
  }, function (t, e, n) {
    var r = n(598),
        i = function (t) {
      function e(e) {
        var n;
        return (n = t.call(this, e) || this).layout = r.dendrogram, n;
      }

      return function (t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
      }(e, t), e;
    }(n(597));

    t.exports = i;
  }, function (t, e, n) {
    var r = n(598),
        i = function (t) {
      function e(e) {
        var n;
        return (n = t.call(this, e) || this).layout = r.compactBox, n;
      }

      return function (t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
      }(e, t), e;
    }(n(597));

    t.exports = i;
  }, function (t, e, n) {
    var r = n(26),
        i = n(625),
        a = n(623),
        o = function (t) {
      function e(e) {
        var n = r.mix({
          layout: new a.CompactBoxTree({
            getHGap: function getHGap() {
              return 10;
            },
            getVGap: function getVGap() {
              return 10;
            }
          }),
          _type: "tree"
        }, e);
        return t.call(this, n) || this;
      }

      !function (t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
      }(e, t);
      var n = e.prototype;
      return n.initEvent = function () {
        var t = this;
        this.on("afterdrawinner", function () {
          t.get("_sourceData").roots.forEach(function (e) {
            var n = t.find(e.id);

            t._setVisibleByCollapsed(n);
          });
        });
      }, n._executeLayout = function (t) {
        var e = this.get("_sourceData");
        r.isFunction(t) ? t(e.roots, this) : r.isObject(t) && (t.roots = e.roots, t.graph = this, t.execute());
      }, n.getHierarchy = function (t) {
        t = this.getItem(t);

        for (var e = this.get("_dataMap"), n = t.getModel().parent, r = 1; n;) {
          n = e[n].parent, r++;
        }

        return r;
      }, n.parseSource = function (t) {
        var e = t.roots,
            n = this.get("_dataMap"),
            i = [],
            a = [];
        if (!e) throw new Error("please set data.roots!");
        return e.forEach(function (t) {
          r.traverseTree(t, function (t, e) {
            t.id || (t.id = r.guid()), e || (e = n[t.parent]), e && (t.parent = e.id, e.id || (e.id = r.guid()), a.push({
              source: e.id,
              target: t.id,
              id: e.id + "-" + t.id
            })), i.push(t);
          }, function (t) {
            return t.children;
          }, !0);
        }), {
          nodes: i,
          edges: a
        };
      }, n._setVisibleByCollapsed = function (t) {
        var e = t.getModel();
        t.collapsedParent ? (t.hide(), t.getEdges().forEach(function (t) {
          t.hide();
        }), t.deepEach(function (t) {
          t.hide(), t.getEdges().forEach(function (t) {
            t.hide();
          });
        })) : e.collapsed ? t.deepEach(function (t) {
          t.hide(), t.getEdges().forEach(function (t) {
            t.hide();
          });
        }) : t.deepEach(function (t) {
          t.collapsedParent && (t.hide(), t.getEdges().forEach(function (t) {
            t.hide();
          }));
        });
      }, n.source = function (t) {
        var e = this.parseSource(t);
        this.emit("beforesource"), this.set("_sourceData", t), this.set("_data", e), this.emit("aftersource");
      }, n._setNodeNth = function (t, e) {
        var n = (t = this.getItem(t)).getModel(),
            i = t.getParent().getModel().children;
        r.Array.remove(i, n), i.splice(e, 0, n);
      }, n.getNth = function (t) {
        var e = (t = this.getItem(t)).getModel();
        return t.getParent().getModel().children.indexOf(e);
      }, n.add = function (t, e) {
        var n,
            i = this.get("_dataMap")[e.parent],
            a = {
          action: "add",
          model: e
        };

        if ("node" === t || "guide" === t) {
          if (this.emit("beforechange", a), "node" === t) {
            if (!i) throw new Error("please set available parent Id !");
            r.isArray(i.children) ? i.children.push(e) : i.children = [e];
            var o = this.parseSource({
              roots: [e]
            });
            this._addItems("node", o.nodes), this._addItems("edge", o.edges), n = this.find(e.id), this._setVisibleByCollapsed(n), r.isNil(e.nth) || this._setNodeNth(n, e.nth), this.find(i.id).forceUpdate();
          } else this._addItems(t, [e]), n = this.find(e.id);

          return a.item = n, this.emit("afterchange", a), n;
        }

        console.warn("Tree do not support add type " + t + "!");
      }, n.update = function (t, e) {
        var n = this;

        if (e) {
          var i = (t = this.getItem(t)).getModel(),
              a = r.mix({}, i),
              o = {
            action: "update",
            item: t,
            originModel: a,
            updateModel: e
          };

          if (this.emit("beforechange", o), this._updateItems([t], [e]), t.isNode) {
            if ("collapsed" in e && (e.collapsed ? t.deepEach(function (t) {
              t.hide(), t.getEdges().forEach(function (t) {
                t.hide();
              });
            }) : t.deepEach(function (t) {
              t.show(), t.getInEdges().forEach(function (t) {
                t.show();
              });
            }, function (t) {
              return t.model.collapsed ? null : t.getChildren();
            })), e.parent && e.parent !== a.parent) {
              var s = this.find(a.parent).getModel(),
                  u = this.find(e.parent).getModel(),
                  c = this.find(s.id + "-" + a.id),
                  h = {
                id: u.id + "-" + a.id,
                source: u.id,
                target: a.id
              };
              r.Array.remove(s.children, i), u.children ? u.children.push(i) : u.children = [i], this._removeItems([c]), this._addItems("edge", [h]), this.find(u.id).forceUpdate();
            }

            r.isArray(e.children) && (a.children && r.each(a.children, function (t) {
              var e = n.find(t.id),
                  r = [e];
              e.getEdges().forEach(function (t) {
                r.push(t);
              }), n._removeItems(r);
            }), r.each(e.children, function (t) {
              var e = n.parseSource({
                roots: [t]
              }),
                  i = r.isNil(t.id) ? r.guid() : t.id;
              n._addItems("node", e.nodes), n._addItems("edge", e.edges), !t.parent && n._addItems("edge", [{
                id: a.id + "-" + i,
                source: a.id,
                target: i
              }]);
            })), r.isNil(e.nth) || this._setNodeNth(t, e.nth);
            var f = this.find(i.parent);
            f && f.forceUpdate();
          }

          return this.emit("afterchange", o), this;
        }
      }, n.remove = function (t) {
        var e = this.get("_dataMap"),
            n = [];

        if ((t = this.getItem(t)) && !t.destroyed) {
          var i = {
            action: "remove",
            item: t
          };

          if (this.emit("beforechange", i), n.push(t), "node" === t.type) {
            t.getEdges().forEach(function (t) {
              n.push(t);
            });
            var a = t.getModel(),
                o = e[a.parent];
            t.deepEach(function (t) {
              n.push(t), t.getEdges().forEach(function (t) {
                n.push(t);
              });
            }), r.Array.remove(o.children, a), this.find(o.id).forceUpdate();
          }

          return this._removeItems(r.uniq(n)), this.emit("afterchange", i), this;
        }
      }, n.getRoots = function () {
        var t = this;
        return this.getSource().roots.map(function (e) {
          return t.find(e.id);
        });
      }, n.save = function () {
        var t = {
          roots: r.clone(this.getSource().roots),
          guides: this.getGuides().map(function (t) {
            return t.getModel();
          })
        };
        return 0 === t.roots.length && delete t.roots, 0 === t.guides.length && delete t.guides, t;
      }, e;
    }(i);

    t.exports = o;
  }, function (t, e, n) {
    var r = n(26),
        i = {
      INIT: "_initForceFit"
    };
    i.AUGMENT = {
      _initForceFit: function _initForceFit() {
        var t = this.get("width"),
            e = this.get("height");
        return t || e ? t ? e ? void 0 : (this.forceFit("height"), void this._bindForceEvent("height")) : (this.forceFit("width"), void this._bindForceEvent("width")) : (this.forceFit(), void this._bindForceEvent());
      },
      _bindForceEvent: function _bindForceEvent(t) {
        var e = this,
            n = this._getTimer("forceFit"),
            r = function r() {
          var r = setTimeout(function () {
            e.forceFit(t);
          }, 200);
          n && clearTimeout(n), e._setTimer("forceFit", r);
        };

        window.addEventListener("resize", r), this.set("_windowForceResizeEvent", r);
      },
      forceFit: function forceFit(t) {
        var e = this.get("_containerDOM"),
            n = this.get("width"),
            i = this.get("height"),
            a = r.getHeight(e),
            o = r.getWidth(e);
        return "width" === t ? (this.changeSize(o, i), this) : "height" === t ? (this.changeSize(n, a), this) : (this.changeSize(o, a), this);
      }
    }, t.exports = i;
  }, function (t, e, n) {
    var r = n(26),
        i = {
      CFG: {
        fitView: void 0,
        fitViewPadding: 10,
        minZoom: .2,
        maxZoom: 10
      }
    };
    i.AUGMENT = {
      getBBox: function getBBox() {
        var t = this.get("_itemGroup"),
            e = this.get("_itemMap"),
            n = t.get("children");
        return n.length > 0 ? (n = n.filter(function (t) {
          var n = e[t.id];
          return !!n && !1 !== n.getShapeObj().bboxCalculation;
        }), r.getChildrenBBox(n)) : {
          minX: 0,
          minY: 0,
          maxX: this.get("width"),
          maxY: this.get("height")
        };
      },
      getFitViewPadding: function getFitViewPadding() {
        return r.toAllPadding(this.get("fitViewPadding"));
      },
      setFitView: function setFitView(t) {
        if (!t) return this;
        if ("autoZoom" === t) return this.autoZoom(), this;
        var e = this.getFitViewPadding(),
            n = this.get("width"),
            i = this.get("height"),
            a = this.getBBox(),
            o = a.maxX - a.minX,
            s = a.maxY - a.minY,
            u = {
          x: 0,
          y: 0,
          width: n,
          height: i
        },
            c = r.getNineBoxPosition(t, u, o, s, e),
            h = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        r.mat3.translate(h, h, [-a.minX + c.x, -a.minY + c.y]), this.updateMatrix(h);
      },
      _getZoomRatio: function _getZoomRatio(t) {
        var e = this.get("maxZoom"),
            n = this.get("minZoom");
        return t < n && (t = n), t > e && (t = e), t;
      },
      autoZoom: function autoZoom(t) {
        var e = this;
        t || (t = this.getFitViewPadding());
        var n = this.get("width"),
            i = this.get("height"),
            a = this.getBBox(),
            o = r.getAutoZoomMatrix({
          minX: 0,
          minY: 0,
          maxX: n,
          maxY: i
        }, a, t, function (t) {
          return e._getZoomRatio(t);
        });
        this.updateMatrix(o);
      },
      getZoom: function getZoom() {
        return this.getMatrix()[0];
      },
      updateMatrix: function updateMatrix(t) {
        var e = this.getMatrix(),
            n = {
          updateMatrix: t,
          originMatrix: e
        },
            r = e[0] !== t[0];
        return this.emit("beforeviewportchange", n), r && this.emit("beforezoom", n), this.setMatrix(t), r && this.emit("afterzoom", n), this.emit("afterviewportchange", n), this.draw(), this;
      },
      zoom: function zoom(t, e) {
        if (!r.isNumber(t)) {
          e = this._getZoomRatio(e);
          var n = this.get("_rootGroup"),
              i = r.clone(n.getMatrix()),
              a = i[6] + i[0] * t.x - e * t.x,
              o = i[7] + i[0] * t.y - e * t.y;
          return i[6] = 0, i[7] = 0, i[0] = e, i[4] = e, r.mat3.translate(i, i, [a, o]), this.updateMatrix(i), this;
        }

        var s = this.get("width"),
            u = this.get("height");
        this.zoomByDom({
          x: s / 2,
          y: u / 2
        }, t);
      },
      zoomByDom: function zoomByDom(t, e) {
        var n = this.getPoint(t);
        return this.zoom(n, e), this;
      },
      translate: function translate(t, e) {
        var n = this.get("_rootGroup").getMatrix();
        return r.mat3.translate(n, n, [t, e]), this.updateMatrix(n), this;
      },
      translateByDom: function translateByDom(t, e) {
        var n = this.get("_rootGroup").getMatrix()[0];
        return this.translate(t / n, e / n), this;
      },
      getMatrix: function getMatrix() {
        return this.get("_rootGroup").getMatrix();
      },
      setMatrix: function setMatrix(t) {
        this.get("_rootGroup").setMatrix(t);
      },
      getPoint: function getPoint(t) {
        return this.getPointByDom(t);
      },
      getPointByDom: function getPointByDom(t) {
        var e = this.get("_rootGroup").getMatrix();
        return r.invertMatrix(t, e);
      },
      getPointByCanvas: function getPointByCanvas(t) {
        var e = this.get("_canvas").get("pixelRatio");
        return this.getPoint({
          x: t.x / e,
          y: t.y / e
        });
      },
      getPointByClient: function getPointByClient(t) {
        var e = this.get("_canvas").getPointByClient(t.x, t.y);
        return this.getPointByCanvas(e);
      },
      getDomPoint: function getDomPoint(t) {
        var e = this.get("_rootGroup").getMatrix();
        return r.applyMatrix(t, e);
      },
      getCanvasPoint: function getCanvasPoint(t) {
        var e = this.get("_canvas").get("pixelRatio"),
            n = this.getDomPoint(t);
        return {
          x: n.x * e,
          y: n.y * e
        };
      },
      getClientPoint: function getClientPoint(t) {
        var e = this.getCanvasPoint(t),
            n = this.get("_canvas").getClientByPoint(e.x, e.y);
        return {
          x: n.clientX,
          y: n.clientY
        };
      },
      focus: function focus(t) {
        if (r.isString(t) && (t = this.find(t)), t) {
          var e = t.getCenter();
          this.focusPoint(e);
        }

        return this;
      },
      focusPoint: function focusPoint(t) {
        var e = this.get("_rootGroup").getMatrix(),
            n = this.get("width"),
            r = this.get("height"),
            i = -e[6] + n / 2 - e[0] * t.x,
            a = -e[7] + r / 2 - e[0] * t.y;
        return this.translate(i, a), this;
      },
      focusPointByDom: function focusPointByDom(t) {
        var e = this.getPoint(t);
        return this.focusPoint(e), this;
      }
    }, t.exports = i;
  }, function (t, e) {
    var n = {
      INIT: "_initDraw",
      AUGMENT: {
        _initDraw: function _initDraw() {
          var t = this,
              e = this.get("_controllers").animate;
          ["clear", "show", "hide", "change", "updatenodeposition"].forEach(function (n) {
            e && t.on("before" + n, function (n) {
              var r = t.get("_forcePreventAnimate"),
                  i = n ? n.affectedItemIds : void 0;
              !0 !== r && e && e.cacheGraph("startCache", i);
            }), t.on("after" + n, function (n) {
              var r = n ? n.affectedItemIds : void 0,
                  i = t.get("_forcePreventAnimate");

              if (n && "changeData" === n.action) {
                var a = t.get("fitView");
                a && t.setFitView(a);
              }

              !0 !== i && e ? (e.cacheGraph("endCache", r), e.run()) : t.draw();
            });
          });
        },
        draw: function draw() {
          this.get("_canvas").draw();
        },
        animateDraw: function animateDraw() {
          this.get("_controllers").animate.run();
        }
      }
    };
    t.exports = n;
  }, function (t, e, n) {
    var r = n(247);

    function i(t, e) {
      var n = t.getGraphicGroup(),
          i = t.getBBox(),
          a = (i.minX + i.maxX) / 2,
          o = (i.minY + i.maxY) / 2,
          s = n.getMatrix()[0];
      n.transform([["t", -a, -o], ["s", .01 / s, .01 / s], ["t", a, o]]), n.animate({
        transform: [["t", -a, -o], ["s", 100 * s, 100 * s], ["t", a, o]]
      }, r.enterDuration, r.enterEasing, e);
    }

    function a(t, e) {
      var n = t.getGraphicGroup(),
          i = t.getBBox(),
          a = (i.minX + i.maxX) / 2,
          o = (i.minY + i.maxY) / 2,
          s = n.getMatrix()[0];
      n.animate({
        transform: [["t", -a, -o], ["s", .01 / s, .01 / s], ["t", a, o]]
      }, r.leaveDuration, r.leaveEasing, e);
    }

    function o(t, e) {
      t.deepEach(function (t) {
        if (t.isShape) {
          var n = t.attr("fillOpacity"),
              i = t.attr("strokeOpacity");
          t.attr({
            fillOpacity: 0,
            strokeOpacity: 0
          }), t.animate({
            fillOpacity: n,
            strokeOpacity: i
          }, r.enterDuration, r.enterEasing, e);
        }
      });
    }

    function s(t, e) {
      t.deepEach(function (t) {
        var n = t.attr("fillOpacity"),
            i = t.attr("strokeOpacity");
        t.isShape && t.animate({
          fillOpacity: 0,
          strokeOpacity: 0
        }, r.leaveDuration, r.leaveEasing, function () {
          t.attr({
            fillOpacity: n,
            strokeOpacity: i
          }), e();
        });
      });
    }

    t.exports = {
      enterScaleIn: function enterScaleIn(t) {
        var e = t.item;
        t.element.isItemContainer && e.getKeyShape() && i(e);
      },
      showScaleIn: function showScaleIn(t) {
        var e = t.item;
        t.element.isItemContainer && e.getKeyShape() && i(e);
      },
      leaveScaleOut: function leaveScaleOut(t) {
        var e = t.item,
            n = t.element,
            r = t.done;
        n.isItemContainer && a(e, function () {
          r();
        });
      },
      hideScaleOut: function hideScaleOut(t) {
        var e = t.item,
            n = t.element,
            r = t.done;
        n.isItemContainer && a(e, function () {
          r();
        });
      },
      enterFadeIn: function enterFadeIn(t) {
        var e = t.element,
            n = t.item;
        e.isItemContainer && n.getKeyShape() && o(e);
      },
      showFadeIn: function showFadeIn(t) {
        var e = t.element,
            n = t.item;
        e.isItemContainer && n.getKeyShape() && o(e);
      },
      leaveFadeOut: function leaveFadeOut(t) {
        var e = t.element,
            n = t.item,
            r = t.done;
        e.isItemContainer && n.getKeyShape() && s(e, r);
      },
      hideFadeOut: function hideFadeOut(t) {
        var e = t.element,
            n = t.item,
            r = t.done;
        e.isItemContainer && n.getKeyShape() && s(e, r);
      }
    };
  }, function (t, e, n) {
    function r(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : t[e] = n, t;
    }

    var i = n(599),
        a = n(693),
        o = n(26),
        s = n(247),
        u = ["matrix", "fillStyle", "strokeStyle", "endArrow", "startArrow"],
        c = function (t) {
      function e() {
        return t.apply(this, arguments) || this;
      }

      !function (t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
      }(e, t);
      var n = e.prototype;
      return n.getDefaultCfg = function () {
        return {
          show: "scaleIn",
          hide: "scaleOut",
          enter: "scaleIn",
          leave: "scaleOut",
          update: function update(t) {
            var e = t.element,
                n = t.endKeyFrame.props;
            e.animate(function (t) {
              for (var e = 1; e < arguments.length; e++) {
                var n = null != arguments[e] ? arguments[e] : {},
                    i = Object.keys(n);
                "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter(function (t) {
                  return Object.getOwnPropertyDescriptor(n, t).enumerable;
                }))), i.forEach(function (e) {
                  r(t, e, n[e]);
                });
              }

              return t;
            }({
              matrix: n.matrix
            }, n.attrs), s.updateDuration, s.updateEasing);
          },
          graph: null,
          startCache: {},
          endCache: {},
          keykeyCache: {}
        };
      }, n._init = function () {
        var t = this,
            e = this.graph,
            n = this.keykeyCache;
        e.on("afteritemdraw", function (e) {
          e.item.getGraphicGroup().deepEach(function (e) {
            n[e.gid] = t._getCache(e);
          }, !0);
        });
      }, n.cacheGraph = function (t, e) {
        var n,
            r = this,
            i = this.graph;
        n = e ? e.map(function (t) {
          return i.find(t);
        }) : i.getItems(), this[t] = {}, n.forEach(function (e) {
          e && r.cache(e, r[t], t);
        });
      }, n._getCache = function (t) {
        var e = this.keykeyCache;
        if (!o.isObject(t)) return e[t];
        var n = {
          props: {
            matrix: o.clone(t.getMatrix()),
            attrs: {}
          }
        };

        if (t.isShape) {
          var r = t.attr();
          r = o.omit(r, u), n.props.attrs = o.clone(r);
        }

        return n;
      }, n._getAnimation = function (t, e) {
        var n = this.graph,
            r = t.shapeObj,
            i = this[e],
            s = r[e + "Animation"] || r[e + "Animate"],
            u = n.get("_" + e + "Animation"),
            c = s || u || i;
        return o.isString(c) ? a[e + o.upperFirst(c)] : c;
      }, n.cache = function (t, e, n) {
        var r = this;
        t.getGraphicGroup().deepEach(function (i) {
          var a = i.gid,
              o = "startCache" === n ? r._getCache(i) : r._getCache(i.gid);
          o.enterAnimate = r._getAnimation(t, "enter"), o.leaveAnimate = r._getAnimation(t, "leave"), o.showAnimate = r._getAnimation(t, "show"), o.hideAnimate = r._getAnimation(t, "hide"), o.updateAnimate = r._getAnimation(t, "update"), o.item = t, o.element = i, o.visible = i.get("visible"), e[a] = o;
        }, !0);
      }, n._compare = function () {
        var t = this.startCache,
            e = this.endCache,
            n = [],
            r = [],
            i = [],
            a = [],
            s = [];
        o.each(e, function (e, r) {
          var o = t[r];
          o ? o.element.get("type") === e.element.get("type") && (o.visible && e.visible ? i.push(r) : o.visible && !e.visible ? a.push(r) : !o.visible && e.visible && s.push(r)) : n.push(r);
        }), o.each(t, function (t, n) {
          e[n] || r.push(n);
        }), this.enterElements = n, this.leaveElements = r, this.updateElements = i, this.hideElements = a, this.showElements = s;
      }, n._addTween = function () {
        var t = this.enterElements,
            e = this.leaveElements,
            n = this.updateElements,
            r = this.hideElements,
            i = this.showElements,
            a = this.startCache,
            s = this.endCache;
        t.forEach(function (t) {
          var e = s[t],
              n = e.enterAnimate;
          n && n({
            element: e.element,
            item: e.item,
            endKeyFrame: e,
            startKeyFrame: null,
            startCache: a,
            endCache: s,
            done: function done() {}
          });
        }), e.forEach(function (t) {
          var e = a[t],
              n = e.leaveAnimate;

          if (n) {
            var r = a[t].element;
            r.isItemContainer && r.getParent().add(r), n({
              element: r,
              item: e.item,
              endKeyFrame: null,
              startKeyFrame: e,
              startCache: a,
              endCache: s,
              done: function done() {
                r.isItemContainer && r.remove();
              }
            });
          }
        }), n.forEach(function (t) {
          var e = s[t],
              n = a[t],
              r = e.element,
              i = n.element,
              u = n.props,
              c = e.props,
              h = e.updateAnimate;
          u.attrs && r.attr(u.attrs), o.isEqual(u.matrix, c.matrix) || r.setMatrix(u.matrix), h({
            element: r,
            item: e,
            endKeyFrame: e,
            startKeyFrame: n,
            startCache: a,
            endCache: s,
            done: function done() {}
          }), i !== r && i.remove();
        }), r.forEach(function (t) {
          var e = s[t],
              n = a[t],
              r = e.hideAnimate;
          r && (e.element.show(), r({
            element: e.element,
            item: e.item,
            endKeyFrame: e,
            startKeyFrame: n,
            startCache: a,
            endCache: s,
            done: function done() {
              var t = e.item,
                  n = t.getGraphicGroup();
              !t.visible && n.hide();
            }
          }));
        }), i.forEach(function (t) {
          var e = s[t],
              n = a[t],
              r = e.showAnimate;
          r && r({
            element: e.element,
            item: e.item,
            endKeyFrame: e,
            startKeyFrame: n,
            startCache: a,
            endCache: s,
            done: function done() {}
          });
        });
      }, n.run = function () {
        this.graph.destroyed || (this._compare(), this._addTween());
      }, e;
    }(i);

    t.exports = c;
  }, function (t, e, n) {
    function r(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : t[e] = n, t;
    }

    var i = n(26),
        a = n(694),
        o = {
      INIT: "_initAnimate",
      CFG: {
        animate: !1
      }
    };
    o.AUGMENT = {
      _initAnimate: function _initAnimate() {
        var t = this.get("animate");

        if (t) {
          var e = this.get("_controllers"),
              n = {
            graph: this
          };
          i.isPlainObject(t) && (n = function (t) {
            for (var e = 1; e < arguments.length; e++) {
              var n = null != arguments[e] ? arguments[e] : {},
                  i = Object.keys(n);
              "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter(function (t) {
                return Object.getOwnPropertyDescriptor(n, t).enumerable;
              }))), i.forEach(function (e) {
                r(t, e, n[e]);
              });
            }

            return t;
          }({}, n, t)), e.animate = new a(n);
        }
      }
    }, t.exports = o;
  }, function (t, e, n) {
    var r = n(26),
        i = {
      INIT: "_initFilter",
      CFG: {
        filters: []
      }
    };
    i.AUGMENT = {
      _initFilter: function _initFilter() {
        var t = this,
            e = this.get("filters");
        r.isFunction(e) && this.set("filters", [e]), this.on("afterchange", function (n) {
          var r = n.action;
          e.length > 0 && "changeData" === r && !t.destroyed && t.filter();
        });
      },
      addFilter: function addFilter(t) {
        return this.get("filters").push(t), t;
      },
      removeFilter: function removeFilter(t) {
        var e = this.get("filters");
        this.set("filters", r.filter(e, t));
      },
      filter: function filter() {
        this.emit("beforefilter");

        var t = this.get("filters"),
            e = this.getItems(),
            n = this._getFilterItems();

        t.forEach(function (t) {
          n = n.filter(t);
        }), e.forEach(function (t) {
          -1 === n.indexOf(t) ? t.hide() : t.show();
        }), this.draw(), this.emit("afterfilter");
      },
      _getFilterItems: function _getFilterItems() {
        return this.getItems().filter(function (t) {
          return !1 !== t.getShapeObj().filter;
        });
      }
    }, t.exports = i;
  }, function (t, e, n) {
    var r = n(26),
        i = n(626),
        a = {
      CFG: {
        modes: {
          default: []
        },
        mode: "default",
        _eventCache: {}
      },
      INIT: "_initModes"
    };
    a.AUGMENT = {
      _initModes: function _initModes() {
        var t = this.get("mode");
        this.changeMode(t);
      },
      changeMode: function changeMode(t) {
        var e = this.get("modes");
        r.isEmpty(e) || r.isEmpty(e[t]) || (i.resetMode(e[t], this), this.set("mode", t));
      },
      addBehaviour: function addBehaviour(t, e) {
        var n = this.get("modes");
        e = e || this.get("mode"), r.isEmpty(n[e]) && (n[e] = []);
        var a = n[e],
            o = [].concat(t);
        return r.each(o, function (t) {
          -1 === a.indexOf(t) && a.push(t);
        }), i.resetMode(n[e], this), this;
      },
      removeBehaviour: function removeBehaviour(t) {
        var e = this.get("modes"),
            n = this.get("mode"),
            a = e[n];

        if (!r.isEmpty(a)) {
          var o = [].concat(t);
          return a = a.filter(function (t) {
            return -1 === o.indexOf(t);
          }), e[n] = a, i.resetMode(a, this), this;
        }
      },
      behaviourOn: function behaviourOn(t, e) {
        var n = this._eventCache;
        n[t] || (n[t] = []), n[t].push(e), this.on(t, e);
      },
      _off: function _off() {
        var t = this,
            e = this._eventCache;
        r.each(e, function (e, n) {
          r.each(e, function (e) {
            t.off(n, e);
          });
        }), this._eventCache = {};
      }
    }, t.exports = a;
  }, function (t, e, n) {
    var r = n(599),
        i = n(26),
        a = {
      MOUSEMOVE: "mousemove",
      MOUSEDOWN: "mousedown",
      MOUSEUP: "mouseup",
      MOUSEENTER: "mouseenter",
      MOUSELEAVE: "mouseleave",
      CLICK: "click",
      DBLCLICK: "dblclick",
      DRAGSTART: "dragstart",
      DRAG: "drag",
      DRAGENTER: "dragenter",
      DRAGLEAVE: "dragleave",
      DRAGEND: "dragend",
      DROP: "drop",
      CONTEXTMENU: "contextmenu",
      WHEEL: "wheel",
      KEYDOWN: "keydown",
      KEYUP: "keyup",
      KEYPRESS: "keypress",
      MOUSEWHEEL: "mousewheel"
    },
        o = [a.DBLCLICK, a.MOUSEDOWN, a.MOUSEUP, a.MOUSEENTER, a.MOUSELEAVE, a.MOUSEMOVE, a.CONTEXTMENU, a.WHEEL, a.MOUSEWHEEL],
        s = [a.KEYDOWN, a.KEYUP, a.KEYPRESS];

    var u = function (t) {
      function e(e) {
        var n;
        return (n = t.call(this, e) || this)._domEvents = [], n._initEventStates(), n._registerEvents(), n;
      }

      !function (t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
      }(e, t);
      var n = e.prototype;
      return n._initEventStates = function () {
        this._pressing = !1, this._dragging = !1, this._currentEventObj = {}, this._dragEventObj = {};
      }, n._registerEvents = function () {
        this._registerMouseEvents(), this._registerKeyboardEvents();
      }, n._registerKeyboardEvents = function () {
        var t = this.graph,
            e = t.getKeyboardEventWrapper(),
            n = this._domEvents,
            r = t.get("keyboardEnable");
        i.each(s, function (a) {
          n.push(i.addEventListener(e, a, function (e) {
            var n = !0;
            i.isFunction(r) && (n = r()), n && t.emit(a, {
              domEvent: e
            });
          }));
        });
      }, n._registerMouseEvents = function () {
        var t = this,
            e = this,
            n = this.graph.getMouseEventWrapper(),
            r = this._domEvents;
        i.each(o, function (o) {
          r.push(i.addEventListener(n, o, function (n) {
            if (n.type !== a.MOUSEENTER || !n.fromElement || n.fromElement.parentNode && !function (t, e) {
              for (var n = t.parentNode; n;) {
                if (n.tagName === e) return !0;
                n = n.parentNode;
              }

              return !1;
            }(n.fromElement, "foreignObject")) {
              var r = t._currentEventObj;
              t._oldEventObj = r, t._processEventObj(n);
              var o = t._currentEventObj;
              e._simulateEvents(n, r, o), -1 !== [a.MOUSELEAVE, a.MOUSEENTER].indexOf(n.type) && e._triggerEvent("canvas:" + n.type), e._triggerEvent(n.type), n.type === a.MOUSELEAVE && (t._dragging && e._triggerEvent(a.DRAGLEAVE, i.mix({}, o, {
                item: null,
                shape: null,
                currentItem: t._dragEventObj.item,
                currentShape: t._dragEventObj.shape
              })), e._initEventStates());
            }
          }));
        });
      }, n.destroy = function () {
        var t = this._domEvents;
        i.each(t, function (t) {
          t && t.remove();
        }), this._domEvents = null;
      }, n._triggerEvent = function (t, e) {
        if (e || (e = "mouseleave" === t ? this._oldEventObj : this._currentEventObj), "mousedown" === t && (e.button = this._button), e._type = t, this.emitGraphEvent(t, e), -1 === ["canvas:" + a.MOUSELEAVE, "canvas:" + a.MOUSEENTER].indexOf(t)) {
          var n = e.shape && e.shape.eventPreFix;

          if (-1 !== [a.DRAGSTART, a.DRAG, a.DRAGEND].indexOf(t) && (n = e.currentShape && e.currentShape.eventPreFix), n) {
            var r = n + ":" + t;
            e._type = r, i.isBoolean(e._isItemChange) ? e._isItemChange && this.emitGraphEvent(r, e) : this.emitGraphEvent(r, e);
          }
        }
      }, n.emitGraphEvent = function (t, e) {
        this.graph.emit(t, e);
      }, n._getDistanceToPress = function (t) {
        return Math.pow(t.clientX - this._pressX, 2) + Math.pow(t.clientY - this._pressY, 2);
      }, n._simulateEvents = function (t, e, n) {
        void 0 === e && (e = {}), void 0 === n && (n = {});
        var r = this._dragEventObj.item,
            o = this._dragEventObj.shape;

        switch (t.type) {
          case a.MOUSEDOWN:
            this._pressing = !0, this._button = t.button, this._pressX = t.clientX, this._pressY = t.clientY;
            break;

          case a.MOUSEMOVE:
            if (this._dragging) {
              if (this._triggerEvent(a.DRAG, i.mix({}, n, {
                button: this._button,
                currentItem: r,
                currentShape: o
              })), e.shape !== n.shape) {
                var s = this._isItemChange(e, n);

                e.shape && this._triggerEvent(a.DRAGLEAVE, i.mix({}, n, {
                  button: this._button,
                  item: e.item,
                  shape: e.shape,
                  toItem: n.item,
                  toShape: n.shape,
                  currentItem: r,
                  currentShape: o,
                  _isItemChange: s
                })), n.shape && this._triggerEvent(a.DRAGENTER, i.mix({}, n, {
                  button: this._button,
                  currentItem: r,
                  currentShape: o,
                  fromItem: e.item,
                  fromShape: e.shape,
                  _isItemChange: s
                }));
              }
            } else this._pressing && this._getDistanceToPress(t) > 9 && (this._dragging = !0, this._dragEventObj = e, r = this._dragEventObj.item, o = this._dragEventObj.shape, this._triggerEvent(a.DRAGSTART, i.mix({}, e, {
              button: this._button,
              currentItem: r,
              currentShape: o
            })));

            if (e.shape !== n.shape) {
              var u = this._isItemChange(e, n);

              e.shape && this._triggerEvent(a.MOUSELEAVE, i.mix({}, n, {
                item: e.item,
                shape: e.shape,
                toItem: n.item,
                toShape: n.shape,
                _isItemChange: u
              })), n.shape && this._triggerEvent(a.MOUSEENTER, i.mix({}, n, {
                fromtItem: e.item,
                fromShape: e.shape,
                _isItemChange: u
              }));
            }

            break;

          case a.MOUSEUP:
            !this._dragging && this._pressing ? this._triggerEvent(a.CLICK, i.mix({}, n, {
              button: this._button
            })) : (this._triggerEvent(a.DROP, i.mix({}, n, {
              button: this._button,
              currentItem: r,
              currentShape: o
            })), this._triggerEvent(a.DRAGEND, i.mix({}, n, {
              button: this._button,
              currentItem: r,
              currentShape: o
            }))), this._pressing = !1, this._dragging = !1, this._dragEventObj = {};
            break;

          default:
            return;
        }
      }, n._isItemChange = function (t, e) {
        var n = t.shape,
            r = e.shape,
            a = n && r && (n.get("isItemChange") || r.get("isItemChange"));
        return a ? a(r, n) : i.isObject(t.item) && i.isObject(e.item) ? t.item.id !== e.item.id : t.item !== e.item;
      }, n._processEventObj = function (t) {
        var e = this.graph.get("_canvas"),
            n = this._getEventObj(t, e);

        this._currentEventObj = n;
      }, n._parsePoint = function (t, e) {
        return this.graph.getPointByCanvas({
          x: t,
          y: e
        });
      }, n._getEventObj = function (t, e) {
        var n = this.graph,
            r = t.clientX,
            i = t.clientY,
            a = e.getPointByClient(r, i),
            o = this._parsePoint(a.x, a.y),
            s = e.getShape(a.x, a.y, t),
            u = n.getItemByShape(s),
            c = e.get("pixelRatio");

        return {
          item: u,
          shape: s,
          x: o.x,
          y: o.y,
          domX: a.x / c,
          domY: a.y / c,
          domEvent: t
        };
      }, e;
    }(r);

    t.exports = u;
  }, function (t, e, n) {
    var r = {},
        i = n(698);
    r.INIT = "_initEvents", r.CFG = {
      keyboardEnable: !0
    }, r.AUGMENT = {
      _initEvents: function _initEvents() {
        this.get("_controllers").events = new i({
          graph: this
        });
      }
    }, t.exports = r;
  }, function (t, e, n) {
    var r = n(26),
        i = {};
    i.AUGMENT = {
      find: function find(t) {
        return this.get("_itemMap")[t];
      },
      getNodes: function getNodes() {
        return this.get("_itemMap")._nodes;
      },
      getEdges: function getEdges() {
        return this.get("_itemMap")._edges;
      },
      getGroups: function getGroups() {
        return this.get("_itemMap")._groups;
      },
      getGuides: function getGuides() {
        return this.get("_itemMap")._guides;
      },
      getItems: function getItems() {
        var t = this.get("_itemMap"),
            e = [];
        return r.each(t, function (t) {
          t.type && e.push(t);
        }), e;
      },
      getItemByShape: function getItemByShape(t) {
        return t ? this.getItem(t.id) : null;
      },
      getItem: function getItem(t) {
        var e = this.get("_itemMap");
        return r.isObject(t) ? t.destroyed && (t = e[t.id]) : t = e[t], t;
      }
    }, t.exports = i;
  }, function (t, e, n) {
    var r = n(599),
        i = n(26),
        a = ["color", "shape", "size", "label", "style"],
        o = function (t) {
      function e() {
        return t.apply(this, arguments) || this;
      }

      !function (t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
      }(e, t);
      var n = e.prototype;
      return n._init = function () {
        var t = this,
            e = {};
        i.each(a, function (n) {
          e[n] = {}, t[n] = function (r) {
            return e[n].input = r, t;
          };
        }), this.channels = e;
      }, n.addChannels = function (t) {
        var e = this.channels;
        i.each(t, function (t, n) {
          e[n] = {
            input: t
          };
        });
      }, n.mapping = function (t) {
        var e = this.channels;
        i.each(e, function (e, n) {
          i.isFunction(e.input) ? t[n] = e.input(t) : e.input && (t[n] = e.input);
        });
      }, e;
    }(r);

    t.exports = o;
  }, function (t, e, n) {
    var r = n(701),
        i = {
      INIT: "_initMapper"
    };
    i.AUGMENT = {
      _initMapper: function _initMapper() {
        var t = this.get("_controllers");
        t.nodeMapper = new r({
          graph: this
        }), t.edgeMapper = new r({
          graph: this
        }), t.groupMapper = new r({
          graph: this
        }), t.guideMapper = new r({
          graph: this
        });
      },
      node: function node(t) {
        var e = this._getController("nodeMapper");

        return t && e.addChannels(t), e;
      },
      edge: function edge(t) {
        var e = this._getController("edgeMapper");

        return t && e.addChannels(t), e;
      },
      group: function group(t) {
        var e = this._getController("groupMapper");

        return t && e.addChannels(t), this._getController("groupMapper");
      },
      guide: function guide(t) {
        var e = this._getController("guideMapper");

        return t && e.addChannels(t), this._getController("guideMapper");
      }
    }, t.exports = i;
  }, function (t, e, n) {
    var r = function (t) {
      function e() {
        return t.apply(this, arguments) || this;
      }

      !function (t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
      }(e, t);
      var n = e.prototype;
      return n.getDefaultCfg = function () {
        return {
          graph: null,
          auto: !0,
          processor: null
        };
      }, n._init = function () {
        var t = this,
            e = this.graph;
        e.on("afteritemdraw", function (t) {
          var e = t.item,
              n = e.getKeyShape(),
              r = e.getModel();
          if (e.isEdge) r.lineWidth = n.attr("lineWidth");else if (e.isNode || e.isGroup) {
            var i = e.getBBox();
            r.width = i.width, r.height = i.height;
          }
        }), e.on("afterchange", function (n) {
          var r = n.action;
          "once" === t.auto ? "changeData" === r && (e.destroyed || e.preventAnimate(function () {
            t.layout();
          })) : t.auto && !e.destroyed && e.preventAnimate(function () {
            t.layout();
          });
        });
      }, n.changeLayout = function (t) {
        this.processor = t, this.layout();
      }, n.layout = function () {
        var t = this.graph,
            e = this.getLayoutProcessor();
        t.emit("beforelayout");
        var n = t.getNodes().filter(function (t) {
          return t.isVisible();
        }).map(function (t) {
          return t.getModel();
        }),
            r = t.getEdges().filter(function (t) {
          return t.isVisible();
        }).map(function (t) {
          return t.getModel();
        }),
            i = t.getGroups().filter(function (t) {
          return t.isVisible();
        }).map(function (t) {
          return t.getModel();
        });
        t._executeLayout(e, n, r, i), t.updateNodePosition(), t.emit("afterlayout");
      }, n.getLayoutProcessor = function () {
        return this.processor ? this.processor : this.processer;
      }, e;
    }(n(599));

    t.exports = r;
  }, function (t, e, n) {
    var r = n(26),
        i = n(703),
        a = {
      CFG: {
        layout: void 0
      },
      INIT: "_initLayout"
    };
    a.AUGMENT = {
      _initLayout: function _initLayout() {
        var t = this.get("_controllers"),
            e = this._getLayoutCfg();

        e && (t.layout = new i(r.mix({
          graph: this
        }, e)));
      },
      _getLayoutCfg: function _getLayoutCfg() {
        var t = this.get("layout");
        return r.isPlainObject(t) ? t : r.isFunction(t) || r.isObject(t) ? {
          processor: t
        } : null;
      },
      layout: function layout() {
        return this._getController("layout").layout(), this;
      },
      updateNodePosition: function updateNodePosition(t) {
        var e = this.getGuides(),
            n = [],
            i = [];
        return this.emit("beforeupdatenodeposition"), t ? (t.forEach(function (t) {
          t.getEdges().forEach(function (t) {
            i.push(t);
          });
          var e = t.getParent();
          e && n.push(e);
        }), i = r.uniq(i), n = r.uniq(n)) : (t = this.getNodes(), n = this.getGroups(), i = this.getEdges()), t.forEach(function (t) {
          t.layoutUpdate();
        }), n.forEach(function (t) {
          t.layoutUpdate();
        }), i.forEach(function (t) {
          t.layoutUpdate();
        }), e.forEach(function (t) {
          t.layoutUpdate();
        }), this.emit("afterupdatenodeposition"), this;
      },
      changeLayout: function changeLayout(t) {
        return this._getController("layout").changeLayout(t), this;
      },
      getLayout: function getLayout() {
        return this._getController("layout").getLayoutProcessor();
      }
    }, t.exports = a;
  }, function (t, e, n) {
    !function (e) {
      "use strict";

      var n = function () {
        return {
          escape: function escape(t) {
            return t.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
          },
          parseExtension: t,
          mimeType: function mimeType(e) {
            var n = t(e).toLowerCase();
            return function () {
              var t = "application/font-woff";
              return {
                woff: t,
                woff2: t,
                ttf: "application/font-truetype",
                eot: "application/vnd.ms-fontobject",
                png: "image/png",
                jpg: "image/jpeg",
                jpeg: "image/jpeg",
                gif: "image/gif",
                tiff: "image/tiff",
                svg: "image/svg+xml"
              };
            }()[n] || "";
          },
          dataAsUrl: function dataAsUrl(t, e) {
            return "data:" + e + ";base64," + t;
          },
          isDataUrl: function isDataUrl(t) {
            return -1 !== t.search(/^(data:)/);
          },
          canvasToBlob: function canvasToBlob(t) {
            return t.toBlob ? new Promise(function (e) {
              t.toBlob(e);
            }) : function (t) {
              return new Promise(function (e) {
                for (var n = window.atob(t.toDataURL().split(",")[1]), r = n.length, i = new Uint8Array(r), a = 0; a < r; a++) {
                  i[a] = n.charCodeAt(a);
                }

                e(new Blob([i], {
                  type: "image/png"
                }));
              });
            }(t);
          },
          resolveUrl: function resolveUrl(t, e) {
            var n = document.implementation.createHTMLDocument(),
                r = n.createElement("base");
            n.head.appendChild(r);
            var i = n.createElement("a");
            return n.body.appendChild(i), r.href = e, i.href = t, i.href;
          },
          getAndEncode: function getAndEncode(t) {
            var e = 3e4;
            s.impl.options.cacheBust && (t += (/\?/.test(t) ? "&" : "?") + new Date().getTime());
            return new Promise(function (n) {
              var r,
                  i = new XMLHttpRequest();

              if (i.onreadystatechange = function () {
                if (4 !== i.readyState) return;
                if (200 !== i.status) return void (r ? n(r) : o("cannot fetch resource: " + t + ", status: " + i.status));
                var e = new FileReader();
                e.onloadend = function () {
                  var t = e.result.split(/,/)[1];
                  n(t);
                }, e.readAsDataURL(i.response);
              }, i.ontimeout = function () {
                r ? n(r) : o("timeout of " + e + "ms occured while fetching resource: " + t);
              }, i.responseType = "blob", i.timeout = e, i.open("GET", t, !0), i.send(), s.impl.options.imagePlaceholder) {
                var a = s.impl.options.imagePlaceholder.split(/,/);
                a && a[1] && (r = a[1]);
              }

              function o(t) {
                console.error(t), n("");
              }
            });
          },
          uid: function () {
            var t = 0;
            return function () {
              return "u" + ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4) + t++;
            };
          }(),
          delay: function delay(t) {
            return function (e) {
              return new Promise(function (n) {
                setTimeout(function () {
                  n(e);
                }, t);
              });
            };
          },
          asArray: function asArray(t) {
            for (var e = [], n = t.length, r = 0; r < n; r++) {
              e.push(t[r]);
            }

            return e;
          },
          escapeXhtml: function escapeXhtml(t) {
            return t.replace(/#/g, "%23").replace(/\n/g, "%0A");
          },
          makeImage: function makeImage(t) {
            return new Promise(function (e, n) {
              var r = new Image();
              r.onload = function () {
                e(r);
              }, r.onerror = n, r.src = t;
            });
          },
          width: function width(t) {
            var n = e(t, "border-left-width"),
                r = e(t, "border-right-width");
            return t.scrollWidth + n + r;
          },
          height: function height(t) {
            var n = e(t, "border-top-width"),
                r = e(t, "border-bottom-width");
            return t.scrollHeight + n + r;
          }
        };

        function t(t) {
          var e = /\.([^\.\/]*?)$/g.exec(t);
          return e ? e[1] : "";
        }

        function e(t, e) {
          var n = window.getComputedStyle(t).getPropertyValue(e);
          return parseFloat(n.replace("px", ""));
        }
      }(),
          r = function () {
        var t = /url\(['"]?([^'"]+?)['"]?\)/g;
        return {
          inlineAll: function inlineAll(t, n, a) {
            return e(t) ? Promise.resolve(t).then(r).then(function (e) {
              var r = Promise.resolve(t);
              return e.forEach(function (t) {
                r = r.then(function (e) {
                  return i(e, t, n, a);
                });
              }), r;
            }) : Promise.resolve(t);
          },
          shouldProcess: e,
          impl: {
            readUrls: r,
            inline: i
          }
        };

        function e(e) {
          return -1 !== e.search(t);
        }

        function r(e) {
          for (var r, i = []; null !== (r = t.exec(e));) {
            i.push(r[1]);
          }

          return i.filter(function (t) {
            return !n.isDataUrl(t);
          });
        }

        function i(t, e, r, i) {
          return Promise.resolve(e).then(function (t) {
            return r ? n.resolveUrl(t, r) : t;
          }).then(i || n.getAndEncode).then(function (t) {
            return n.dataAsUrl(t, n.mimeType(e));
          }).then(function (r) {
            return t.replace(function (t) {
              return new RegExp("(url\\(['\"]?)(" + n.escape(t) + ")(['\"]?\\))", "g");
            }(e), "$1" + r + "$3");
          });
        }
      }(),
          i = function () {
        return {
          resolveAll: function resolveAll() {
            return t(document).then(function (t) {
              return Promise.all(t.map(function (t) {
                return t.resolve();
              }));
            }).then(function (t) {
              return t.join("\n");
            });
          },
          impl: {
            readAll: t
          }
        };

        function t() {
          return Promise.resolve(n.asArray(document.styleSheets)).then(function (t) {
            var e = [];
            return t.forEach(function (t) {
              try {
                n.asArray(t.cssRules || []).forEach(e.push.bind(e));
              } catch (e) {
                console.log("Error while reading CSS rules from " + t.href, e.toString());
              }
            }), e;
          }).then(function (t) {
            return t.filter(function (t) {
              return t.type === CSSRule.FONT_FACE_RULE;
            }).filter(function (t) {
              return r.shouldProcess(t.style.getPropertyValue("src"));
            });
          }).then(function (e) {
            return e.map(t);
          });

          function t(t) {
            return {
              resolve: function resolve() {
                var e = (t.parentStyleSheet || {}).href;
                return r.inlineAll(t.cssText, e);
              },
              src: function src() {
                return t.style.getPropertyValue("src");
              }
            };
          }
        }
      }(),
          a = function () {
        return {
          inlineAll: function e(i) {
            if (!(i instanceof Element)) return Promise.resolve(i);
            return function (t) {
              var e = t.style.getPropertyValue("background");
              return e ? r.inlineAll(e).then(function (e) {
                t.style.setProperty("background", e, t.style.getPropertyPriority("background"));
              }).then(function () {
                return t;
              }) : Promise.resolve(t);
            }(i).then(function () {
              return i instanceof HTMLImageElement ? t(i).inline() : Promise.all(n.asArray(i.childNodes).map(function (t) {
                return e(t);
              }));
            });
          },
          impl: {
            newImage: t
          }
        };

        function t(t) {
          return {
            inline: function inline(e) {
              return n.isDataUrl(t.src) ? Promise.resolve() : Promise.resolve(t.src).then(e || n.getAndEncode).then(function (e) {
                return n.dataAsUrl(e, n.mimeType(t.src));
              }).then(function (e) {
                return new Promise(function (n, r) {
                  t.onload = n, t.onerror = r, t.src = e;
                });
              });
            }
          };
        }
      }(),
          o = {
        imagePlaceholder: void 0,
        cacheBust: !1
      },
          s = {
        toSvg: u,
        toPng: function toPng(t, e) {
          return c(t, e || {}).then(function (t) {
            return t.toDataURL();
          });
        },
        toJpeg: function toJpeg(t, e) {
          return c(t, e = e || {}).then(function (t) {
            return t.toDataURL("image/jpeg", e.quality || 1);
          });
        },
        toBlob: function toBlob(t, e) {
          return c(t, e || {}).then(n.canvasToBlob);
        },
        toPixelData: function toPixelData(t, e) {
          return c(t, e || {}).then(function (e) {
            return e.getContext("2d").getImageData(0, 0, n.width(t), n.height(t)).data;
          });
        },
        impl: {
          fontFaces: i,
          images: a,
          util: n,
          inliner: r,
          options: {}
        }
      };

      function u(t, e) {
        return function (t) {
          void 0 === t.imagePlaceholder ? s.impl.options.imagePlaceholder = o.imagePlaceholder : s.impl.options.imagePlaceholder = t.imagePlaceholder;
          void 0 === t.cacheBust ? s.impl.options.cacheBust = o.cacheBust : s.impl.options.cacheBust = t.cacheBust;
        }(e = e || {}), Promise.resolve(t).then(function (t) {
          return function (t, e, r) {
            if (!r && e && !e(t)) return Promise.resolve();
            return Promise.resolve(t).then(function (t) {
              return t instanceof HTMLCanvasElement ? n.makeImage(t.toDataURL()) : t.cloneNode(!1);
            }).then(function (r) {
              return function (t, e, r) {
                var i = t.childNodes;
                return 0 === i.length ? Promise.resolve(e) : function (t, e, n) {
                  var r = Promise.resolve();
                  return e.forEach(function (e) {
                    r = r.then(function () {
                      return h(e, n);
                    }).then(function (e) {
                      e && t.appendChild(e);
                    });
                  }), r;
                }(e, n.asArray(i), r).then(function () {
                  return e;
                });
              }(t, r, e);
            }).then(function (e) {
              return function (t, e) {
                return e instanceof Element ? Promise.resolve().then(function () {
                  !function (t, e) {
                    t.cssText ? e.cssText = t.cssText : function (t, e) {
                      n.asArray(t).forEach(function (n) {
                        e.setProperty(n, t.getPropertyValue(n), t.getPropertyPriority(n));
                      });
                    }(t, e);
                  }(window.getComputedStyle(t), e.style);
                }).then(function () {
                  [":before", ":after"].forEach(function (r) {
                    !function (r) {
                      var i = window.getComputedStyle(t, r),
                          a = i.getPropertyValue("content");

                      if ("" !== a && "none" !== a) {
                        var o = n.uid();
                        e.className = e.className + " " + o;
                        var s = document.createElement("style");
                        s.appendChild(function (t, e, r) {
                          var i = "." + t + ":" + e,
                              a = r.cssText ? function (t) {
                            var e = t.getPropertyValue("content");
                            return t.cssText + " content: " + e + ";";
                          }(r) : function (t) {
                            return n.asArray(t).map(function (e) {
                              return e + ": " + t.getPropertyValue(e) + (t.getPropertyPriority(e) ? " !important" : "");
                            }).join("; ") + ";";
                          }(r);
                          return document.createTextNode(i + "{" + a + "}");
                        }(o, r, i)), e.appendChild(s);
                      }
                    }(r);
                  });
                }).then(function () {
                  t instanceof HTMLTextAreaElement && (e.innerHTML = t.value), t instanceof HTMLInputElement && e.setAttribute("value", t.value);
                }).then(function () {
                  e instanceof SVGElement && (e.setAttribute("xmlns", "http://www.w3.org/2000/svg"), e instanceof SVGRectElement && ["width", "height"].forEach(function (t) {
                    var n = e.getAttribute(t);
                    n && e.style.setProperty(t, n);
                  }));
                }).then(function () {
                  return e;
                }) : e;
              }(t, e);
            });
          }(t, e.filter, !0);
        }).then(f).then(l).then(function (t) {
          e.bgcolor && (t.style.backgroundColor = e.bgcolor);
          e.width && (t.style.width = e.width + "px");
          e.height && (t.style.height = e.height + "px");
          e.style && Object.keys(e.style).forEach(function (n) {
            t.style[n] = e.style[n];
          });
          return t;
        }).then(function (r) {
          return function (t, e, r) {
            return Promise.resolve(t).then(function (t) {
              return t.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), new XMLSerializer().serializeToString(t);
            }).then(n.escapeXhtml).then(function (t) {
              return '<foreignObject x="0" y="0" width="100%" height="100%">' + t + "</foreignObject>";
            }).then(function (t) {
              return '<svg xmlns="http://www.w3.org/2000/svg" width="' + e + '" height="' + r + '">' + t + "</svg>";
            }).then(function (t) {
              return "data:image/svg+xml;charset=utf-8," + t;
            });
          }(r, e.width || n.width(t), e.height || n.height(t));
        });
      }

      function c(t, e) {
        return u(t, e).then(n.makeImage).then(n.delay(100)).then(function (r) {
          var i = function (t) {
            var r = document.createElement("canvas");

            if (r.width = e.width || n.width(t), r.height = e.height || n.height(t), e.bgcolor) {
              var i = r.getContext("2d");
              i.fillStyle = e.bgcolor, i.fillRect(0, 0, r.width, r.height);
            }

            return r;
          }(t);

          return i.getContext("2d").drawImage(r, 0, 0), i;
        });
      }

      function h(t, e, r) {
        if (!r && e && !e(t)) return Promise.resolve();
        return Promise.resolve(t).then(i).then(function (n) {
          return a(t, n, e);
        }).then(function (e) {
          return o(t, e);
        });

        function i(t) {
          return t instanceof HTMLCanvasElement ? n.makeImage(t.toDataURL()) : t.cloneNode(!1);
        }

        function a(t, e, r) {
          var i = t.childNodes;
          return 0 === i.length ? Promise.resolve(e) : function (t, e, n) {
            var r = Promise.resolve();
            return e.forEach(function (e) {
              r = r.then(function () {
                return h(e, n);
              }).then(function (e) {
                e && t.appendChild(e);
              });
            }), r;
          }(e, n.asArray(i), r).then(function () {
            return e;
          });

          function a(t, e, n) {
            var r = Promise.resolve();
            return e.forEach(function (e) {
              r = r.then(function () {
                return h(e, n);
              }).then(function (e) {
                e && t.appendChild(e);
              });
            }), r;
          }
        }

        function o(t, e) {
          return e instanceof Element ? Promise.resolve().then(function () {
            !function (t, e) {
              t.cssText ? e.cssText = t.cssText : function (t, e) {
                n.asArray(t).forEach(function (n) {
                  e.setProperty(n, t.getPropertyValue(n), t.getPropertyPriority(n));
                });
              }(t, e);
            }(window.getComputedStyle(t), e.style);
          }).then(function () {
            [":before", ":after"].forEach(function (r) {
              !function (r) {
                var i = window.getComputedStyle(t, r),
                    a = i.getPropertyValue("content");
                if ("" === a || "none" === a) return;
                var o = n.uid();
                e.className = e.className + " " + o;
                var s = document.createElement("style");
                s.appendChild(function (t, e, r) {
                  var i = "." + t + ":" + e,
                      a = r.cssText ? function (t) {
                    var e = t.getPropertyValue("content");
                    return t.cssText + " content: " + e + ";";
                  }(r) : function (t) {
                    return n.asArray(t).map(function (e) {
                      return e + ": " + t.getPropertyValue(e) + (t.getPropertyPriority(e) ? " !important" : "");
                    }).join("; ") + ";";
                  }(r);
                  return document.createTextNode(i + "{" + a + "}");
                }(o, r, i)), e.appendChild(s);
              }(r);
            });
          }).then(function () {
            t instanceof HTMLTextAreaElement && (e.innerHTML = t.value);
            t instanceof HTMLInputElement && e.setAttribute("value", t.value);
          }).then(function () {
            if (!(e instanceof SVGElement)) return;
            if (e.setAttribute("xmlns", "http://www.w3.org/2000/svg"), !(e instanceof SVGRectElement)) return;
            ["width", "height"].forEach(function (t) {
              var n = e.getAttribute(t);
              n && e.style.setProperty(t, n);
            });
          }).then(function () {
            return e;
          }) : e;

          function r() {
            function r(t, e) {
              if (t.cssText) e.cssText = t.cssText;else r(t, e);

              function r(t, e) {
                n.asArray(t).forEach(function (n) {
                  e.setProperty(n, t.getPropertyValue(n), t.getPropertyPriority(n));
                });
              }
            }

            r(window.getComputedStyle(t), e.style);
          }

          function i() {
            function r(r) {
              var i = window.getComputedStyle(t, r),
                  a = i.getPropertyValue("content");
              if (a === "" || a === "none") return;
              var o = n.uid();
              e.className = e.className + " " + o;
              var s = document.createElement("style");

              function u(t, e, r) {
                var i = "." + t + ":" + e,
                    a = r.cssText ? o(r) : s(r);
                return document.createTextNode(i + "{" + a + "}");

                function o(t) {
                  var e = t.getPropertyValue("content");
                  return t.cssText + " content: " + e + ";";
                }

                function s(t) {
                  return n.asArray(t).map(e).join("; ") + ";";

                  function e(e) {
                    return e + ": " + t.getPropertyValue(e) + (t.getPropertyPriority(e) ? " !important" : "");
                  }
                }
              }

              s.appendChild(u(o, r, i)), e.appendChild(s);
            }

            [":before", ":after"].forEach(function (t) {
              r(t);
            });
          }

          function a() {
            if (t instanceof HTMLTextAreaElement) e.innerHTML = t.value;
            if (t instanceof HTMLInputElement) e.setAttribute("value", t.value);
          }

          function o() {
            if (!(e instanceof SVGElement)) return;
            if (e.setAttribute("xmlns", "http://www.w3.org/2000/svg"), !(e instanceof SVGRectElement)) return;
            ["width", "height"].forEach(function (t) {
              var n = e.getAttribute(t);
              if (!n) return;
              e.style.setProperty(t, n);
            });
          }
        }
      }

      function f(t) {
        return i.resolveAll().then(function (e) {
          var n = document.createElement("style");
          return t.appendChild(n), n.appendChild(document.createTextNode(e)), t;
        });
      }

      function l(t) {
        return a.inlineAll(t).then(function () {
          return t;
        });
      }

      t.exports = s;
    }();
  }, function (t, e, n) {
    function r(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : t[e] = n, t;
    }

    var i = n(26),
        a = n(248),
        o = n(705),
        s = function () {
      function t(t) {
        this.options = function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = null != arguments[e] ? arguments[e] : {},
                i = Object.keys(n);
            "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter(function (t) {
              return Object.getOwnPropertyDescriptor(n, t).enumerable;
            }))), i.forEach(function (e) {
              r(t, e, n[e]);
            });
          }

          return t;
        }({
          graph: null,
          width: null,
          height: null,
          canvas: null,
          beforeTransform: function beforeTransform() {},
          afterTransform: function afterTransform() {},
          drawCount: 0
        }, t);
      }

      var e = t.prototype;
      return e.getCanvas = function () {
        var t = this.options,
            e = t.width,
            n = t.height,
            r = t.canvas;

        if (!r) {
          var o = i.createDOM("<canvas></canvas>");
          r = new a.Canvas({
            containerDOM: o,
            width: e,
            height: n
          });
        }

        return r.drawCount || (r.drawCount = 0), r;
      }, e.drawInner = function (t, e) {
        var n = this.options.graph,
            r = n.getCanvas(),
            i = n.get("renderer"),
            a = t.drawCount;

        if ("svg" === i) {
          var s = [];
          r.deepEach(function (t) {
            "dom" === t.get("type") && s.push(t);
          }), s.length > 0 ? s.forEach(function (n) {
            var r = n.get("el");

            if (r) {
              n.domImageOnload = !1;
              var i = n.attr("width"),
                  u = n.attr("height");
              o.toPng(r, {
                width: i,
                height: u
              }).then(function (r) {
                var i = new Image();
                i.src = r, i.onload = function () {
                  if (a === t.drawCount - 1) {
                    n.domImage = i, n.domImageOnload = !0;

                    for (var r = 0; r < s.length; r++) {
                      var o = s[r];
                      if (!o.domImageOnload || o.get("destroyed")) break;
                      o.domImageOnload && r === s.length - 1 && e();
                    }
                  }
                };
              });
            }
          }) : e();
        } else e();

        t.drawCount += 1;
      }, e.toCanvas = function () {
        var t = this.options,
            e = t.graph,
            n = t.width,
            r = t.height,
            a = t.beforeTransform,
            o = t.limitRatio,
            s = t.afterTransform,
            u = this.getCanvas(),
            c = e.getBBox(),
            h = i.clone(e.getMatrix()),
            f = e.getFitViewPadding(),
            l = e.getCanvas(),
            p = i.getAutoZoomMatrix({
          minX: 0,
          minY: 0,
          maxX: n,
          maxY: r
        }, c, f, o);
        return this.drawInner(u, function () {
          var t = l.get("children");
          u.set("children", t), a(p, h), e.setMatrix(p), u.draw(), e.setMatrix(h), s(p, h);
        }), u.matrix = p, u.get("el");
      }, t;
    }();

    t.exports = s;
  }, function (t, e, n) {
    var r = n(26),
        i = function (t) {
      function e(e) {
        var n = {
          type: "guide",
          isGuide: !0,
          zIndex: 4
        };
        return r.mix(n, e), t.call(this, n) || this;
      }

      return function (t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
      }(e, t), e;
    }(n(608));

    t.exports = i;
  }, function (t, e, n) {
    var r = n(26),
        i = function (t) {
      function e(e) {
        var n = {
          type: "group",
          isNode: !1,
          isGroup: !0,
          zIndex: 1
        };
        return r.mix(n, e), t.call(this, n) || this;
      }

      !function (t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
      }(e, t);
      var n = e.prototype;
      return n._beforeDraw = function () {
        this.deepEach(function (t, e) {
          e && (t.zIndex = e.zIndex + 1), t.updateCollapsedParent(), t.collapsedParent ? t.hide() : t.show();
        }), this.getInnerEdges().forEach(function (t) {
          t.linkedItemVisible() ? t.show() : t.hide();
        }), t.prototype._beforeDraw.call(this);
      }, n.updatePosition = function () {}, n._shouldDraw = function () {
        return !0;
      }, n.getCrossEdges = function () {
        var t = [],
            e = this.getInnerEdges();
        this.deepEach(function (e) {
          t.push(e.id);
        });
        var n = e.filter(function (e) {
          var n = e.getModel();
          return -1 === t.indexOf(n.source) || -1 === t.indexOf(n.target);
        });
        return r.uniq(n);
      }, n.getInnerEdges = function () {
        var t = [];
        return this.deepEach(function (e) {
          e.getEdges().forEach(function (e) {
            t.push(e);
          });
        }), r.uniq(t);
      }, n.getChildrenBBox = function () {
        var t = this.getChildren().map(function (t) {
          return t.getGraphicGroup();
        });
        return r.getChildrenBBox(t);
      }, e;
    }(n(624));

    t.exports = i;
  }, function (t, e, n) {
    function r(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : t[e] = n, t;
    }

    var i = n(26),
        a = function (t) {
      function e(e) {
        var n = {
          type: "edge",
          isEdge: !0,
          zIndex: 2
        };
        return i.mix(n, e), t.call(this, n) || this;
      }

      !function (t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
      }(e, t);
      var n = e.prototype;
      return n._init = function () {
        t.prototype._init.call(this);
      }, n._beforeDraw = function () {
        var e = this.model,
            n = this.itemMap;
        i.isObject(e.source) ? this.source = e.source : this.source = n[e.source], i.isObject(e.target) ? this.target = e.target : this.target = n[e.target], t.prototype._beforeDraw.call(this);
      }, n._afterDraw = function () {
        this.linkedItemVisible() || this.hide(), this._addArrow(), t.prototype._afterDraw.call(this);
      }, n._addArrow = function () {
        var t = this.model,
            e = this.keyShape;

        if ("path" === e.get("type")) {
          var n = this.shapeObj,
              r = e.attr("endArrow"),
              i = e.attr("startArrow"),
              a = t.endArrow || r,
              o = t.startArrow || i;
          i && e.attr("startArrow", !1), r && e.attr("endArrow", !1), a && this._drawArrow(n.endArrow, "end"), o && this._drawArrow(n.startArrow, "start");
        }
      }, n._drawArrow = function (t, e) {
        var n = t.path,
            a = t.shorten,
            o = t.tangent,
            s = t.ratio,
            u = t.style;
        o = o(this), a = a(this), n = n(this), u = u(this), s = s();
        var c = this.group,
            h = this.keyShape,
            f = i.parsePathString(h.attr("path")),
            l = f[f.length - 1],
            p = f[0],
            d = h.getPoint(s);

        if (d && !isNaN(d.x)) {
          var g = c.addShape("path", {
            attrs: function (t) {
              for (var e = 1; e < arguments.length; e++) {
                var n = null != arguments[e] ? arguments[e] : {},
                    i = Object.keys(n);
                "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter(function (t) {
                  return Object.getOwnPropertyDescriptor(n, t).enumerable;
                }))), i.forEach(function (e) {
                  r(t, e, n[e]);
                });
              }

              return t;
            }({
              path: n
            }, u)
          }),
              v = o[1][0] - o[0][0],
              m = o[1][1] - o[0][1],
              x = a / Math.sqrt(v * v + m * m),
              y = [-v * x, -m * x],
              b = 0,
              M = Math.atan(v / m);
          0 === m && v < 0 ? b = Math.PI : v > 0 && m > 0 ? b = Math.PI / 2 - M : v < 0 && m < 0 ? b = -Math.PI / 2 - M : v >= 0 && m < 0 ? b = -M - Math.PI / 2 : v <= 0 && m > 0 && (b = Math.PI / 2 - M), g.rotate(b), g.translate(d.x, d.y), "end" === e ? (l[l.length - 1] = y[1] + d.y, l[l.length - 2] = y[0] + d.x) : (p[p.length - 1] = y[1] + d.y, p[p.length - 2] = y[0] + d.x), h.attr("path", f), this[e + "Arrow"] = g;
        }
      }, n._getControlPoints = function () {
        var t = this.model.controlPoints;
        return i.isArray(t) ? t : [];
      }, n._shouldDraw = function () {
        return t.prototype._shouldDraw.call(this) && this.linkedItemVisible();
      }, n._getPoint = function (t) {
        if (t.isItem) {
          var e = t.getBBox();
          return {
            x: e.centerX,
            y: e.centerY
          };
        }

        return {
          x: t.x,
          y: t.y
        };
      }, n.linkedItemVisible = function () {
        var t = this.source,
            e = this.target;
        return i.isPlainObject(t) || i.isPlainObject(e) || t.isVisible() || e.isVisible() || t.collapsedParent !== e.collapsedParent;
      }, n.getSource = function () {
        var t = this.source,
            e = t.collapsedParent,
            n = this.itemMap;
        return e ? n[e.id] : t;
      }, n.getTarget = function () {
        var t = this.target,
            e = t.collapsedParent,
            n = this.itemMap;
        return e ? n[e.id] : t;
      }, n.getPoints = function () {
        var t = this.getSource(),
            e = this.getTarget(),
            n = this.model,
            r = this._getControlPoints(),
            a = this._getPoint(t),
            o = this._getPoint(e),
            s = [a].concat(r).concat([o]),
            u = s.length;

        if (t.isItem) {
          var c = i.isNumber(this.model.sourceAnchor) && t.id === n.source ? this.model.sourceAnchor : s[1],
              h = t.getLinkPoints(c);
          s[0] = h[0];
        }

        if (e.isItem) {
          var f = i.isNumber(this.model.targetAnchor) && e.id === n.target ? this.model.targetAnchor : s[u - 2],
              l = e.getLinkPoints(f);
          s[u - 1] = l[0];
        }

        return s;
      }, n.destroy = function () {
        var e = this.itemMap,
            n = this.model,
            r = e[n.source],
            a = e[n.target];
        r && r.isItem && i.Array.remove(r.edges, this), a && a.isItem && i.Array.remove(a.edges, this), t.prototype.destroy.call(this);
      }, e;
    }(n(608));

    t.exports = a;
  }, function (t, e, n) {
    t.exports = {
      Node: n(624),
      Edge: n(709),
      Group: n(708),
      Guide: n(707)
    };
  }, function (t, e, n) {
    var r;
    /*!
     * EventEmitter v5.2.5 - git.io/ee
     * Unlicense - http://unlicense.org/
     * Oliver Caldwell - http://oli.me.uk/
     * @preserve
     */

    !function (e) {
      "use strict";

      function i() {}

      var a = i.prototype,
          o = e.EventEmitter;

      function s(t, e) {
        for (var n = t.length; n--;) {
          if (t[n].listener === e) return n;
        }

        return -1;
      }

      function u(t) {
        return function () {
          return this[t].apply(this, arguments);
        };
      }

      a.getListeners = function (t) {
        var e,
            n,
            r = this._getEvents();

        if (t instanceof RegExp) for (n in e = {}, r) {
          r.hasOwnProperty(n) && t.test(n) && (e[n] = r[n]);
        } else e = r[t] || (r[t] = []);
        return e;
      }, a.flattenListeners = function (t) {
        var e,
            n = [];

        for (e = 0; e < t.length; e += 1) {
          n.push(t[e].listener);
        }

        return n;
      }, a.getListenersAsObject = function (t) {
        var e,
            n = this.getListeners(t);
        return n instanceof Array && ((e = {})[t] = n), e || n;
      }, a.addListener = function (t, e) {
        if (!function t(e) {
          return "function" == typeof e || e instanceof RegExp || !(!e || "object" != _typeof(e)) && t(e.listener);
        }(e)) throw new TypeError("listener must be a function");

        var n,
            r = this.getListenersAsObject(t),
            i = "object" == _typeof(e);

        for (n in r) {
          r.hasOwnProperty(n) && -1 === s(r[n], e) && r[n].push(i ? e : {
            listener: e,
            once: !1
          });
        }

        return this;
      }, a.on = u("addListener"), a.addOnceListener = function (t, e) {
        return this.addListener(t, {
          listener: e,
          once: !0
        });
      }, a.once = u("addOnceListener"), a.defineEvent = function (t) {
        return this.getListeners(t), this;
      }, a.defineEvents = function (t) {
        for (var e = 0; e < t.length; e += 1) {
          this.defineEvent(t[e]);
        }

        return this;
      }, a.removeListener = function (t, e) {
        var n,
            r,
            i = this.getListenersAsObject(t);

        for (r in i) {
          i.hasOwnProperty(r) && -1 !== (n = s(i[r], e)) && i[r].splice(n, 1);
        }

        return this;
      }, a.off = u("removeListener"), a.addListeners = function (t, e) {
        return this.manipulateListeners(!1, t, e);
      }, a.removeListeners = function (t, e) {
        return this.manipulateListeners(!0, t, e);
      }, a.manipulateListeners = function (t, e, n) {
        var r,
            i,
            a = t ? this.removeListener : this.addListener,
            o = t ? this.removeListeners : this.addListeners;
        if ("object" != _typeof(e) || e instanceof RegExp) for (r = n.length; r--;) {
          a.call(this, e, n[r]);
        } else for (r in e) {
          e.hasOwnProperty(r) && (i = e[r]) && ("function" == typeof i ? a.call(this, r, i) : o.call(this, r, i));
        }
        return this;
      }, a.removeEvent = function (t) {
        var e,
            n = _typeof(t),
            r = this._getEvents();

        if ("string" === n) delete r[t];else if (t instanceof RegExp) for (e in r) {
          r.hasOwnProperty(e) && t.test(e) && delete r[e];
        } else delete this._events;
        return this;
      }, a.removeAllListeners = u("removeEvent"), a.emitEvent = function (t, e) {
        var n,
            r,
            i,
            a,
            o = this.getListenersAsObject(t);

        for (a in o) {
          if (o.hasOwnProperty(a)) for (n = o[a].slice(0), i = 0; i < n.length; i++) {
            !0 === (r = n[i]).once && this.removeListener(t, r.listener), r.listener.apply(this, e || []) === this._getOnceReturnValue() && this.removeListener(t, r.listener);
          }
        }

        return this;
      }, a.trigger = u("emitEvent"), a.emit = function (t) {
        var e = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(t, e);
      }, a.setOnceReturnValue = function (t) {
        return this._onceReturnValue = t, this;
      }, a._getOnceReturnValue = function () {
        return !this.hasOwnProperty("_onceReturnValue") || this._onceReturnValue;
      }, a._getEvents = function () {
        return this._events || (this._events = {});
      }, i.noConflict = function () {
        return e.EventEmitter = o, i;
      }, void 0 === (r = function () {
        return i;
      }.call(e, n, e, t)) || (t.exports = r);
    }("undefined" != typeof window ? window : this || {});
  }, function (t, e, n) {
    var r = n(26),
        i = function (t) {
      !function (t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
      }(n, t);
      var e = n.prototype;

      function n(e) {
        var n,
            i = (n = t.call(this) || this).getDefaultCfg();
        return n._cfg = r.mix({}, i, e), n;
      }

      return e.getDefaultCfg = function () {
        return {};
      }, e.get = function (t) {
        return this._cfg[t];
      }, e.set = function (t, e) {
        this._cfg[t] = e;
      }, e.destroy = function () {
        this._cfg = {}, this.removeAllListeners(), this.destroyed = !0;
      }, n;
    }(n(711));

    t.exports = i;
  }, function (t, e, n) {
    var r = n(26),
        i = n(248),
        a = function a() {};

    r.augment(a, {
      drawInner: function drawInner(t) {
        var e = r.clone(this.getTotalMatrix()),
            n = this._attrs,
            i = n.x,
            a = n.y,
            o = n.width,
            s = n.height;
        t.setTransform(e[0], e[1], e[3], e[4], e[6], e[7]), t.drawImage(this.domImage, i, a, o, s);
      }
    }), r.mixin(i.Dom, [a]), t.exports = a;
  }, function (t, e, n) {
    var r = n(26),
        i = n(248),
        a = function a() {};

    r.augment(a, {
      hasClass: function hasClass(t) {
        var e = this.get("class");
        return !(!e || -1 === e.indexOf(t));
      }
    }), r.mixin(i.Shape, [a]), t.exports = a;
  }, function (t, e, n) {
    var r = n(248),
        i = n(26),
        a = function a() {};

    i.augment(a, {
      findByClass: function findByClass(t) {
        var e = [];
        return this.deepEach(function (n) {
          n.hasClass(t) && e.push(n);
        }), e;
      },
      hasClass: function hasClass(t) {
        var e = this.get("class");
        return !(!e || -1 === e.indexOf(t));
      },
      deepEach: function deepEach(t, e) {
        i.traverseTree(this, t, function (t) {
          return t.get("children");
        }, e);
      },
      sort: function sort() {
        var t = this.get("children");
        this.set("children", i.radixSort(t, function (t) {
          return t.get("zIndex");
        }));
      },
      sortBy: function sortBy(t) {
        var e = this.get("children");
        this.set("children", i.radixSort(e, t));
      },
      clear: function clear(t) {
        for (var e = this._cfg.children, n = e.length - 1; n >= 0; n--) {
          e[n].remove(t);
        }

        return this._cfg.children = [], this;
      }
    }), i.mixin(r.Group, [a]), t.exports = a;
  }, function (t, e, n) {
    n(258).registerGuide("common", {
      draw: function draw() {
        console.warn("do not have this guide, please register one");
      }
    });
  }, function (t, e, n) {
    t.exports = {
      common: n(716)
    };
  }, function (t, e, n) {
    function r(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : t[e] = n, t;
    }

    var i = n(258),
        a = n(26),
        o = n(247);
    i.registerGroup("common", {
      draw: function draw(t) {
        return t.getModel().collapsed ? this.drawCollapsed(t) : this.drawExpanded(t);
      },
      defaultWidth: 184,
      defaultHeight: 40,
      getLabel: function getLabel(t) {
        return t.getModel().label;
      },
      drawLabel: function drawLabel(t, e, n) {
        var r = this.getLabel(t);

        if (r) {
          var i = t.getGraphicGroup(),
              s = [8, 8];
          e += s[0], n += s[1];
          var u = t.getModel(),
              c = u.labelOffsetX,
              h = u.labelOffsetY,
              f = u.labelRotate;
          e = c ? c + e : e, n = h ? h + n : n;
          var l = a.mix(!0, {}, o.labelStyle, {
            x: e,
            y: n,
            textAlign: "left",
            textBaseline: "top"
          });
          a.isObject(r) ? a.mix(l, r) : l.text = r;
          var p = i.addShape("text", {
            class: "label",
            attrs: l
          });

          if (f) {
            var d = p.getBBox(),
                g = (d.maxX + d.minX) / 2,
                v = (d.maxY + d.minY) / 2;
            p.transform([["t", -g, -v], ["r", f, f], ["t", g, v]]);
          }
        }
      },
      drawKeyShape: function drawKeyShape(t, e) {
        var n = e.x,
            r = e.y,
            i = e.width,
            s = e.height,
            u = t.getModel(),
            c = t.getGraphicGroup(),
            h = a.mix({}, o.groupStyle, u.style),
            f = a.getRectPath(n, r, i, s, h.radius);
        return t.lastChildrenBox = e, c.addShape("path", {
          attrs: a.mix({}, h, {
            path: f
          })
        });
      },
      getChildrenBBox: function getChildrenBBox(t) {
        var e = function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = null != arguments[e] ? arguments[e] : {},
                i = Object.keys(n);
            "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter(function (t) {
              return Object.getOwnPropertyDescriptor(n, t).enumerable;
            }))), i.forEach(function (e) {
              r(t, e, n[e]);
            });
          }

          return t;
        }({}, t.lastChildrenBox),
            n = t.getModel();

        if (t.getChildren().length > 0) {
          var i = t.getChildrenBBox();
          e.x = i.minX - o.groupBackgroundPadding[3], e.y = i.minY - o.groupBackgroundPadding[0], e.width = i.maxX - i.minX + o.groupBackgroundPadding[3] + o.groupBackgroundPadding[1], e.height = i.maxY - i.minY + o.groupBackgroundPadding[0] + o.groupBackgroundPadding[2];
        } else e.width = this.defaultWidth, e.height = this.defaultHeight;

        return a.isNil(e.x) && !a.isNil(n.x) && (e.x = n.x), a.isNil(e.y) && !a.isNil(n.y) && (e.y = n.y), e;
      },
      drawExpanded: function drawExpanded(t) {
        var e = this.getChildrenBBox(t),
            n = this.drawKeyShape(t, e);
        return this.drawLabel(t, e.x, e.y), n;
      },
      drawCollapsed: function drawCollapsed(t) {
        var e = this.getChildrenBBox(t);
        e.width = this.defaultWidth, e.height = this.defaultHeight;
        var n = this.drawKeyShape(t, e);
        return this.drawLabel(t, e.x, e.y), n;
      },
      anchor: {
        intersectBox: "rect"
      }
    });
  }, function (t, e, n) {
    t.exports = {
      common: n(718)
    };
  }, function (t, e, n) {
    function r(t) {
      for (var e = 1; e < arguments.length; e++) {
        var n = null != arguments[e] ? arguments[e] : {},
            r = Object.keys(n);
        "function" == typeof Object.getOwnPropertySymbols && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function (t) {
          return Object.getOwnPropertyDescriptor(n, t).enumerable;
        }))), r.forEach(function (e) {
          i(t, e, n[e]);
        });
      }

      return t;
    }

    function i(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : t[e] = n, t;
    }

    var a = n(258),
        o = n(26),
        s = n(247),
        u = {
      path: function path(t) {
        var e = t.getKeyShape().attr("lineWidth"),
            n = 10 * (e = e > 3 ? e : 3) / 3,
            r = 4 * e / 3,
            i = 4 * e;
        return [["M", -n, r], ["L", 0, 0], ["L", -n, -r], ["A", i, i, 0, 0, 1, -n, r], ["Z"]];
      },
      shorten: function shorten(t) {
        var e = t.getKeyShape().attr("lineWidth");
        return 3.1 * (e > 3 ? e : 3);
      },
      style: function style(t) {
        var e = t.getKeyShape().attr();
        return {
          fillOpacity: e.strokeOpacity,
          fill: e.stroke
        };
      }
    };
    a.registerEdge("common", {
      draw: function draw(t) {
        var e = this.drawKeyShape(t);
        return this.drawLabel(t, e), e;
      },
      drawKeyShape: function drawKeyShape(t) {
        var e = t.getGraphicGroup(),
            n = this.getStyle(t),
            r = this.getPath(t);
        return e.addShape("path", {
          attrs: o.mix({}, n, {
            path: r
          })
        });
      },
      getStyle: function getStyle(t) {
        var e = t.getModel();
        return o.mix(!0, {}, {
          stroke: e.color || "#A3B1BF",
          strokeOpacity: .92,
          lineAppendWidth: 4,
          lineWidth: e.size || 1
        }, e.style);
      },
      getPath: function getPath(t) {
        var e = t.getPoints();
        return o.pointsToPolygon(e);
      },
      getLabel: function getLabel(t) {
        return t.getModel().label;
      },
      getDefaultLabelRectStyle: function getDefaultLabelRectStyle() {
        return {
          fill: "white"
        };
      },
      getDefaultLabelRectPadding: function getDefaultLabelRectPadding() {
        return o.toAllPadding([4, 8]);
      },
      drawLabel: function drawLabel(t, e) {
        var n = this.getLabel(t),
            r = t.getGraphicGroup(),
            i = t.getModel(),
            a = i.labelOffsetX,
            u = i.labelOffsetY,
            c = i.labelRotate;

        if (n) {
          var h = e.getPoint(.5);
          if (!h) return;
          h.x = a ? h.x + a : h.x, h.y = u ? h.y + u : h.y;
          var f = o.mix(!0, {}, s.labelStyle, h);
          o.isObject(n) ? o.mix(f, n) : f.text = n, n = r.addShape("text", {
            class: "label",
            attrs: f
          });
          var l = this.getDefaultLabelRectPadding(t),
              p = this.getDefaultLabelRectStyle(t),
              d = n.getBBox(),
              g = i.labelRectStyle ? o.mix({}, p, i.labelRectStyle) : p,
              v = r.addShape("rect", {
            attrs: o.mix({}, g, {
              x: d.minX - l[3],
              y: d.minY - l[0],
              width: d.maxX - d.minX + l[1] + l[3],
              height: d.maxY - d.minY + l[0] + l[2]
            })
          });

          if (c) {
            var m = (d.maxX + d.minX) / 2,
                x = (d.maxY + d.minY) / 2;
            n.transform([["t", -m, -x], ["r", c, c], ["t", m, x]]), v.transform([["t", -m, -x], ["r", c, c], ["t", m, x]]);
          }

          o.toFront(n);
        }
      },
      startArrow: r({}, u, {
        tangent: function tangent(t) {
          return t.getKeyShape().getStartTangent();
        },
        ratio: function ratio() {
          return 0;
        }
      }),
      endArrow: r({}, u, {
        tangent: function tangent(t) {
          return t.getKeyShape().getEndTangent();
        },
        ratio: function ratio() {
          return 1;
        }
      })
    });
  }, function (t, e, n) {
    t.exports = {
      common: n(720)
    };
  }, function (t, e, n) {
    var r = n(258),
        i = n(26);
    r.registerNode("html", {
      getHtml: function getHtml(t) {
        return t.getModel().html;
      },
      cssSize: !0,
      draw: function draw(t) {
        var e = i.createDOM('<div class="g6-html-node-container"></div>'),
            n = t.getGraphicGroup(),
            r = t.getGraph();
        if ("svg" !== r.get("renderer")) throw new Error("please use svg renderer draw html element !");
        var a = r.getGraphContainer(),
            o = this.getSize(t),
            s = this.getStyle(t),
            u = this.cssSize,
            c = this.getHtml(t);
        c = i.createDOM(c), e.css({
          position: "absolute",
          padding: "0px",
          margin: "0px"
        }), e.appendChild(c), a.appendChild(e), u && (o[0] = e.width(), o[1] = e.height());
        var h = -o[0] / 2,
            f = -o[1] / 2,
            l = o[0],
            p = o[1],
            d = n.addShape("rect", {
          attrs: i.mix({}, s, {
            x: h,
            y: f,
            width: l,
            height: p
          })
        });
        return n.addShape("dom", {
          attrs: i.mix({
            x: h,
            y: f,
            width: l,
            height: p,
            html: e
          })
        }), d;
      }
    });
  }, function (t, e, n) {
    var r = n(258),
        i = n(26),
        a = n(247);
    r.registerNode("common", {
      draw: function draw(t) {
        var e = t.getGraphicGroup(),
            n = this.drawLabel(t),
            r = this.drawKeyShape(t);
        return n && i.toFront(n, e), r;
      },
      getSize: function getSize(t) {
        var e = t.getModel().size;
        return i.isArray(e) ? e : i.isNumber(e) ? [e, e] : [a.defaultNodeSize, a.defaultNodeSize];
      },
      getStyle: function getStyle(t) {
        var e = t.getModel();
        return i.mix(!0, {
          lineWidth: 1,
          fill: e.color || "#40a9ff",
          stroke: e.color || "#096dd9",
          fillOpacity: .92
        }, e.style);
      },
      getLabel: function getLabel(t) {
        return t.getModel().label;
      },
      drawKeyShape: function drawKeyShape(t) {
        var e = t.getGraphicGroup(),
            n = this.getStyle(t),
            r = this.getPath(t);
        return e.addShape("path", {
          attrs: i.mix({}, n, {
            path: r
          })
        });
      },
      drawLabel: function drawLabel(t) {
        var e = t.getGraphicGroup(),
            n = this.getLabel(t),
            r = t.getModel(),
            o = r.labelOffsetX,
            s = r.labelOffsetY,
            u = r.labelRotate;

        if (!i.isNil(n)) {
          var c = i.mix(!0, {}, a.labelStyle, {
            x: o || 0,
            y: s || 0
          });
          i.isObject(n) ? i.mix(c, n) : c.text = n;
          var h = e.addShape("text", {
            class: "label",
            attrs: c
          });
          return u && h.rotate(u), h;
        }
      },
      getPath: function getPath(t) {
        var e = this.getSize(t);
        return i.getEllipsePath(0, 0, e[0] / 2, e[1] / 2);
      }
    });
  }, function (t, e, n) {
    t.exports = {
      common: n(723),
      html: n(722)
    };
  }, function (t, e, n) {
    var r = n(682),
        i = n(257),
        a = {
      getAutoZoomMatrix: function getAutoZoomMatrix(t, e, n, i) {
        var a = [1, 0, 0, 0, 1, 0, 0, 0, 1],
            o = t.maxX - t.minX,
            s = t.maxY - t.minY,
            u = (e.maxX + e.minX) / 2,
            c = (e.maxY + e.minY) / 2,
            h = o - n[1] - n[3],
            f = s - n[0] - n[2],
            l = e.maxX - e.minX,
            p = e.maxY - e.minY,
            d = Math.min(f / p, h / l);
        return i && (d = i(d)), r.mat3.translate(a, a, [-u, -c]), r.mat3.scale(a, a, [d, d]), r.mat3.translate(a, a, [o / 2, s / 2]), a;
      },
      getNineBoxPosition: function getNineBoxPosition(t, e, n, r, i) {
        var a = {};

        switch (t) {
          case "tl":
            a.y = e.x + i[0], a.x = e.y + i[3];
            break;

          case "lc":
            a.y = (e.height - r) / 2, a.x = i[3];
            break;

          case "bl":
            a.y = e.height - r - i[2], a.x = i[3];
            break;

          case "cc":
            a.y = (e.height - r) / 2, a.x = (e.width - n) / 2;
            break;

          case "tc":
            a.y = i[0], a.x = (e.width - n) / 2;
            break;

          case "tr":
            a.y = i[0], a.x = e.width - n - i[1];
            break;

          case "rc":
            a.y = (e.height - r) / 2, a.x = e.width - n - i[1];
            break;

          case "br":
            a.y = e.height - r - i[2], a.x = e.width - n - i[1];
            break;

          case "bc":
            a.y = e.height - r - i[2], a.x = (e.width - n) / 2;
            break;

          default:
            a.y = e.x + i[0], a.x = e.y + i[3];
        }

        return a.x += e.x, a.y += e.y, a;
      },
      getTotalBBox: function getTotalBBox(t) {
        var e = 1 / 0,
            n = -1 / 0,
            r = 1 / 0,
            i = -1 / 0;
        return t.forEach(function (t) {
          t.minX < e && (e = t.minX), t.maxX > n && (n = t.maxX), t.minY < r && (r = t.minY), t.maxY > i && (i = t.maxY);
        }), {
          minX: e,
          minY: r,
          maxX: n,
          maxY: i,
          width: n - e,
          height: i - r
        };
      },
      getChildrenBBox: function getChildrenBBox(t) {
        var e = 1 / 0,
            n = -1 / 0,
            r = 1 / 0,
            o = -1 / 0;
        i.each(t, function (t) {
          var i = t.isGroup ? a.getChildrenBBox(t.get("children")) : t.getBBox();
          if (!i) return !0;
          var s = [i.minX, i.minY, 1],
              u = [i.minX, i.maxY, 1],
              c = [i.maxX, i.minY, 1],
              h = [i.maxX, i.maxY, 1];
          t.apply(s), t.apply(u), t.apply(c), t.apply(h);
          var f = Math.min(s[0], u[0], c[0], h[0]),
              l = Math.max(s[0], u[0], c[0], h[0]),
              p = Math.min(s[1], u[1], c[1], h[1]),
              d = Math.max(s[1], u[1], c[1], h[1]);
          f < e && (e = f), l > n && (n = l), p < r && (r = p), d > o && (o = d);
        });
        var s = {
          minX: e,
          minY: r,
          maxX: n,
          maxY: o
        };
        return s.x = s.minX, s.y = s.minY, s.width = s.maxX - s.minX, s.height = s.maxY - s.minY, s.centerX = (s.minX + s.maxX) / 2, s.centerY = (s.minY + s.maxY) / 2, s;
      },
      getBBox: function getBBox(t, e) {
        var n,
            i = t.getBBox(),
            a = {
          x: i.minX,
          y: i.minY
        },
            o = {
          x: i.maxX,
          y: i.maxY
        };

        if (e.isGroup) {
          for (n = t; n !== e;) {
            var s = n.getMatrix();
            a = r.applyMatrix(a, s), o = r.applyMatrix(o, s), n = n.getParent();
          }

          var u = n.getMatrix();
          a = r.applyMatrix(a, u), o = r.applyMatrix(o, u);
        } else a = r.applyMatrix(a, e), o = r.applyMatrix(o, e);

        return {
          minX: a.x,
          minY: a.y,
          maxX: o.x,
          maxY: o.y
        };
      },
      toBack: function toBack(t) {
        t.toBack();
      },
      toFront: function toFront(t) {
        t.toFront();
      }
    };
    t.exports = a;
  }, function (t, e, n) {
    var r = n(257);
    t.exports = {
      isNode: function isNode(t) {
        return t && r.isObject(t) && "node" === t.type;
      },
      isEdge: function isEdge(t) {
        return t && r.isObject(t) && "edge" === t.type;
      },
      isGroup: function isGroup(t) {
        return t && r.isObject(t) && "group" === t.type;
      }
    };
  }, function (t, e, n) {
    var r = n(257),
        i = {};
    r.mix(i, {
      addEventListener: function addEventListener(t, e, n) {
        return t.attachEvent ? (t.attachEvent("on" + e, n), {
          remove: function remove() {
            t.detachEvent("on" + e, n);
          }
        }) : t.addEventListener ? (t.addEventListener(e, n, !1), {
          remove: function remove() {
            t.removeEventListener(e, n, !1);
          }
        }) : void 0;
      },
      createDOM: function createDOM(t, e) {
        var n;
        return (n = r.isString(t) ? r.createDom(t) : t).bbox = n.getBoundingClientRect(), n.hide = function () {
          return n.style.visibility = "hidden", n;
        }, n.show = function () {
          return n.style.visibility = "visible", n;
        }, n.css = function (t) {
          return r.modifyCSS(n, t), n;
        }, n.width = function () {
          return r.getWidth(n);
        }, n.height = function () {
          return r.getHeight(n);
        }, n.destroy = function () {
          n.parentNode && n.parentNode.removeChild(n);
        }, n.on = function (t, e) {
          n.addEventListener(t, e);
        }, n.off = function (t, e) {
          n.removeEventListener(t, e);
        }, n.css(e), n;
      },
      initDOMContainer: function initDOMContainer(t, e) {
        if (!t) throw new Error("please set the container for the " + e + " !");
        return r.isString(t) && (t = document.getElementById(t)), t;
      }
    }), t.exports = i;
  }, function (t, e) {
    var n = {
      svg: "svg",
      circle: "circle",
      rect: "rect",
      text: "text",
      path: "path",
      foreignObject: "foreignObject",
      polygon: "polygon",
      ellipse: "ellipse",
      image: "image"
    };

    t.exports = function (t, e, r) {
      var i = r.target || r.srcElement;

      if (!n[i.tagName]) {
        for (var a = i.parentNode; a && !n[a.tagName];) {
          a = a.parentNode;
        }

        i = a;
      }

      return this._cfg.el === i ? this : this.find(function (t) {
        return t._cfg && t._cfg.el === i;
      });
    };
  }, function (t, e, n) {
    var r = n(19),
        i = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i,
        a = function () {
      function t(t) {
        var e = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
        e.setAttribute("patternUnits", "userSpaceOnUse");
        var n = document.createElementNS("http://www.w3.org/2000/svg", "image");
        e.appendChild(n);
        var a = r.uniqueId("pattern_");
        e.id = a, this.el = e, this.id = a, this.cfg = t;
        var o = i.exec(t)[2];
        n.setAttribute("href", o);
        var s = new Image();

        function u() {
          console.log(s.width, s.height), e.setAttribute("width", s.width), e.setAttribute("height", s.height);
        }

        return o.match(/^data:/i) || (s.crossOrigin = "Anonymous"), s.src = o, s.complete ? u() : (s.onload = u, s.src = s.src), this;
      }

      return t.prototype.match = function (t, e) {
        return this.cfg === e;
      }, t;
    }();

    t.exports = a;
  }, function (t, e, n) {
    var r = n(19),
        i = function () {
      function t(t) {
        this.type = "clip";
        var e = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
        this.el = e, this.id = r.uniqueId("clip_"), e.id = this.id;
        var n = t._cfg.el;
        return e.appendChild(n.cloneNode(!0)), this.cfg = t, this;
      }

      var e = t.prototype;
      return e.match = function () {
        return !1;
      }, e.remove = function () {
        var t = this.el;
        t.parentNode.removeChild(t);
      }, t;
    }();

    t.exports = i;
  }, function (t, e, n) {
    var r = n(19),
        i = function () {
      function t(t, e) {
        var n = document.createElementNS("http://www.w3.org/2000/svg", "marker"),
            i = r.uniqueId("marker_");
        n.setAttribute("id", i);
        var a = document.createElementNS("http://www.w3.org/2000/svg", "path");
        return a.setAttribute("stroke", "none"), a.setAttribute("fill", t.stroke || "#000"), n.appendChild(a), n.setAttribute("overflow", "visible"), n.setAttribute("orient", "auto-start-reverse"), this.el = n, this.child = a, this.id = i, this.cfg = t["marker-start" === e ? "startArrow" : "endArrow"], this.stroke = t.stroke || "#000", !0 === this.cfg ? this._setDefaultPath(e, a) : this._setMarker(t.lineWidth, a), this;
      }

      var e = t.prototype;
      return e.match = function () {
        return !1;
      }, e._setDefaultPath = function (t, e) {
        var n = this.el;
        e.setAttribute("d", "M0,0 L6,3 L0,6 L3,3Z"), n.setAttribute("refX", 3), n.setAttribute("refY", 3);
      }, e._setMarker = function (t, e) {
        var n = this.el,
            i = this.cfg.path,
            a = this.cfg.d;
        r.isArray(i) && (i = i.map(function (t) {
          return t.join(" ");
        }).join("")), e.setAttribute("d", i), n.appendChild(e), a && n.setAttribute("refX", a / t);
      }, e.update = function (t) {
        var e = this.child;
        e.attr ? e.attr("fill", t) : e.setAttribute("fill", t);
      }, t;
    }();

    t.exports = i;
  }, function (t, e, n) {
    var r = n(19),
        i = {
      shadowColor: "color",
      shadowOpacity: "opacity",
      shadowBlur: "blur",
      shadowOffsetX: "dx",
      shadowOffsetY: "dy"
    },
        a = {
      x: "-40%",
      y: "-40%",
      width: "200%",
      height: "200%"
    },
        o = function () {
      function t(t) {
        this.type = "filter";
        var e = document.createElementNS("http://www.w3.org/2000/svg", "filter");
        return r.each(a, function (t, n) {
          e.setAttribute(n, t);
        }), this.el = e, this.id = r.uniqueId("filter_"), this.el.id = this.id, this.cfg = t, this._parseShadow(t, e), this;
      }

      var e = t.prototype;
      return e.match = function (t, e) {
        if (this.type !== t) return !1;
        var n = !0,
            i = this.cfg;
        return r.each(Object.keys(i), function (t) {
          if (i[t] !== e[t]) return n = !1, !1;
        }), n;
      }, e.update = function (t, e) {
        var n = this.cfg;
        return n[i[t]] = e, this._parseShadow(n, this.el), this;
      }, e._parseShadow = function (t, e) {
        var n = '<feDropShadow \n      dx="' + (t.dx || 0) + '" \n      dy="' + (t.dy || 0) + '" \n      stdDeviation="' + (t.blur ? t.blur / 10 : 0) + '"\n      flood-color="' + (t.color ? t.color : "#000") + '"\n      flood-opacity="' + (t.opacity ? t.opacity : 1) + '"\n      />';
        e.innerHTML = n;
      }, t;
    }();

    t.exports = o;
  }, function (t, e, n) {
    var r = n(19),
        i = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i,
        a = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i,
        o = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;

    function s(t) {
      var e = t.match(o);
      if (!e) return "";
      var n = "";
      return e.sort(function (t, e) {
        return t = t.split(":"), e = e.split(":"), Number(t[0]) - Number(e[0]);
      }), r.each(e, function (t) {
        t = t.split(":"), n += '<stop offset="' + t[0] + '" stop-color="' + t[1] + '"></stop>';
      }), n;
    }

    var u = function () {
      function t(t) {
        var e = null,
            n = r.uniqueId("gradient_");
        return "l" === t.toLowerCase()[0] ? function (t, e) {
          var n,
              a,
              o = i.exec(t),
              u = r.mod(r.toRadian(parseFloat(o[1])), 2 * Math.PI),
              c = o[2];
          u >= 0 && u < .5 * Math.PI ? (n = {
            x: 0,
            y: 0
          }, a = {
            x: 1,
            y: 1
          }) : .5 * Math.PI <= u && u < Math.PI ? (n = {
            x: 1,
            y: 0
          }, a = {
            x: 0,
            y: 1
          }) : Math.PI <= u && u < 1.5 * Math.PI ? (n = {
            x: 1,
            y: 1
          }, a = {
            x: 0,
            y: 0
          }) : (n = {
            x: 0,
            y: 1
          }, a = {
            x: 1,
            y: 0
          });
          var h = Math.tan(u),
              f = h * h,
              l = (a.x - n.x + h * (a.y - n.y)) / (f + 1) + n.x,
              p = h * (a.x - n.x + h * (a.y - n.y)) / (f + 1) + n.y;
          e.setAttribute("x1", n.x), e.setAttribute("y1", n.y), e.setAttribute("x2", l), e.setAttribute("y2", p), e.innerHTML = s(c);
        }(t, e = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient")) : function (t, e) {
          var n = a.exec(t),
              r = parseFloat(n[1]),
              i = parseFloat(n[2]),
              o = parseFloat(n[3]),
              u = n[4];
          e.setAttribute("cx", r), e.setAttribute("cy", i), e.setAttribute("r", o), e.innerHTML = s(u);
        }(t, e = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient")), e.setAttribute("id", n), this.el = e, this.id = n, this.cfg = t, this;
      }

      return t.prototype.match = function (t, e) {
        return this.cfg === e;
      }, t;
    }();

    t.exports = u;
  }, function (t, e, n) {
    var r = n(19),
        i = n(733),
        a = n(732),
        o = n(731),
        s = n(730),
        u = n(729),
        c = function () {
      function t(t) {
        var e = document.createElementNS("http://www.w3.org/2000/svg", "defs"),
            n = r.uniqueId("defs_");
        e.id = n, t.appendChild(e), this.children = [], this.defaultArrow = {}, this.el = e, this.canvas = t;
      }

      var e = t.prototype;
      return e.find = function (t, e) {
        for (var n = this.children, r = null, i = 0; i < n.length; i++) {
          if (n[i].match(t, e)) {
            r = n[i].id;
            break;
          }
        }

        return r;
      }, e.findById = function (t) {
        for (var e = this.children, n = null, r = 0; r < e.length; r++) {
          if (e[r].id === t) {
            n = e[r];
            break;
          }
        }

        return n;
      }, e.add = function (t) {
        this.children.push(t), t.canvas = this.canvas, t.parent = this;
      }, e.getDefaultArrow = function (t, e) {
        var n = t.stroke || t.strokeStyle;
        if (this.defaultArrow[n]) return this.defaultArrow[n].id;
        var r = new o(t, e);
        return this.defaultArrow[n] = r, this.el.appendChild(r.el), r.id;
      }, e.addGradient = function (t) {
        var e = new i(t);
        return this.el.appendChild(e.el), this.add(e), e.id;
      }, e.addArrow = function (t, e) {
        var n = new o(t, e);
        return this.el.appendChild(n.el), n.id;
      }, e.addShadow = function (t) {
        var e = new a(t);
        return this.el.appendChild(e.el), this.add(e), e.id;
      }, e.addPattern = function (t) {
        var e = new u(t);
        return this.el.appendChild(e.el), this.add(e), e.id;
      }, e.addClip = function (t) {
        var e = new s(t);
        return this.el.appendChild(e.el), this.add(e), e.id;
      }, t;
    }();

    t.exports = c;
  }, function (t, e, n) {
    var r = n(19),
        i = n(593).parseRadius,
        a = n(611),
        o = n(734),
        s = {
      rect: "path",
      circle: "circle",
      line: "line",
      path: "path",
      marker: "path",
      text: "text",
      polygon: "polygon",
      image: "image",
      ellipse: "ellipse",
      dom: "foreignObject",
      fan: "path",
      group: "g"
    },
        u = {
      opacity: "opacity",
      fillStyle: "fill",
      strokeOpacity: "stroke-opacity",
      fillOpacity: "fill-opacity",
      strokeStyle: "stroke",
      x: "x",
      y: "y",
      r: "r",
      width: "width",
      height: "height",
      x1: "x1",
      x2: "x2",
      y1: "y1",
      y2: "y2",
      lineCap: "stroke-linecap",
      lineJoin: "stroke-linejoin",
      lineWidth: "stroke-width",
      lineDash: "stroke-dasharray",
      lineDashOffset: "stroke-dashoffset",
      miterLimit: "stroke-miterlimit",
      font: "font",
      fontSize: "font-size",
      fontStyle: "font-style",
      fontVariant: "font-variant",
      fontWeight: "font-weight",
      fontFamily: "font-family",
      startArrow: "marker-start",
      endArrow: "marker-end",
      path: "d",
      class: "class",
      id: "id",
      style: "style",
      preserveAspectRatio: "preserveAspectRatio"
    },
        c = {
      top: "before-edge",
      middle: "central",
      bottom: "after-edge",
      alphabetic: "baseline",
      hanging: "hanging"
    },
        h = {
      left: "left",
      start: "left",
      center: "middle",
      right: "end",
      end: "end"
    },
        f = function () {
      function t(t) {
        if (!t) return null;
        var e = r.uniqueId("canvas_"),
            n = r.createDom('<svg id="' + e + '"></svg>');
        return t.appendChild(n), this.type = "svg", this.canvas = n, this.context = new o(n), this.toDraw = !1, this;
      }

      var e = t.prototype;
      return e.draw = function (t) {
        var e = this;
        e.animateHandler ? e.toDraw = !0 : function n() {
          e.animateHandler = r.requestAnimationFrame(function () {
            e.animateHandler = void 0, e.toDraw && n();
          });

          try {
            e._drawChildren(t);
          } catch (t) {
            console.warn("error in draw canvas, detail as:"), console.warn(t), e.toDraw = !1;
          }

          e.toDraw = !1;
        }();
      }, e.drawSync = function (t) {
        this._drawChildren(t);
      }, e._drawGroup = function (t, e) {
        var n = t._cfg;
        n.removed || n.destroyed || (n.tobeRemoved && (r.each(n.tobeRemoved, function (t) {
          t.parentNode && t.parentNode.removeChild(t);
        }), n.tobeRemoved = []), this._drawShape(t, e), n.children && n.children.length > 0 && this._drawChildren(t));
      }, e._drawChildren = function (t) {
        var e,
            n = t._cfg.children;
        if (n) for (var r = 0; r < n.length; r++) {
          (e = n[r]).isGroup ? this._drawGroup(e, r) : this._drawShape(e, r);
        }
      }, e._drawShape = function (t, e) {
        var n = t._attrs,
            r = t._cfg,
            i = r.el;
        r.removed || r.destroyed ? i && i.parentNode.removeChild(r.el) : (!i && r.parent && (this._createDom(t, e), this._updateShape(t)), i = r.el, !1 !== r.visible ? (r.visible && i.hasAttribute("visibility") && i.removeAttribute("visibility"), r.hasUpdate && this._updateShape(t), n.clip && n.clip._cfg.hasUpdate && this._updateShape(n.clip)) : i.setAttribute("visibility", "hidden"));
      }, e._updateShape = function (t) {
        var e = t._attrs,
            n = t._cfg.attrs;
        if (n) if (t._cfg.el || this._createDom(t), "clip" in e && this._setClip(t, e.clip), ("shadowOffsetX" in e || "shadowOffsetY" in e || "shadowBlur" in e || "shadowColor" in e) && this._setShadow(t), "text" !== t.type) {
          for (var i in "fan" === t.type && this._updateFan(t), "marker" === t.type && t._cfg.el.setAttribute("d", this._assembleMarker(e)), "rect" === t.type && t._cfg.el.setAttribute("d", this._assembleRect(e)), e) {
            e[i] !== n[i] && this._setAttribute(t, i, e[i]);
          }

          t._cfg.attrs = r.deepMix({}, t._attrs), t._cfg.hasUpdate = !1;
        } else this._updateText(t);
      }, e._setAttribute = function (t, e, n) {
        var i = t.type,
            a = t._attrs,
            o = t._cfg.el,
            s = this.context;
        if ("marker" !== i && "rect" !== i || !~["x", "y", "radius", "r"].indexOf(e)) if (~["circle", "ellipse"].indexOf(i) && ~["x", "y"].indexOf(e)) o.setAttribute("c" + e, parseInt(n, 10));else {
          if ("polygon" === i && "points" === e) return n && 0 !== n.length || (n = ""), r.isArray(n) && (n = (n = n.map(function (t) {
            return t[0] + "," + t[1];
          })).join(" ")), void o.setAttribute("points", n);
          if ("path" === e && r.isArray(n)) o.setAttribute("d", this._formatPath(n));else if ("img" !== e) {
            if ("transform" === e) return n ? void this._setTransform(t) : void o.removeAttribute("transform");
            if ("rotate" === e) return n ? void this._setTransform(t) : void o.removeAttribute("transform");
            if ("matrix" !== e) {
              if ("fillStyle" !== e && "strokeStyle" !== e) {
                if ("clip" !== e) if (~e.indexOf("Arrow")) {
                  if (e = u[e], n) {
                    var c = null;
                    c = "boolean" == typeof n ? s.getDefaultArrow(a, e) : s.addArrow(a, e), o.setAttribute(e, "url(#" + c + ")"), t._cfg[e] = c;
                  } else t._cfg[e] = null, o.removeAttribute(e);
                } else "html" === e && ("string" == typeof n ? o.innerHTML = n : (o.innerHTML = "", o.appendChild(n))), u[e] && o.setAttribute(u[e], n);
              } else this._setColor(t, e, n);
            } else this._setTransform(t);
          } else this._setImage(t, n);
        }
      }, e._createDom = function (t, e) {
        var n = s[t.type],
            r = t._attrs,
            i = t._cfg.parent,
            a = i._cfg.el;
        if (!n) throw new Error("the type" + t.type + "is not supported by svg");
        var o = document.createElementNS("http://www.w3.org/2000/svg", n);
        if (t._cfg.el = o, i) if (void 0 === e) a.appendChild(o);else {
          var u = i._cfg.el.childNodes;
          "svg" === a.tagName && (e += 1), u.length <= e ? a.appendChild(o) : a.insertBefore(o, u[e]);
        }
        return t._cfg.attrs = {}, "text" === t.type ? (o.setAttribute("paint-order", "stroke"), o.setAttribute("style", "stroke-linecap:butt; stroke-linejoin:miter;")) : (r.stroke || r.strokeStyle || o.setAttribute("stroke", "none"), r.fill || r.fillStyle || o.setAttribute("fill", "none")), o;
      }, e._assembleMarker = function (t) {
        var e = t.r;
        if (void 0 === t.r && (e = t.radius), isNaN(Number(t.x)) || isNaN(Number(t.y)) || isNaN(Number(e))) return "";
        var n = "";
        return n = "function" == typeof t.symbol ? t.symbol(t.x, t.y, e) : a.Symbols[t.symbol || "circle"](t.x, t.y, e), r.isArray(n) && (n = n.map(function (t) {
          return t.join(" ");
        }).join("")), n;
      }, e._assembleRect = function (t) {
        var e = t.x,
            n = t.y,
            a = t.width,
            o = t.height,
            s = t.radius;
        if (!s) return "M " + e + "," + n + " l " + a + ",0 l 0," + o + " l" + -a + " 0 z";
        var u = i(s);
        return r.isArray(s) ? 1 === s.length ? u.r1 = u.r2 = u.r3 = u.r4 = s[0] : 2 === s.length ? (u.r1 = u.r3 = s[0], u.r2 = u.r4 = s[1]) : 3 === s.length ? (u.r1 = s[0], u.r2 = u.r4 = s[1], u.r3 = s[2]) : (u.r1 = s[0], u.r2 = s[1], u.r3 = s[2], u.r4 = s[3]) : u.r1 = u.r2 = u.r3 = u.r4 = s, [["M " + (e + u.r1) + "," + n], ["l " + (a - u.r1 - u.r2) + ",0"], ["a " + u.r2 + "," + u.r2 + ",0,0,1," + u.r2 + "," + u.r2], ["l 0," + (o - u.r2 - u.r3)], ["a " + u.r3 + "," + u.r3 + ",0,0,1," + -u.r3 + "," + u.r3], ["l " + (u.r3 + u.r4 - a) + ",0"], ["a " + u.r4 + "," + u.r4 + ",0,0,1," + -u.r4 + "," + -u.r4], ["l 0," + (u.r4 + u.r1 - o)], ["a " + u.r1 + "," + u.r1 + ",0,0,1," + u.r1 + "," + -u.r1], ["z"]].join(" ");
      }, e._formatPath = function (t) {
        return ~(t = t.map(function (t) {
          return t.join(" ");
        }).join("")).indexOf("NaN") ? "" : t;
      }, e._setTransform = function (t) {
        for (var e = t._attrs.matrix, n = t._cfg.el, r = [], i = 0; i < 9; i += 3) {
          r.push(e[i] + "," + e[i + 1]);
        }

        -1 === (r = r.join(",")).indexOf("NaN") ? n.setAttribute("transform", "matrix(" + r + ")") : console.warn("invalid matrix:", e);
      }, e._setImage = function (t, e) {
        var n = t._attrs,
            i = t._cfg.el;
        if (r.isString(e)) i.setAttribute("href", e);else if (e instanceof Image) n.width || (i.setAttribute("width", e.width), t._attrs.width = e.width), n.height || (i.setAttribute("height", e.height), t._attrs.height = e.height), i.setAttribute("href", e.src);else if (e instanceof HTMLElement && r.isString(e.nodeName) && "CANVAS" === e.nodeName.toUpperCase()) i.setAttribute("href", e.toDataURL());else if (e instanceof ImageData) {
          var a = document.createElement("canvas");
          a.setAttribute("width", e.width), a.setAttribute("height", e.height), a.getContext("2d").putImageData(e, 0, 0), n.width || (i.setAttribute("width", e.width), t._attrs.width = e.width), n.height || (i.setAttribute("height", e.height), t._attrs.height = e.height), i.setAttribute("href", a.toDataURL());
        }
      }, e._updateFan = function (t) {
        function e(t, e, n) {
          return {
            x: e * Math.cos(t) + n.x,
            y: e * Math.sin(t) + n.y
          };
        }

        var n = t._attrs,
            i = t._cfg,
            a = {
          x: n.x,
          y: n.y
        },
            o = [],
            s = n.startAngle,
            u = n.endAngle;
        r.isNumberEqual(u - s, 2 * Math.PI) && (u -= 1e-5);
        var c = e(s, n.re, a),
            h = e(u, n.re, a),
            f = u > s ? 1 : 0,
            l = Math.abs(u - s) > Math.PI ? 1 : 0,
            p = n.rs,
            d = n.re,
            g = e(s, n.rs, a),
            v = e(u, n.rs, a);
        n.rs > 0 ? (o.push("M " + h.x + "," + h.y), o.push("L " + v.x + "," + v.y), o.push("A " + p + "," + p + ",0," + l + "," + (1 === f ? 0 : 1) + "," + g.x + "," + g.y), o.push("L " + c.x + " " + c.y)) : (o.push("M " + a.x + "," + a.y), o.push("L " + c.x + "," + c.y)), o.push("A " + d + "," + d + ",0," + l + "," + f + "," + h.x + "," + h.y), n.rs > 0 ? o.push("L " + v.x + "," + v.y) : o.push("Z"), i.el.setAttribute("d", o.join(" "));
      }, e._updateText = function (t) {
        var e = t._attrs,
            n = t._cfg.attrs,
            r = t._cfg.el;

        for (var i in this._setFont(t), e) {
          if (e[i] !== n[i]) {
            if ("text" === i) {
              this._setText(t, "" + e[i]);

              continue;
            }

            if ("fillStyle" === i || "strokeStyle" === i) {
              this._setColor(t, i, e[i]);

              continue;
            }

            if ("matrix" === i) {
              this._setTransform(t);

              continue;
            }

            u[i] && r.setAttribute(u[i], e[i]);
          }
        }

        t._cfg.attrs = Object.assign({}, t._attrs), t._cfg.hasUpdate = !1;
      }, e._setFont = function (t) {
        var e = t.get("el"),
            n = t._attrs,
            r = n.fontSize;
        e.setAttribute("alignment-baseline", c[n.textBaseline] || "baseline"), e.setAttribute("text-anchor", h[n.textAlign] || "left"), r && +r < 12 && (n.matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1], t.transform([["t", -n.x, -n.y], ["s", +r / 12, +r / 12], ["t", n.x, n.y]]));
      }, e._setText = function (t, e) {
        var n = t._cfg.el,
            i = t._attrs.textBaseline || "bottom";
        if (e) {
          if (~e.indexOf("\n")) {
            var a = t._attrs.x,
                o = e.split("\n"),
                s = o.length - 1,
                u = "";
            r.each(o, function (t, e) {
              0 === e ? "alphabetic" === i ? u += '<tspan x="' + a + '" dy="' + -s + 'em">' + t + "</tspan>" : "top" === i ? u += '<tspan x="' + a + '" dy="0.9em">' + t + "</tspan>" : "middle" === i ? u += '<tspan x="' + a + '" dy="' + -(s - 1) / 2 + 'em">' + t + "</tspan>" : "bottom" === i ? u += '<tspan x="' + a + '" dy="-' + (s + .3) + 'em">' + t + "</tspan>" : "hanging" === i && (u += '<tspan x="' + a + '" dy="' + (-(s - 1) - .3) + 'em">' + t + "</tspan>") : u += '<tspan x="' + a + '" dy="1em">' + t + "</tspan>";
            }), n.innerHTML = u;
          } else n.innerHTML = e;
        } else n.innerHTML = "";
      }, e._setClip = function (t, e) {
        var n = t._cfg.el;
        if (e) {
          if (n.hasAttribute("clip-path")) e._cfg.hasUpdate && this._updateShape(e);else {
            this._createDom(e), this._updateShape(e);
            var r = this.context.addClip(e);
            n.setAttribute("clip-path", "url(#" + r + ")");
          }
        } else n.removeAttribute("clip-path");
      }, e._setColor = function (t, e, n) {
        var r = t._cfg.el,
            i = this.context;
        if (n) {
          if (n = n.trim(), /^[r,R,L,l]{1}[\s]*\(/.test(n)) {
            var a = i.find("gradient", n);
            a || (a = i.addGradient(n)), r.setAttribute(u[e], "url(#" + a + ")");
          } else if (/^[p,P]{1}[\s]*\(/.test(n)) {
            var o = i.find("pattern", n);
            o || (o = i.addPattern(n)), r.setAttribute(u[e], "url(#" + o + ")");
          } else r.setAttribute(u[e], n);
        } else r.setAttribute(u[e], "none");
      }, e._setShadow = function (t) {
        var e = t._cfg.el,
            n = t._attrs,
            r = {
          dx: n.shadowOffsetX,
          dy: n.shadowOffsetY,
          blur: n.shadowBlur,
          color: n.shadowColor
        };

        if (r.dx || r.dy || r.blur || r.color) {
          var i = this.context.find("filter", r);
          i || (i = this.context.addShadow(r, this)), e.setAttribute("filter", "url(#" + i + ")");
        } else e.removeAttribute("filter");
      }, t;
    }();

    t.exports = f;
  }, function (t, e, n) {
    t.exports = {
      painter: n(735),
      getShape: n(728)
    };
  }, function (t, e, n) {
    var r = n(19),
        i = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/gi,
        a = /[^\s\,]+/gi,
        o = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i,
        s = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i,
        u = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i,
        c = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;

    function h(t, e) {
      var n = t.match(c);
      r.each(n, function (t) {
        t = t.split(":"), e.addColorStop(t[0], t[1]);
      });
    }

    t.exports = {
      parsePath: function parsePath(t) {
        return t = t || [], r.isArray(t) ? t : r.isString(t) ? (t = t.match(i), r.each(t, function (e, n) {
          if ((e = e.match(a))[0].length > 1) {
            var i = e[0].charAt(0);
            e.splice(1, 0, e[0].substr(1)), e[0] = i;
          }

          r.each(e, function (t, n) {
            isNaN(t) || (e[n] = +t);
          }), t[n] = e;
        }), t) : void 0;
      },
      parseStyle: function parseStyle(t, e, n) {
        if (r.isString(t)) {
          if ("(" === t[1] || "(" === t[2]) {
            if ("l" === t[0]) return function (t, e, n) {
              var i,
                  a,
                  s = o.exec(t),
                  u = r.mod(r.toRadian(parseFloat(s[1])), 2 * Math.PI),
                  c = s[2],
                  f = e.getBBox();
              u >= 0 && u < .5 * Math.PI ? (i = {
                x: f.minX,
                y: f.minY
              }, a = {
                x: f.maxX,
                y: f.maxY
              }) : .5 * Math.PI <= u && u < Math.PI ? (i = {
                x: f.maxX,
                y: f.minY
              }, a = {
                x: f.minX,
                y: f.maxY
              }) : Math.PI <= u && u < 1.5 * Math.PI ? (i = {
                x: f.maxX,
                y: f.maxY
              }, a = {
                x: f.minX,
                y: f.minY
              }) : (i = {
                x: f.minX,
                y: f.maxY
              }, a = {
                x: f.maxX,
                y: f.minY
              });
              var l = Math.tan(u),
                  p = l * l,
                  d = (a.x - i.x + l * (a.y - i.y)) / (p + 1) + i.x,
                  g = l * (a.x - i.x + l * (a.y - i.y)) / (p + 1) + i.y,
                  v = n.createLinearGradient(i.x, i.y, d, g);
              return h(c, v), v;
            }(t, e, n);
            if ("r" === t[0]) return function (t, e, n) {
              var r = s.exec(t),
                  i = parseFloat(r[1]),
                  a = parseFloat(r[2]),
                  o = parseFloat(r[3]),
                  u = r[4];

              if (0 === o) {
                var f = u.match(c);
                return f[f.length - 1].split(":")[1];
              }

              var l = e.getBBox(),
                  p = l.maxX - l.minX,
                  d = l.maxY - l.minY,
                  g = Math.sqrt(p * p + d * d) / 2,
                  v = n.createRadialGradient(l.minX + p * i, l.minY + d * a, o * g, l.minX + p / 2, l.minY + d / 2, g);
              return h(u, v), v;
            }(t, e, n);
            if ("p" === t[0]) return function (t, e, n) {
              if (e.get("patternSource") && e.get("patternSource") === t) return e.get("pattern");
              var r,
                  i,
                  a = u.exec(t),
                  o = a[1],
                  s = a[2];

              function c() {
                r = n.createPattern(i, o), e.setSilent("pattern", r), e.setSilent("patternSource", t);
              }

              switch (o) {
                case "a":
                  o = "repeat";
                  break;

                case "x":
                  o = "repeat-x";
                  break;

                case "y":
                  o = "repeat-y";
                  break;

                case "n":
                  o = "no-repeat";
                  break;

                default:
                  o = "no-repeat";
              }

              return i = new Image(), s.match(/^data:/i) || (i.crossOrigin = "Anonymous"), i.src = s, i.complete ? c() : (i.onload = c, i.src = i.src), r;
            }(t, e, n);
          }

          return t;
        }
      }
    };
  }, function (t, e, n) {
    var r = n(19),
        i = n(737),
        a = ["fillStyle", "font", "globalAlpha", "lineCap", "lineWidth", "lineJoin", "miterLimit", "shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY", "strokeStyle", "textAlign", "textBaseline", "lineDash", "lineDashOffset"],
        o = function () {
      function t(t) {
        if (!t) return null;
        var e = r.uniqueId("canvas_"),
            n = r.createDom('<canvas id="' + e + '"></canvas>');
        return t.appendChild(n), this.type = "canvas", this.canvas = n, this.context = n.getContext("2d"), this.toDraw = !1, this;
      }

      var e = t.prototype;
      return e.beforeDraw = function () {
        var t = this.canvas;
        this.context && this.context.clearRect(0, 0, t.width, t.height);
      }, e.draw = function (t) {
        var e = this;
        e.animateHandler ? e.toDraw = !0 : function n() {
          e.animateHandler = r.requestAnimationFrame(function () {
            e.animateHandler = void 0, e.toDraw && n();
          }), e.beforeDraw();

          try {
            e._drawGroup(t);
          } catch (t) {
            console.warn("error in draw canvas, detail as:"), console.warn(t), e.toDraw = !1;
          }

          e.toDraw = !1;
        }();
      }, e.drawSync = function (t) {
        this.beforeDraw(), this._drawGroup(t);
      }, e._drawGroup = function (t) {
        if (!t._cfg.removed && !t._cfg.destroyed && t._cfg.visible) {
          var e = t._cfg.children,
              n = null;
          this.setContext(t);

          for (var r = 0; r < e.length; r++) {
            n = e[r], e[r].isGroup ? this._drawGroup(n) : this._drawShape(n);
          }

          this.restoreContext(t);
        }
      }, e._drawShape = function (t) {
        t._cfg.removed || t._cfg.destroyed || !t._cfg.visible || (this.setContext(t), t.drawInner(this.context), this.restoreContext(t), t._cfg.attrs = t._attrs, t._cfg.hasUpdate = !1);
      }, e.setContext = function (t) {
        var e = this.context,
            n = t._attrs.clip;
        e.save(), n && (n.resetTransform(e), n.createPath(e), e.clip()), this.resetContext(t), t.resetTransform(e);
      }, e.restoreContext = function () {
        this.context.restore();
      }, e.resetContext = function (t) {
        var e = this.context,
            n = t._attrs;
        if (!t.isGroup) for (var o in n) {
          if (a.indexOf(o) > -1) {
            var s = n[o];
            "fillStyle" === o && (s = i.parseStyle(s, t, e)), "strokeStyle" === o && (s = i.parseStyle(s, t, e)), "lineDash" === o && e.setLineDash ? r.isArray(s) ? e.setLineDash(s) : r.isString(s) && e.setLineDash(s.split(" ")) : e[o] = s;
          }
        }
      }, t;
    }();

    t.exports = o;
  }, function (t, e, n) {
    t.exports = {
      painter: n(738)
    };
  }, function (t, e, n) {
    t.exports = {
      canvas: n(739),
      svg: n(736)
    };
  }, function (t, e, n) {
    var r = n(19),
        i = n(610),
        a = n(17),
        o = n(44),
        s = n(238),
        u = s.interpolate,
        c = s.interpolateArray,
        h = function h(t) {
      this._animators = [], this._current = 0, this._timer = null, this.canvas = t;
    };

    function f(t, e, n) {
      var a,
          s = e.startTime;
      if (n < s + e.delay || e.isPaused) return !1;
      var h = e.duration,
          f = e.easing;
      if (n = n - s - e.delay, e.toAttrs.repeat) a = n % h / h, a = o[f](a);else {
        if (!((a = n / h) < 1)) return t.attr(e.toAttrs), e.toMatrix && t.setMatrix(e.toMatrix), !0;
        a = o[f](a);
      }
      return function (t, e, n) {
        var a = {},
            o = e.toAttrs,
            s = e.fromAttrs,
            h = e.toMatrix;

        if (!t.get("destroyed")) {
          var f;

          for (var l in o) {
            if (!r.isEqual(s[l], o[l])) if ("path" === l) {
              var p = o[l],
                  d = s[l];
              p.length > d.length ? (p = i.parsePathString(o[l]), d = i.parsePathString(s[l]), d = i.fillPathByDiff(d, p), d = i.formatPath(d, p), e.fromAttrs.path = d, e.toAttrs.path = p) : e.pathFormatted || (p = i.parsePathString(o[l]), d = i.parsePathString(s[l]), d = i.formatPath(d, p), e.fromAttrs.path = d, e.toAttrs.path = p, e.pathFormatted = !0), a[l] = [];

              for (var g = 0; g < p.length; g++) {
                for (var v = p[g], m = d[g], x = [], y = 0; y < v.length; y++) {
                  r.isNumber(v[y]) && m && r.isNumber(m[y]) ? (f = u(m[y], v[y]), x.push(f(n))) : x.push(v[y]);
                }

                a[l].push(x);
              }
            } else f = u(s[l], o[l]), a[l] = f(n);
          }

          if (h) {
            var b = c(e.fromMatrix, h)(n);
            t.setMatrix(b);
          }

          t.attr(a);
        }
      }(t, e, a), !1;
    }

    r.augment(h, {
      initTimer: function initTimer() {
        var t,
            e,
            n,
            r = this,
            i = this;
        i._timer = a.timer(function (a) {
          if (i._current = a, r._animators.length > 0) {
            for (var o = r._animators.length - 1; o >= 0; o--) {
              if ((t = r._animators[o]).get("destroyed")) i.removeAnimator(o);else {
                if (!t.get("pause").isPaused) for (var s = (e = t.get("animators")).length - 1; s >= 0; s--) {
                  n = e[s], f(t, n, a) && (e.splice(s, 1), !1, n.callback && n.callback());
                }
                0 === e.length && i.removeAnimator(o);
              }
            }

            r.canvas.draw();
          }
        });
      },
      addAnimator: function addAnimator(t) {
        this._animators.push(t);
      },
      removeAnimator: function removeAnimator(t) {
        this._animators.splice(t, 1);
      },
      isAnimating: function isAnimating() {
        return !!this._animators.length;
      },
      stop: function stop() {
        this._timer && this._timer.stop();
      },
      stopAllAnimations: function stopAllAnimations() {
        this._animators.forEach(function (t) {
          t.stopAnimate();
        }), this._animators = [], this.canvas.draw();
      },
      getTime: function getTime() {
        return this._current;
      }
    }), t.exports = h;
  }, function (t, e, n) {
    var r = n(19),
        i = n(613),
        a = {
      arc: n(602),
      ellipse: n(639),
      line: n(603)
    },
        o = r.createDom('<canvas width="500" height="500"></canvas>').getContext("2d");

    function s(t, e, n) {
      return n.createPath(o), o.isPointInPath(t, e);
    }

    var u = {
      arc: function arc(t, e) {
        var n = this._attrs,
            r = n.x,
            a = n.y,
            o = n.r,
            s = n.startAngle,
            u = n.endAngle,
            c = n.clockwise,
            h = this.getHitLineWidth();
        return !!this.hasStroke() && i.arcline(r, a, o, s, u, c, h, t, e);
      },
      circle: function circle(t, e) {
        var n = this._attrs,
            r = n.x,
            a = n.y,
            o = n.r,
            s = this.getHitLineWidth(),
            u = this.hasFill(),
            c = this.hasStroke();
        return u && c ? i.circle(r, a, o, t, e) || i.arcline(r, a, o, 0, 2 * Math.PI, !1, s, t, e) : u ? i.circle(r, a, o, t, e) : !!c && i.arcline(r, a, o, 0, 2 * Math.PI, !1, s, t, e);
      },
      dom: function dom(t, e) {
        if (!this._cfg.el) return !1;

        var n = this._cfg.el.getBBox();

        return i.box(n.x, n.x + n.width, n.y, n.y + n.height, t, e);
      },
      ellipse: function ellipse(t, e) {
        var n = this._attrs,
            a = this.hasFill(),
            o = this.hasStroke(),
            s = n.x,
            u = n.y,
            c = n.rx,
            h = n.ry,
            f = this.getHitLineWidth(),
            l = c > h ? c : h,
            p = c > h ? 1 : c / h,
            d = c > h ? h / c : 1,
            g = [t, e, 1],
            v = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        r.mat3.scale(v, v, [p, d]), r.mat3.translate(v, v, [s, u]);
        var m = r.mat3.invert([], v);
        return r.vec3.transformMat3(g, g, m), a && o ? i.circle(0, 0, l, g[0], g[1]) || i.arcline(0, 0, l, 0, 2 * Math.PI, !1, f, g[0], g[1]) : a ? i.circle(0, 0, l, g[0], g[1]) : !!o && i.arcline(0, 0, l, 0, 2 * Math.PI, !1, f, g[0], g[1]);
      },
      fan: function fan(t, e) {
        var n = this,
            o = n.hasFill(),
            s = n.hasStroke(),
            u = n._attrs,
            c = u.x,
            h = u.y,
            f = u.rs,
            l = u.re,
            p = u.startAngle,
            d = u.endAngle,
            g = u.clockwise,
            v = [t - c, e - h],
            m = r.vec2.angleTo([1, 0], v);

        function x() {
          var t = a.arc.nearAngle(m, p, d, g);

          if (r.isNumberEqual(m, t)) {
            var e = r.vec2.squaredLength(v);
            if (f * f <= e && e <= l * l) return !0;
          }

          return !1;
        }

        function y() {
          var r = n.getHitLineWidth(),
              a = {
            x: Math.cos(p) * f + c,
            y: Math.sin(p) * f + h
          },
              o = {
            x: Math.cos(p) * l + c,
            y: Math.sin(p) * l + h
          },
              s = {
            x: Math.cos(d) * f + c,
            y: Math.sin(d) * f + h
          },
              u = {
            x: Math.cos(d) * l + c,
            y: Math.sin(d) * l + h
          };
          return !!(i.line(a.x, a.y, o.x, o.y, r, t, e) || i.line(s.x, s.y, u.x, u.y, r, t, e) || i.arcline(c, h, f, p, d, g, r, t, e) || i.arcline(c, h, l, p, d, g, r, t, e));
        }

        return o && s ? x() || y() : o ? x() : !!s && y();
      },
      image: function image(t, e) {
        var n = this._attrs;
        if (this.get("toDraw") || !n.img) return !1;
        this._cfg.attrs && this._cfg.attrs.img === n.img || this._setAttrImg();
        var r = n.x,
            a = n.y,
            o = n.width,
            s = n.height;
        return i.rect(r, a, o, s, t, e);
      },
      line: function line(t, e) {
        var n = this._attrs,
            r = n.x1,
            a = n.y1,
            o = n.x2,
            s = n.y2,
            u = this.getHitLineWidth();
        return !!this.hasStroke() && i.line(r, a, o, s, u, t, e);
      },
      path: function path(t, e) {
        var n = this,
            i = n.get("segments"),
            a = n.hasFill(),
            o = n.hasStroke();

        function u() {
          if (!r.isEmpty(i)) {
            for (var a = n.getHitLineWidth(), o = 0, s = i.length; o < s; o++) {
              if (i[o].isInside(t, e, a)) return !0;
            }

            return !1;
          }
        }

        return a && o ? s(t, e, n) || u() : a ? s(t, e, n) : !!o && u();
      },
      marker: function marker(t, e) {
        var n = this._attrs,
            r = n.x,
            a = n.y,
            o = n.radius || n.r,
            s = this.getHitLineWidth();
        return i.circle(r, a, o + s / 2, t, e);
      },
      polygon: function polygon(t, e) {
        var n = this,
            r = n.hasFill(),
            a = n.hasStroke();

        function o() {
          var r = n._attrs.points;
          if (r.length < 2) return !1;
          var a = n.getHitLineWidth(),
              o = r.slice(0);
          return r.length >= 3 && o.push(r[0]), i.polyline(o, a, t, e);
        }

        return r && a ? s(t, e, n) || o() : r ? s(t, e, n) : !!a && o();
      },
      polyline: function polyline(t, e) {
        var n = this._attrs;

        if (this.hasStroke()) {
          var r = n.points;
          if (r.length < 2) return !1;
          var a = n.lineWidth;
          return i.polyline(r, a, t, e);
        }

        return !1;
      },
      rect: function rect(t, e) {
        var n = this,
            r = n.hasFill(),
            a = n.hasStroke();

        function o() {
          var r = n._attrs,
              a = r.x,
              o = r.y,
              s = r.width,
              u = r.height,
              c = r.radius,
              h = n.getHitLineWidth();

          if (0 === c) {
            var f = h / 2;
            return i.line(a - f, o, a + s + f, o, h, t, e) || i.line(a + s, o - f, a + s, o + u + f, h, t, e) || i.line(a + s + f, o + u, a - f, o + u, h, t, e) || i.line(a, o + u + f, a, o - f, h, t, e);
          }

          return i.line(a + c, o, a + s - c, o, h, t, e) || i.line(a + s, o + c, a + s, o + u - c, h, t, e) || i.line(a + s - c, o + u, a + c, o + u, h, t, e) || i.line(a, o + u - c, a, o + c, h, t, e) || i.arcline(a + s - c, o + c, c, 1.5 * Math.PI, 2 * Math.PI, !1, h, t, e) || i.arcline(a + s - c, o + u - c, c, 0, .5 * Math.PI, !1, h, t, e) || i.arcline(a + c, o + u - c, c, .5 * Math.PI, Math.PI, !1, h, t, e) || i.arcline(a + c, o + c, c, Math.PI, 1.5 * Math.PI, !1, h, t, e);
        }

        return r && a ? s(t, e, n) || o() : r ? s(t, e, n) : !!a && o();
      },
      text: function text(t, e) {
        var n = this.getBBox();
        if (this.hasFill() || this.hasStroke()) return i.box(n.minX, n.maxX, n.minY, n.maxY, t, e);
      }
    };
    t.exports = {
      isPointInPath: function isPointInPath(t, e) {
        var n = u[this.type];
        return !!n && n.call(this, t, e);
      }
    };
  }, function (t, e, n) {
    var r = n(58);
    r.Arc = n(638), r.Circle = n(637), r.Dom = n(636), r.Ellipse = n(635), r.Fan = n(634), r.Image = n(633), r.Line = n(632), r.Marker = n(611), r.Path = n(631), r.Polygon = n(630), r.Polyline = n(629), r.Rect = n(628), r.Text = n(627), t.exports = r;
  }, function (t, e, n) {
    var r = n(19),
        i = {
      delay: "delay",
      rotate: "rotate"
    },
        a = {
      fill: "fill",
      stroke: "stroke",
      fillStyle: "fillStyle",
      strokeStyle: "strokeStyle"
    };
    t.exports = {
      animate: function animate(t, e, n, o, s) {
        void 0 === s && (s = 0);
        this.set("animating", !0);
        var u = this.get("timeline");
        u || (u = this.get("canvas").get("timeline"), this.setSilent("timeline", u));
        var c = this.get("animators") || [];
        u._timer || u.initTimer(), r.isNumber(o) && (s = o, o = null), r.isFunction(n) ? (o = n, n = "easeLinear") : n = n || "easeLinear";

        var h = function (t, e) {
          var n = {
            matrix: null,
            attrs: {}
          },
              o = e._attrs;

          for (var s in t) {
            if ("transform" === s) n.matrix = r.transform(e.getMatrix(), t[s]);else if ("rotate" === s) n.matrix = r.transform(e.getMatrix(), [["r", t[s]]]);else if ("matrix" === s) n.matrix = t[s];else {
              if (a[s] && /^[r,R,L,l]{1}[\s]*\(/.test(t[s])) continue;
              i[s] || o[s] === t[s] || (n.attrs[s] = t[s]);
            }
          }

          return n;
        }(t, this),
            f = {
          fromAttrs: function (t, e) {
            var n = {},
                r = e._attrs;

            for (var i in t.attrs) {
              n[i] = r[i];
            }

            return n;
          }(h, this),
          toAttrs: h.attrs,
          fromMatrix: r.clone(this.getMatrix()),
          toMatrix: h.matrix,
          duration: e,
          easing: n,
          callback: o,
          delay: s,
          startTime: u.getTime(),
          id: r.uniqueId()
        };

        c.length > 0 ? c = function (t, e) {
          var n = e.delay,
              i = Object.prototype.hasOwnProperty;
          return r.each(e.toAttrs, function (e, a) {
            r.each(t, function (t) {
              n < t.startTime + t.duration && i.call(t.toAttrs, a) && (delete t.toAttrs[a], delete t.fromAttrs[a]);
            });
          }), e.toMatrix && r.each(t, function (t) {
            n < t.startTime + t.duration && t.toMatrix && delete t.toMatrix;
          }), t;
        }(c, f) : u.addAnimator(this), c.push(f), this.setSilent("animators", c), this.setSilent("pause", {
          isPaused: !1
        });
      },
      stopAnimate: function stopAnimate() {
        var t = this,
            e = this.get("animators");
        r.each(e, function (e) {
          t.attr(e.toAttrs), e.toMatrix && t.attr("matrix", e.toMatrix), e.callback && e.callback();
        }), this.setSilent("animating", !1), this.setSilent("animators", []);
      },
      pauseAnimate: function pauseAnimate() {
        var t = this.get("timeline");
        return this.setSilent("pause", {
          isPaused: !0,
          pauseTime: t.getTime()
        }), this;
      },
      resumeAnimate: function resumeAnimate() {
        var t = this.get("timeline").getTime(),
            e = this.get("animators"),
            n = this.get("pause").pauseTime;
        return r.each(e, function (e) {
          e.startTime = e.startTime + (t - n), e._paused = !1, e._pauseTime = null;
        }), this.setSilent("pause", {
          isPaused: !1
        }), this.setSilent("animators", e), this;
      }
    };
  }, function (t, e, n) {
    var r = n(19);

    function i(t) {
      return 1 === t[0] && 0 === t[1] && 0 === t[3] && 1 === t[4] && 0 === t[6] && 0 === t[7];
    }

    function a(t) {
      return 0 === t[1] && 0 === t[3] && 0 === t[6] && 0 === t[7];
    }

    function o(t, e) {
      i(e) || (a(e) ? (t[0] *= e[0], t[4] *= e[4]) : r.mat3.multiply(t, t, e));
    }

    t.exports = {
      initTransform: function initTransform() {},
      resetMatrix: function resetMatrix() {
        this.attr("matrix", [1, 0, 0, 0, 1, 0, 0, 0, 1]);
      },
      translate: function translate(t, e) {
        var n = this._attrs.matrix;
        return r.mat3.translate(n, n, [t, e]), this.clearTotalMatrix(), this.attr("matrix", n), this;
      },
      rotate: function rotate(t) {
        var e = this._attrs.matrix;
        return r.mat3.rotate(e, e, t), this.clearTotalMatrix(), this.attr("matrix", e), this;
      },
      scale: function scale(t, e) {
        var n = this._attrs.matrix;
        return r.mat3.scale(n, n, [t, e]), this.clearTotalMatrix(), this.attr("matrix", n), this;
      },
      rotateAtStart: function rotateAtStart(t) {
        var e = this._attrs.x || this._cfg.attrs.x,
            n = this._attrs.y || this._cfg.attrs.y;
        return Math.abs(t) > 2 * Math.PI && (t = t / 180 * Math.PI), this.transform([["t", -e, -n], ["r", t], ["t", e, n]]);
      },
      move: function move(t, e) {
        var n = this.get("x") || 0,
            r = this.get("y") || 0;
        return this.translate(t - n, e - r), this.set("x", t), this.set("y", e), this;
      },
      transform: function transform(t) {
        var e = this,
            n = this._attrs.matrix;
        return r.each(t, function (t) {
          switch (t[0]) {
            case "t":
              e.translate(t[1], t[2]);
              break;

            case "s":
              e.scale(t[1], t[2]);
              break;

            case "r":
              e.rotate(t[1]);
              break;

            case "m":
              e.attr("matrix", r.mat3.multiply([], n, t[1])), e.clearTotalMatrix();
          }
        }), e;
      },
      setTransform: function setTransform(t) {
        return this.attr("matrix", [1, 0, 0, 0, 1, 0, 0, 0, 1]), this.transform(t);
      },
      getMatrix: function getMatrix() {
        return this.attr("matrix");
      },
      setMatrix: function setMatrix(t) {
        return this.attr("matrix", t), this.clearTotalMatrix(), this;
      },
      apply: function apply(t, e) {
        var n;
        return n = e ? this._getMatrixByRoot(e) : this.attr("matrix"), r.vec3.transformMat3(t, t, n), this;
      },
      _getMatrixByRoot: function _getMatrixByRoot(t) {
        t = t || this;

        for (var e = this, n = []; e !== t;) {
          n.unshift(e), e = e.get("parent");
        }

        n.unshift(e);
        var i = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        return r.each(n, function (t) {
          r.mat3.multiply(i, t.attr("matrix"), i);
        }), i;
      },
      getTotalMatrix: function getTotalMatrix() {
        var t = this._cfg.totalMatrix;

        if (!t) {
          t = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          var e = this._cfg.parent;
          if (e) o(t, e.getTotalMatrix());
          o(t, this.attr("matrix")), this._cfg.totalMatrix = t;
        }

        return t;
      },
      clearTotalMatrix: function clearTotalMatrix() {},
      invert: function invert(t) {
        var e = this.getTotalMatrix();
        if (a(e)) t[0] /= e[0], t[1] /= e[4];else {
          var n = r.mat3.invert([], e);
          n && r.vec3.transformMat3(t, t, n);
        }
        return this;
      },
      resetTransform: function resetTransform(t) {
        var e = this.attr("matrix");
        i(e) || t.transform(e[0], e[1], e[3], e[4], e[6], e[7]);
      }
    };
  }, function (t, e, n) {
    var r = n(19);
    t.exports = {
      canFill: !1,
      canStroke: !1,
      initAttrs: function initAttrs(t) {
        return this._attrs = {
          opacity: 1,
          fillOpacity: 1,
          strokeOpacity: 1,
          matrix: [1, 0, 0, 0, 1, 0, 0, 0, 1]
        }, this.attr(r.assign(this.getDefaultAttrs(), t)), this;
      },
      getDefaultAttrs: function getDefaultAttrs() {
        return {};
      },
      attr: function attr(t, e) {
        if (0 === arguments.length) return this._attrs;

        if (r.isObject(t)) {
          for (var n in t) {
            this._setAttr(n, t[n]);
          }

          return this.clearBBox(), this._cfg.hasUpdate = !0, this;
        }

        return 2 === arguments.length ? (this._setAttr(t, e), this.clearBBox(), this._cfg.hasUpdate = !0, this) : this._attrs[t];
      },
      _setAttr: function _setAttr(t, e) {
        var n = this._attrs;
        n[t] = e, "fill" !== t && "stroke" !== t ? "opacity" !== t ? "clip" === t && e ? this._setClip(e) : "path" === t && this._afterSetAttrPath ? this._afterSetAttrPath(e) : "transform" !== t ? "rotate" === t && this.rotateAtStart(e) : this.transform(e) : n.globalAlpha = e : n[t + "Style"] = e;
      },
      clearBBox: function clearBBox() {
        this.setSilent("box", null);
      },
      hasFill: function hasFill() {
        return this.canFill && this._attrs.fillStyle;
      },
      hasStroke: function hasStroke() {
        return this.canStroke && this._attrs.strokeStyle;
      },
      _setClip: function _setClip(t) {
        t._cfg.renderer = this._cfg.renderer, t._cfg.canvas = this._cfg.canvas, t._cfg.parent = this._cfg.parent, t.hasFill = function () {
          return !0;
        };
      }
    };
  }, function (t, e, n) {
    var r = n(19),
        i = n(643),
        a = n(642),
        o = n(741),
        s = n(740),
        u = function t(e) {
      t.superclass.constructor.call(this, e);
    };

    u.CFG = {
      eventEnable: !0,
      width: null,
      height: null,
      widthCanvas: null,
      heightCanvas: null,
      widthStyle: null,
      heightStyle: null,
      containerDOM: null,
      canvasDOM: null,
      pixelRatio: null,
      renderer: "canvas"
    }, r.extend(u, a), r.augment(u, {
      init: function init() {
        u.superclass.init.call(this), this._setGlobalParam(), this._setContainer(), this._initPainter(), this._scale(), this.get("eventEnable") && this._registEvents();
      },
      getEmitter: function getEmitter(t, e) {
        if (t) {
          if (!r.isEmpty(t._getEvents())) return t;
          var n = t.get("parent");
          if (n && !e.propagationStopped) return this.getEmitter(n, e);
        }
      },
      _getEventObj: function _getEventObj(t, e, n, r) {
        var a = new i(t, e, !0, !0);
        return a.x = n.x, a.y = n.y, a.clientX = e.clientX, a.clientY = e.clientY, a.currentTarget = r, a.target = r, a;
      },
      _triggerEvent: function _triggerEvent(t, e) {
        var n,
            r = this.getPointByClient(e.clientX, e.clientY),
            i = this.getShape(r.x, r.y, e),
            a = this.get("el");

        if ("mousemove" === t) {
          var o = this.get("preShape");

          if (o && o !== i) {
            var s = this._getEventObj("mouseleave", e, r, o);

            (n = this.getEmitter(o, e)) && n.emit("mouseleave", s), a.style.cursor = "default";
          }

          if (i) {
            var u = this._getEventObj("mousemove", e, r, i);

            if ((n = this.getEmitter(i, e)) && n.emit("mousemove", u), o !== i) {
              var c = this._getEventObj("mouseenter", e, r, i);

              n && n.emit("mouseenter", c, e);
            }
          } else {
            var h = this._getEventObj("mousemove", e, r, this);

            this.emit("mousemove", h);
          }

          this.set("preShape", i);
        } else {
          var f = this._getEventObj(t, e, r, i || this);

          (n = this.getEmitter(i, e)) && n !== this && n.emit(t, f), this.emit(t, f);
        }

        i && !i.get("destroyed") && (a.style.cursor = i.attr("cursor") || "default");
      },
      _registEvents: function _registEvents() {
        var t = this,
            e = t.get("el");
        r.each(["mouseout", "mouseover", "mousemove", "mousedown", "mouseleave", "mouseup", "click", "dblclick"], function (n) {
          e.addEventListener(n, function (e) {
            t._triggerEvent(n, e);
          }, !1);
        }), e.addEventListener("touchstart", function (e) {
          r.isEmpty(e.touches) || t._triggerEvent("touchstart", e.touches[0]);
        }, !1), e.addEventListener("touchmove", function (e) {
          r.isEmpty(e.touches) || t._triggerEvent("touchmove", e.touches[0]);
        }, !1), e.addEventListener("touchend", function (e) {
          r.isEmpty(e.changedTouches) || t._triggerEvent("touchend", e.changedTouches[0]);
        }, !1);
      },
      _scale: function _scale() {
        if ("svg" !== this._cfg.renderType) {
          var t = this.get("pixelRatio");
          this.scale(t, t);
        }
      },
      _setGlobalParam: function _setGlobalParam() {
        var t = this.get("renderer") || "canvas";
        "svg" === t ? this.set("pixelRatio", 1) : this.get("pixelRatio") || this.set("pixelRatio", r.getRatio()), this._cfg.renderType = t;
        var e = s[t];
        this._cfg.renderer = e, this._cfg.canvas = this;
        var n = new o(this);
        this._cfg.timeline = n;
      },
      _setContainer: function _setContainer() {
        var t = this.get("containerId"),
            e = this.get("containerDOM");
        e || (e = document.getElementById(t), this.set("containerDOM", e)), r.modifyCSS(e, {
          position: "relative"
        });
      },
      _initPainter: function _initPainter() {
        var t = this.get("containerDOM"),
            e = new this._cfg.renderer.painter(t);
        this._cfg.painter = e, this._cfg.canvasDOM = this._cfg.el = e.canvas, this.changeSize(this.get("width"), this.get("height"));
      },
      _resize: function _resize() {
        var t = this.get("canvasDOM"),
            e = this.get("widthCanvas"),
            n = this.get("heightCanvas"),
            r = this.get("widthStyle"),
            i = this.get("heightStyle");
        t.style.width = r, t.style.height = i, t.setAttribute("width", e), t.setAttribute("height", n);
      },
      getWidth: function getWidth() {
        var t = this.get("pixelRatio");
        return this.get("width") * t;
      },
      getHeight: function getHeight() {
        var t = this.get("pixelRatio");
        return this.get("height") * t;
      },
      changeSize: function changeSize(t, e) {
        var n = this.get("pixelRatio"),
            r = t * n,
            i = e * n;
        this.set("widthCanvas", r), this.set("heightCanvas", i), this.set("widthStyle", t + "px"), this.set("heightStyle", e + "px"), this.set("width", t), this.set("height", e), this._resize();
      },
      getPointByClient: function getPointByClient(t, e) {
        var n = this.get("el"),
            r = this.get("pixelRatio") || 1,
            i = n.getBoundingClientRect();
        return {
          x: (t - i.left) * r,
          y: (e - i.top) * r
        };
      },
      getClientByPoint: function getClientByPoint(t, e) {
        var n = this.get("el").getBoundingClientRect(),
            r = this.get("pixelRatio") || 1;
        return {
          clientX: t / r + n.left,
          clientY: e / r + n.top
        };
      },
      draw: function draw() {
        this._cfg.painter.draw(this);
      },
      getShape: function getShape(t, e, n) {
        return 3 === arguments.length && this._cfg.renderer.getShape ? this._cfg.renderer.getShape.call(this, t, e, n) : u.superclass.getShape.call(this, t, e);
      },
      getRenderer: function getRenderer() {
        return this._cfg.renderType;
      },
      _drawSync: function _drawSync() {
        this._cfg.painter.drawSync(this);
      },
      destroy: function destroy() {
        var t = this._cfg,
            e = t.containerDOM,
            n = t.canvasDOM;
        n && e && e.removeChild(n), t.timeline.stop(), u.superclass.destroy.call(this);
      }
    }), t.exports = u;
  }, function (t, e, n) {
    var r = n(248),
        i = {};
    n(257).mix(i, r.PathUtil, {
      getRectPath: r.PathUtil.rectPath,
      pointsToPolygon: function pointsToPolygon(t) {
        for (var e = [["M", t[0].x, t[0].y]], n = 1; n < t.length; n++) {
          var r = t[n];
          e.push(["L", r.x, r.y]);
        }

        return e;
      },
      getEllipsePath: function getEllipsePath(t, e, n, r) {
        return [["M", t, e - r], ["a", n, r, 0, 1, 1, 0, 2 * r], ["a", n, r, 0, 1, 1, 0, -2 * r], ["z"]];
      }
    }), t.exports = i;
  }, function (t, e, n) {
    var r = n(645),
        i = n(16),
        a = "Expected a function";

    t.exports = function (t, e, n) {
      var o = !0,
          s = !0;
      if ("function" != typeof t) throw new TypeError(a);
      return i(n) && (o = "leading" in n ? !!n.leading : o, s = "trailing" in n ? !!n.trailing : s), r(t, e, {
        leading: o,
        maxWait: e,
        trailing: s
      });
    };
  }, function (t, e) {
    t.exports = function (t, e, n) {
      var r = void 0,
          i = void 0,
          a = void 0,
          o = void 0,
          s = 0;
      n || (n = {});

      var u = function u() {
        s = !1 === n.leading ? 0 : Date.now(), r = null, o = t.apply(i, a), r || (i = a = null);
      },
          c = function c() {
        var c = Date.now();
        s || !1 !== n.leading || (s = c);
        var h = e - (c - s);
        return i = this, a = arguments, h <= 0 || h > e ? (r && (clearTimeout(r), r = null), s = c, o = t.apply(i, a), r || (i = a = null)) : r || !1 === n.trailing || (r = setTimeout(u, h)), o;
      };

      return c.cancel = function () {
        clearTimeout(r), s = 0, r = i = a = null;
      }, c;
    };
  }, function (t, e, n) {
    var r = n(46),
        i = n(596),
        a = Object.prototype.hasOwnProperty;

    t.exports = function (t, e) {
      if (null === t || !i(t)) return {};
      var n = {};
      return r(e, function (e) {
        a.call(t, e) && (n[e] = t[e]);
      }), n;
    };
  }, function (t, e, n) {
    var r = n(46),
        i = n(118);

    t.exports = function (t, e) {
      if (!i(t)) return t;
      var n = [];
      return r(t, function (t, r) {
        n.push(e(t, r));
      }), n;
    };
  }, function (t, e, n) {
    var r = n(84),
        i = n(614);

    t.exports = function (t, e, n) {
      return r(n) ? !!n(t, e) : i(t, e);
    };
  }, function (t, e, n) {
    var r = n(118);

    t.exports = function (t, e) {
      if (!r(t)) return -1;
      var n = Array.prototype.indexOf;
      if (n) return n.call(t, e);

      for (var i = -1, a = 0; a < t.length; a++) {
        if (t[a] === e) {
          i = a;
          break;
        }
      }

      return i;
    };
  }, function (t, e, n) {
    var r = n(649);

    t.exports = function (t, e) {
      if (!e) return [t];
      var n = r(t, e),
          i = [];

      for (var a in n) {
        i.push(n[a]);
      }

      return i;
    };
  }, function (t, e) {
    t.exports = function (t, e, n) {
      var r = void 0;
      return function () {
        var i = this,
            a = arguments,
            o = n && !r;
        clearTimeout(r), r = setTimeout(function () {
          r = null, n || t.apply(i, a);
        }, e), o && t.apply(i, a);
      };
    };
  }, function (t, e, n) {
    var r = n(115);

    t.exports = function (t) {
      return r(t, "Error");
    };
  }, function (t, e, n) {
    var r = n(115);

    t.exports = function (t) {
      return r(t, "Arguments");
    };
  }, function (t, e, n) {
    var r = n(115);

    t.exports = function (t) {
      return r(t, "Date");
    };
  }, function (t, e, n) {
    var r = n(115);

    t.exports = function (t) {
      return r(t, "RegExp");
    };
  }, function (t, e) {
    t.exports = function (t) {
      return void 0 === t;
    };
  }, function (t, e) {
    t.exports = function (t) {
      return null === t;
    };
  }, function (t, e, n) {
    var r = n(115),
        i = {
      getType: n(654),
      isArray: n(45),
      isArrayLike: n(118),
      isBoolean: n(653),
      isFunction: n(84),
      isNil: n(237),
      isNull: n(762),
      isNumber: n(236),
      isObject: n(621),
      isObjectLike: n(619),
      isPlainObject: n(596),
      isPrototype: n(652),
      isType: r,
      isUndefined: n(761),
      isString: n(595),
      isRegExp: n(760),
      isDate: n(759),
      isArguments: n(758),
      isError: n(757)
    };
    t.exports = i;
  }, function (t, e, n) {
    t.exports = n(656);
  }, function (t, e) {
    t.exports = function (t, e) {
      return t && e ? t.replace(/\\?\{([^{}]+)\}/g, function (t, n) {
        return "\\" === t.charAt(0) ? t.slice(1) : void 0 === e[n] ? "" : e[n];
      }) : t;
    };
  }, function (t, e, n) {
    var r = n(594);

    t.exports = function (t) {
      var e = r(t);
      return e.charAt(0).toLowerCase() + e.substring(1);
    };
  }, function (t, e, n) {
    t.exports = n(657);
  }, function (t, e, n) {
    var r = {
      lc: n(767),
      lowerCase: n(657),
      lowerFirst: n(766),
      substitute: n(765),
      uc: n(764),
      upperCase: n(656),
      upperFirst: n(655)
    };
    t.exports = r;
  }, function (t, e) {
    function n(t) {
      var e = [];

      switch (t[0]) {
        case "M":
        case "L":
          e.push([t[1], t[2]]);
          break;

        case "A":
          e.push([t[6], t[7]]);
          break;

        case "Q":
          e.push([t[3], t[4]]), e.push([t[1], t[2]]);
          break;

        case "T":
          e.push([t[1], t[2]]);
          break;

        case "C":
          e.push([t[5], t[6]]), e.push([t[1], t[2]]), e.push([t[3], t[4]]);
          break;

        case "S":
          e.push([t[3], t[4]]), e.push([t[1], t[2]]);
          break;

        case "H":
        case "V":
          e.push([t[1], t[1]]);
      }

      return e;
    }

    function r(t, e, r) {
      for (var i = [].concat(t), a = void 0, o = 1 / (r + 1), s = n(e)[0], u = 1; u <= r; u++) {
        o *= u, 0 === (a = Math.floor(t.length * o)) ? i.unshift([s[0] * o + t[a][0] * (1 - o), s[1] * o + t[a][1] * (1 - o)]) : i.splice(a, 0, [s[0] * o + t[a][0] * (1 - o), s[1] * o + t[a][1] * (1 - o)]);
      }

      return i;
    }

    t.exports = function (t, e) {
      if (t.length <= 1) return t;

      for (var i = void 0, a = 0; a < e.length; a++) {
        if (t[a][0] !== e[a][0]) switch (i = n(t[a]), e[a][0]) {
          case "M":
            t[a] = ["M"].concat(i[0]);
            break;

          case "L":
            t[a] = ["L"].concat(i[0]);
            break;

          case "A":
            t[a] = [].concat(e[a]), t[a][6] = i[0][0], t[a][7] = i[0][1];
            break;

          case "Q":
            if (i.length < 2) {
              if (!(a > 0)) {
                t[a] = e[a];
                break;
              }

              i = r(i, t[a - 1], 1);
            }

            t[a] = ["Q"].concat(i.reduce(function (t, e) {
              return t.concat(e);
            }, []));
            break;

          case "T":
            t[a] = ["T"].concat(i[0]);
            break;

          case "C":
            if (i.length < 3) {
              if (!(a > 0)) {
                t[a] = e[a];
                break;
              }

              i = r(i, t[a - 1], 2);
            }

            t[a] = ["C"].concat(i.reduce(function (t, e) {
              return t.concat(e);
            }, []));
            break;

          case "S":
            if (i.length < 2) {
              if (!(a > 0)) {
                t[a] = e[a];
                break;
              }

              i = r(i, t[a - 1], 1);
            }

            t[a] = ["S"].concat(i.reduce(function (t, e) {
              return t.concat(e);
            }, []));
            break;

          default:
            t[a] = e[a];
        }
      }

      return t;
    };
  }, function (t, e, n) {
    var r = n(46);

    t.exports = function (t, e) {
      if (t.length !== e.length) return !1;
      var n = !0;
      return r(t, function (t, r) {
        if (t !== e[r]) return n = !1, !1;
      }), n;
    };
  }, function (t, e, n) {
    var r = n(770);

    function i(t, e, n) {
      var r = null,
          i = n;
      return e < i && (i = e, r = "add"), t < i && (i = t, r = "del"), {
        type: r,
        min: i
      };
    }

    t.exports = function (t, e) {
      var n = function (t, e) {
        var n = t.length,
            a = e.length,
            o = void 0,
            s = void 0,
            u = 0;
        if (0 === n || 0 === a) return null;

        for (var c = [], h = 0; h <= n; h++) {
          c[h] = [], c[h][0] = {
            min: h
          };
        }

        for (var f = 0; f <= a; f++) {
          c[0][f] = {
            min: f
          };
        }

        for (var l = 1; l <= n; l++) {
          o = t[l - 1];

          for (var p = 1; p <= a; p++) {
            s = e[p - 1], u = r(o, s) ? 0 : 1;
            var d = c[l - 1][p].min + 1,
                g = c[l][p - 1].min + 1,
                v = c[l - 1][p - 1].min + u;
            c[l][p] = i(d, g, v);
          }
        }

        return c;
      }(t, e),
          a = t.length,
          o = e.length,
          s = [],
          u = 1,
          c = 1;

      if (n[a][o] !== a) {
        for (var h = 1; h <= a; h++) {
          var f = n[h][h].min;
          c = h;

          for (var l = u; l <= o; l++) {
            n[h][l].min < f && (f = n[h][l].min, c = l);
          }

          u = c, n[h][u].type && s.push({
            index: h - 1,
            type: n[h][u].type
          });
        }

        for (var p = s.length - 1; p >= 0; p--) {
          u = s[p].index, "add" === s[p].type ? t.splice(u, 0, [].concat(t[u])) : t.splice(u, 1);
        }
      }

      if ((a = t.length) < o) for (var d = 0; d < o - a; d++) {
        "z" === t[a - 1][0] || "Z" === t[a - 1][0] ? t.splice(a - 2, 0, t[a - 2]) : t.push(t[a - 1]);
      }
      return t;
    };
  }, function (t, e) {
    function n(t, e) {
      var n = [],
          r = [];
      return t.length && function t(e, i) {
        if (1 === e.length) n.push(e[0]), r.push(e[0]);else {
          for (var a = [], o = 0; o < e.length - 1; o++) {
            0 === o && n.push(e[0]), o === e.length - 2 && r.push(e[o + 1]), a[o] = [(1 - i) * e[o][0] + i * e[o + 1][0], (1 - i) * e[o][1] + i * e[o + 1][1]];
          }

          t(a, i);
        }
      }(t, e), {
        left: n,
        right: r.reverse()
      };
    }

    function r(t, e, r) {
      if (1 === r) return [[].concat(t)];
      var i = [];
      if ("L" === e[0] || "C" === e[0] || "Q" === e[0]) i = i.concat(function (t, e, r) {
        var i = [[t[1], t[2]]];
        r = r || 2;
        var a = [];
        "A" === e[0] ? (i.push(e[6]), i.push(e[7])) : "C" === e[0] ? (i.push([e[1], e[2]]), i.push([e[3], e[4]]), i.push([e[5], e[6]])) : "S" === e[0] || "Q" === e[0] ? (i.push([e[1], e[2]]), i.push([e[3], e[4]])) : i.push([e[1], e[2]]);

        for (var o = i, s = 1 / r, u = 0; u < r - 1; u++) {
          var c = n(o, s / (1 - s * u));
          a.push(c.left), o = c.right;
        }

        return a.push(o), a.map(function (t) {
          var e = [];
          return 4 === t.length && (e.push("C"), e = e.concat(t[2])), t.length >= 3 && (3 === t.length && e.push("Q"), e = e.concat(t[1])), 2 === t.length && e.push("L"), e = e.concat(t[t.length - 1]);
        });
      }(t, e, r));else {
        var a = [].concat(t);
        "M" === a[0] && (a[0] = "L");

        for (var o = 0; o <= r - 1; o++) {
          i.push(a);
        }
      }
      return i;
    }

    t.exports = function (t, e) {
      if (1 === t.length) return t;
      var n = t.length - 1,
          i = e.length - 1,
          a = n / i,
          o = [];

      if (1 === t.length && "M" === t[0][0]) {
        for (var s = 0; s < i - n; s++) {
          t.push(t[0]);
        }

        return t;
      }

      for (var u = 0; u < i; u++) {
        var c = Math.floor(a * u);
        o[c] = (o[c] || 0) + 1;
      }

      var h = o.reduce(function (e, i, a) {
        return a === n ? e.concat(t[n]) : e.concat(r(t[a], t[a + 1], i));
      }, []);
      return h.unshift(t[0]), "Z" !== e[i] && "z" !== e[i] || h.push("Z"), h;
    };
  }, function (t, e, n) {
    var r = n(45),
        i = n(663),
        a = n(661),
        o = function o(t, e, n, r, i) {
      return t * (t * (-3 * e + 9 * n - 9 * r + 3 * i) + 6 * e - 12 * n + 6 * r) - 3 * e + 3 * n;
    },
        s = function s(t, e, n, r, i, a, _s, u, c) {
      null === c && (c = 1);

      for (var h = (c = c > 1 ? 1 : c < 0 ? 0 : c) / 2, f = [-.1252, .1252, -.3678, .3678, -.5873, .5873, -.7699, .7699, -.9041, .9041, -.9816, .9816], l = [.2491, .2491, .2335, .2335, .2032, .2032, .1601, .1601, .1069, .1069, .0472, .0472], p = 0, d = 0; d < 12; d++) {
        var g = h * f[d] + h,
            v = o(g, t, n, i, _s),
            m = o(g, e, r, a, u),
            x = v * v + m * m;
        p += l[d] * Math.sqrt(x);
      }

      return h * p;
    },
        u = function u(t, e, n, r, i, a, o, s) {
      if (!(Math.max(t, n) < Math.min(i, o) || Math.min(t, n) > Math.max(i, o) || Math.max(e, r) < Math.min(a, s) || Math.min(e, r) > Math.max(a, s))) {
        var u = (t - n) * (a - s) - (e - r) * (i - o);

        if (u) {
          var c = ((t * r - e * n) * (i - o) - (t - n) * (i * s - a * o)) / u,
              h = ((t * r - e * n) * (a - s) - (e - r) * (i * s - a * o)) / u,
              f = +c.toFixed(2),
              l = +h.toFixed(2);
          if (!(f < +Math.min(t, n).toFixed(2) || f > +Math.max(t, n).toFixed(2) || f < +Math.min(i, o).toFixed(2) || f > +Math.max(i, o).toFixed(2) || l < +Math.min(e, r).toFixed(2) || l > +Math.max(e, r).toFixed(2) || l < +Math.min(a, s).toFixed(2) || l > +Math.max(a, s).toFixed(2))) return {
            x: c,
            y: h
          };
        }
      }
    },
        c = function c(t, e, n) {
      return e >= t.x && e <= t.x + t.width && n >= t.y && n <= t.y + t.height;
    },
        h = function h(t, e, n, r) {
      return null === t && (t = e = n = r = 0), null === e && (e = t.y, n = t.width, r = t.height, t = t.x), {
        x: t,
        y: e,
        width: n,
        w: n,
        height: r,
        h: r,
        x2: t + n,
        y2: e + r,
        cx: t + n / 2,
        cy: e + r / 2,
        r1: Math.min(n, r) / 2,
        r2: Math.max(n, r) / 2,
        r0: Math.sqrt(n * n + r * r) / 2,
        path: i(t, e, n, r),
        vb: [t, e, n, r].join(" ")
      };
    },
        f = function f(t, e, n, i, a, o, s, u) {
      r(t) || (t = [t, e, n, i, a, o, s, u]);

      var c = function (t, e, n, r, i, a, o, s) {
        for (var u = [], c = [[], []], h = void 0, f = void 0, l = void 0, p = void 0, d = 0; d < 2; ++d) {
          if (0 === d ? (f = 6 * t - 12 * n + 6 * i, h = -3 * t + 9 * n - 9 * i + 3 * o, l = 3 * n - 3 * t) : (f = 6 * e - 12 * r + 6 * a, h = -3 * e + 9 * r - 9 * a + 3 * s, l = 3 * r - 3 * e), Math.abs(h) < 1e-12) {
            if (Math.abs(f) < 1e-12) continue;
            (p = -l / f) > 0 && p < 1 && u.push(p);
          } else {
            var g = f * f - 4 * l * h,
                v = Math.sqrt(g);

            if (!(g < 0)) {
              var m = (-f + v) / (2 * h);
              m > 0 && m < 1 && u.push(m);
              var x = (-f - v) / (2 * h);
              x > 0 && x < 1 && u.push(x);
            }
          }
        }

        for (var y = u.length, b = y, M = void 0; y--;) {
          M = 1 - (p = u[y]), c[0][y] = M * M * M * t + 3 * M * M * p * n + 3 * M * p * p * i + p * p * p * o, c[1][y] = M * M * M * e + 3 * M * M * p * r + 3 * M * p * p * a + p * p * p * s;
        }

        return c[0][b] = t, c[1][b] = e, c[0][b + 1] = o, c[1][b + 1] = s, c[0].length = c[1].length = b + 2, {
          min: {
            x: Math.min.apply(0, c[0]),
            y: Math.min.apply(0, c[1])
          },
          max: {
            x: Math.max.apply(0, c[0]),
            y: Math.max.apply(0, c[1])
          }
        };
      }.apply(null, t);

      return h(c.min.x, c.min.y, c.max.x - c.min.x, c.max.y - c.min.y);
    },
        l = function l(t, e, n, r, i, a, o, s, u) {
      var c = 1 - u,
          h = Math.pow(c, 3),
          f = Math.pow(c, 2),
          l = u * u,
          p = l * u,
          d = t + 2 * u * (n - t) + l * (i - 2 * n + t),
          g = e + 2 * u * (r - e) + l * (a - 2 * r + e),
          v = n + 2 * u * (i - n) + l * (o - 2 * i + n),
          m = r + 2 * u * (a - r) + l * (s - 2 * a + r);
      return {
        x: h * t + 3 * f * u * n + 3 * c * u * u * i + p * o,
        y: h * e + 3 * f * u * r + 3 * c * u * u * a + p * s,
        m: {
          x: d,
          y: g
        },
        n: {
          x: v,
          y: m
        },
        start: {
          x: c * t + u * n,
          y: c * e + u * r
        },
        end: {
          x: c * i + u * o,
          y: c * a + u * s
        },
        alpha: 90 - 180 * Math.atan2(d - v, g - m) / Math.PI
      };
    },
        p = function p(t, e, n) {
      if (!function (t, e) {
        return t = h(t), e = h(e), c(e, t.x, t.y) || c(e, t.x2, t.y) || c(e, t.x, t.y2) || c(e, t.x2, t.y2) || c(t, e.x, e.y) || c(t, e.x2, e.y) || c(t, e.x, e.y2) || c(t, e.x2, e.y2) || (t.x < e.x2 && t.x > e.x || e.x < t.x2 && e.x > t.x) && (t.y < e.y2 && t.y > e.y || e.y < t.y2 && e.y > t.y);
      }(f(t), f(e))) return n ? 0 : [];

      for (var r = ~~(s.apply(0, t) / 8), i = ~~(s.apply(0, e) / 8), a = [], o = [], p = {}, d = n ? 0 : [], g = 0; g < r + 1; g++) {
        var v = l.apply(0, t.concat(g / r));
        a.push({
          x: v.x,
          y: v.y,
          t: g / r
        });
      }

      for (var m = 0; m < i + 1; m++) {
        var x = l.apply(0, e.concat(m / i));
        o.push({
          x: x.x,
          y: x.y,
          t: m / i
        });
      }

      for (var y = 0; y < r; y++) {
        for (var b = 0; b < i; b++) {
          var M = a[y],
              w = a[y + 1],
              _ = o[b],
              E = o[b + 1],
              S = Math.abs(w.x - M.x) < .001 ? "y" : "x",
              A = Math.abs(E.x - _.x) < .001 ? "y" : "x",
              P = u(M.x, M.y, w.x, w.y, _.x, _.y, E.x, E.y);

          if (P) {
            if (p[P.x.toFixed(4)] === P.y.toFixed(4)) continue;
            p[P.x.toFixed(4)] = P.y.toFixed(4);

            var O = M.t + Math.abs((P[S] - M[S]) / (w[S] - M[S])) * (w.t - M.t),
                C = _.t + Math.abs((P[A] - _[A]) / (E[A] - _[A])) * (E.t - _.t);

            O >= 0 && O <= 1 && C >= 0 && C <= 1 && (n ? d++ : d.push({
              x: P.x,
              y: P.y,
              t1: O,
              t2: C
            }));
          }
        }
      }

      return d;
    };

    t.exports = function (t, e) {
      return function (t, e, n) {
        t = a(t), e = a(e);

        for (var r = void 0, i = void 0, o = void 0, s = void 0, u = void 0, c = void 0, h = void 0, f = void 0, l = void 0, d = void 0, g = n ? 0 : [], v = 0, m = t.length; v < m; v++) {
          var x = t[v];
          if ("M" === x[0]) r = u = x[1], i = c = x[2];else {
            "C" === x[0] ? (r = (l = [r, i].concat(x.slice(1)))[6], i = l[7]) : (l = [r, i, r, i, u, c, u, c], r = u, i = c);

            for (var y = 0, b = e.length; y < b; y++) {
              var M = e[y];
              if ("M" === M[0]) o = h = M[1], s = f = M[2];else {
                "C" === M[0] ? (o = (d = [o, s].concat(M.slice(1)))[6], s = d[7]) : (d = [o, s, o, s, h, f, h, f], o = h, s = f);
                var w = p(l, d, n);
                if (n) g += w;else {
                  for (var _ = 0, E = w.length; _ < E; _++) {
                    w[_].segment1 = v, w[_].segment2 = y, w[_].bez1 = l, w[_].bez2 = d;
                  }

                  g = g.concat(w);
                }
              }
            }
          }
        }

        return g;
      }(t, e);
    };
  }, function (t, e, n) {
    var r = n(773),
        i = n(660),
        a = n(661),
        o = n(658);
    t.exports = {
      catmullRom2Bezier: o,
      catmullRomToBezier: o,
      fillPath: n(772),
      fillPathByDiff: n(771),
      formatPath: n(769),
      intersection: r,
      pathIntersection: r,
      parsePathArray: n(662),
      parsePathString: n(659),
      pathToAbsolute: i,
      path2absolute: i,
      pathTocurve: a,
      path2curve: a,
      rectPath: n(663)
    };
  }, function (t, e, n) {
    var r = n(605),
        i = n(664);

    t.exports = function (t, e) {
      return r(i(t), e);
    };
  }, function (t, e, n) {
    t.exports = n(665);
  }, function (t, e, n) {
    t.exports = n(46);
  }, function (t, e, n) {
    t.exports = {
      forIn: n(777),
      has: n(665),
      hasKey: n(776),
      hasValue: n(775),
      keys: n(677),
      isMatch: n(678),
      values: n(664)
    };
  }, function (t, e, n) {
    t.exports = {
      mat3: n(617),
      vec2: n(668),
      vec3: n(667),
      transform: n(666)
    };
  }, function (t, e, n) {
    var r = n(45),
        i = n(84),
        a = n(46);

    t.exports = function (t, e) {
      if (r(t)) {
        var n = t[0],
            o = void 0;
        o = i(e) ? e(t[0]) : t[0][e];
        var s = void 0;
        return a(t, function (t) {
          (s = i(e) ? e(t) : t[e]) < o && (n = t, o = s);
        }), n;
      }
    };
  }, function (t, e, n) {
    var r = n(45),
        i = n(84),
        a = n(46);

    t.exports = function (t, e) {
      if (r(t)) {
        var n = t[0],
            o = void 0;
        o = i(e) ? e(t[0]) : t[0][e];
        var s = void 0;
        return a(t, function (t) {
          (s = i(e) ? e(t) : t[e]) > o && (n = t, o = s);
        }), n;
      }
    };
  }, function (t, e, n) {
    var r = n(236);

    t.exports = function (t) {
      return r(t) && t > 0;
    };
  }, function (t, e, n) {
    var r = n(236);

    t.exports = function (t) {
      return r(t) && t % 2 != 0;
    };
  }, function (t, e, n) {
    var r = n(236);

    t.exports = function (t) {
      return r(t) && t < 0;
    };
  }, function (t, e, n) {
    var r = n(236),
        i = Number.isInteger ? Number.isInteger : function (t) {
      return r(t) && t % 1 == 0;
    };
    t.exports = i;
  }, function (t, e, n) {
    var r = n(236);

    t.exports = function (t) {
      return r(t) && t % 2 == 0;
    };
  }, function (t, e, n) {
    var r = n(236);

    t.exports = function (t) {
      return r(t) && t % 1 != 0;
    };
  }, function (t, e) {
    t.exports = function (t, e) {
      var n = e.toString(),
          r = n.indexOf(".");
      if (-1 === r) return Math.round(t);
      var i = n.substr(r + 1).length;
      return i > 20 && (i = 20), parseFloat(t.toFixed(i));
    };
  }, function (t, e, n) {
    var r = n(673);
    t.exports = {
      clamp: n(618),
      fixedBase: n(788),
      isDecimal: n(787),
      isEven: n(786),
      isInteger: n(785),
      isNegative: n(784),
      isNumberEqual: r,
      isOdd: n(783),
      isPositive: n(782),
      maxBy: n(781),
      minBy: n(780),
      mod: n(672),
      snapEqual: r,
      toDegree: n(671),
      toInt: n(670),
      toInteger: n(670),
      toRadian: n(669)
    };
  }, function (t, e, n) {
    var r = n(45);

    t.exports = function (t) {
      var e = 0,
          n = 0,
          i = 0,
          a = 0;
      return r(t) ? 1 === t.length ? e = n = i = a = t[0] : 2 === t.length ? (e = i = t[0], n = a = t[1]) : 3 === t.length ? (e = t[0], n = a = t[1], i = t[2]) : (e = t[0], n = t[1], i = t[2], a = t[3]) : e = n = i = a = t, {
        r1: e,
        r2: n,
        r3: i,
        r4: a
      };
    };
  }, function (t, e, n) {
    var r = n(45),
        i = n(595),
        a = n(46),
        o = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/gi,
        s = /[^\s\,]+/gi;

    t.exports = function (t) {
      return r(t = t || []) ? t : i(t) ? (t = t.match(o), a(t, function (e, n) {
        if ((e = e.match(s))[0].length > 1) {
          var r = e[0].charAt(0);
          e.splice(1, 0, e[0].substr(1)), e[0] = r;
        }

        a(e, function (t, n) {
          isNaN(t) || (e[n] = +t);
        }), t[n] = e;
      }), t) : void 0;
    };
  }, function (t, e) {
    var n = {};

    t.exports = function (t) {
      var e = n[t];

      if (!e) {
        for (var r = t.toString(16), i = r.length; i < 6; i++) {
          r = "0" + r;
        }

        e = "#" + r, n[t] = e;
      }

      return e;
    };
  }, function (t, e, n) {
    var r = n(792);
    t.exports = {
      number2color: r,
      numberToColor: r,
      parsePath: n(791),
      parseRadius: n(790)
    };
  }, function (t, e) {
    t.exports = function (t, e) {
      if (t["_wrap_" + e]) return t["_wrap_" + e];

      var n = function n(_n) {
        t[e](_n);
      };

      return t["_wrap_" + e] = n, n;
    };
  }, function (t, e) {
    t.exports = function (t, e) {
      return t["_wrap_" + e];
    };
  }, function (t, e, n) {
    t.exports = {
      getWrapBehavior: n(795),
      wrapBehavior: n(794)
    };
  }, function (t, e, n) {
    var r = n(237),
        i = n(45),
        a = n(46);

    t.exports = function (t, e) {
      for (var n = [], o = {}, s = 0; s < t.length; s++) {
        var u = t[s][e];
        r(u) || (i(u) || (u = [u]), a(u, function (t) {
          o[t] || (n.push(t), o[t] = !0);
        }));
      }

      return n;
    };
  }, function (t, e, n) {
    var r = n(46),
        i = n(604),
        a = n(674);

    t.exports = function () {
      var t = [],
          e = i(arguments);
      return r(e, function (e) {
        t = t.concat(e);
      }), a(t);
    };
  }, function (t, e, n) {
    var r = n(595),
        i = n(84),
        a = n(45);

    t.exports = function (t, e) {
      var n = void 0;
      if (i(e)) n = function n(t, _n2) {
        return e(t) - e(_n2);
      };else {
        var o = [];
        r(e) ? o.push(e) : a(e) && (o = e), n = function n(t, e) {
          for (var n = 0; n < o.length; n += 1) {
            var r = o[n];
            if (t[r] > e[r]) return 1;
            if (t[r] < e[r]) return -1;
          }

          return 0;
        };
      }
      return t.sort(n), t;
    };
  }, function (t, e, n) {
    var r = n(118),
        i = n(675);

    t.exports = function (t, e) {
      var n = [];
      if (!r(t)) return n;

      for (var a = -1, o = [], s = t.length; ++a < s;) {
        var u = t[a];
        e(u, a, t) && (n.push(u), o.push(a));
      }

      return i(t, o), n;
    };
  }, function (t, e, n) {
    var r = n(45),
        i = n(596),
        a = n(46);

    t.exports = function (t, e, n) {
      if (!r(t) && !i(t)) return t;
      var o = n;
      return a(t, function (t, n) {
        o = e(o, t, n);
      }), o;
    };
  }, function (t, e) {
    t.exports = function (t) {
      for (var e = [], n = 0; n < t.length; n++) {
        e = e.concat(t[n]);
      }

      return e;
    };
  }, function (t, e, n) {
    var r = n(620),
        i = n(45);

    t.exports = function (t) {
      if (!(t = r(t, function (t) {
        return !isNaN(t);
      })).length) return {
        min: 0,
        max: 0
      };

      if (i(t[0])) {
        for (var e = [], n = 0; n < t.length; n++) {
          e = e.concat(t[n]);
        }

        t = e;
      }

      var a = Math.max.apply(null, t);
      return {
        min: Math.min.apply(null, t),
        max: a
      };
    };
  }, function (t, e, n) {
    var r = n(45);

    t.exports = function t(e) {
      var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
      if (r(e)) for (var i = 0; i < e.length; i += 1) {
        t(e[i], n);
      } else n.push(e);
      return n;
    };
  }, function (t, e, n) {
    var r = n(45),
        i = n(46);

    t.exports = function (t) {
      if (!r(t)) return t;
      var e = [];
      return i(t, function (t) {
        r(t) ? i(t, function (t) {
          e.push(t);
        }) : e.push(t);
      }), e;
    };
  }, function (t, e, n) {
    var r = n(237),
        i = n(45);

    t.exports = function (t, e) {
      for (var n = null, a = 0; a < t.length; a++) {
        var o = t[a][e];

        if (!r(o)) {
          n = i(o) ? o[0] : o;
          break;
        }
      }

      return n;
    };
  }, function (t, e, n) {
    var r = n(84),
        i = n(596),
        a = n(678);

    t.exports = function (t, e) {
      var n = void 0;
      if (r(e) && (n = e), i(e) && (n = function n(t) {
        return a(t, e);
      }), n) for (var o = 0; o < t.length; o += 1) {
        if (n(t[o])) return t[o];
      }
      return null;
    };
  }, function (t, e, n) {
    var r = n(620),
        i = n(605);

    t.exports = function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
      return r(t, function (t) {
        return !i(e, t);
      });
    };
  }, function (t, e, n) {
    t.exports = {
      contains: n(605),
      difference: n(808),
      find: n(807),
      firstValue: n(806),
      flatten: n(805),
      flattenDeep: n(804),
      getRange: n(803),
      merge: n(802),
      pull: n(676),
      pullAt: n(675),
      reduce: n(801),
      remove: n(800),
      sortBy: n(799),
      union: n(798),
      uniq: n(674),
      valuesOfKey: n(797)
    };
  }, function (t, e) {
    t.exports = function (t, e) {
      var n = this.getStyle(t, "width", e);
      return "auto" === n && (n = t.offsetWidth), parseFloat(n);
    };
  }, function (t, e, n) {
    var r = n(237);

    t.exports = function (t, e, n) {
      try {
        return window.getComputedStyle ? window.getComputedStyle(t, null)[e] : t.currentStyle[e];
      } catch (t) {
        return r(n) ? null : n;
      }
    };
  }, function (t, e) {
    t.exports = function () {
      return window.devicePixelRatio ? window.devicePixelRatio : 2;
    };
  }, function (t, e) {
    t.exports = function (t, e) {
      var n = this.getWidth(t, e),
          r = parseFloat(this.getStyle(t, "borderLeftWidth")) || 0,
          i = parseFloat(this.getStyle(t, "paddingLeft")) || 0,
          a = parseFloat(this.getStyle(t, "paddingRight")) || 0;
      return n + r + (parseFloat(this.getStyle(t, "borderRightWidth")) || 0) + i + a;
    };
  }, function (t, e) {
    t.exports = function (t, e) {
      var n = this.getHeight(t, e),
          r = parseFloat(this.getStyle(t, "borderTopWidth")) || 0,
          i = parseFloat(this.getStyle(t, "paddingTop")) || 0,
          a = parseFloat(this.getStyle(t, "paddingBottom")) || 0;
      return n + r + (parseFloat(this.getStyle(t, "borderBottomWidth")) || 0) + i + a;
    };
  }, function (t, e) {
    t.exports = function (t, e) {
      var n = this.getStyle(t, "height", e);
      return "auto" === n && (n = t.offsetHeight), parseFloat(n);
    };
  }, function (t, e) {
    t.exports = function (t, e) {
      if (t && t.getBoundingClientRect) {
        var n = t.getBoundingClientRect(),
            r = document.documentElement.clientTop,
            i = document.documentElement.clientLeft;
        return {
          top: n.top - r,
          bottom: n.bottom - r,
          left: n.left - i,
          right: n.right - i
        };
      }

      return e || null;
    };
  }, function (t, e) {
    t.exports = function (t, e, n) {
      if (t) {
        if (t.addEventListener) return t.addEventListener(e, n, !1), {
          remove: function remove() {
            t.removeEventListener(e, n, !1);
          }
        };
        if (t.attachEvent) return t.attachEvent("on" + e, n), {
          remove: function remove() {
            t.detachEvent("on" + e, n);
          }
        };
      }
    };
  }, function (t, e, n) {
    t.exports = {
      addEventListener: n(817),
      createDom: n(681),
      getBoundingClientRect: n(816),
      getHeight: n(815),
      getOuterHeight: n(814),
      getOuterWidth: n(813),
      getRatio: n(812),
      getStyle: n(811),
      getWidth: n(810),
      modifyCSS: n(680),
      requestAnimationFrame: n(679)
    };
  }, function (t, e, n) {
    var r = n(46),
        i = n(606),
        a = n(818),
        o = n(809),
        s = n(796),
        u = n(793),
        c = n(789),
        h = n(779),
        f = n(778),
        l = n(774),
        p = n(768),
        d = n(763),
        g = {
      DOMUtil: a,
      DomUtil: a,
      MatrixUtil: h,
      PathUtil: l,
      arrayUtil: o,
      domUtil: a,
      eventUtil: s,
      formatUtil: u,
      mathUtil: c,
      matrixUtil: h,
      objectUtil: f,
      stringUtil: p,
      pathUtil: l,
      typeUtil: d,
      augment: n(651),
      clone: n(616),
      debounce: n(756),
      deepMix: n(615),
      each: r,
      extend: n(650),
      filter: n(620),
      group: n(755),
      groupBy: n(648),
      groupToMap: n(649),
      indexOf: n(754),
      isEmpty: n(647),
      isEqual: n(614),
      isEqualWith: n(753),
      map: n(752),
      mix: i,
      pick: n(751),
      throttle: n(750),
      toArray: n(604),
      toString: n(594),
      uniqueId: n(646)
    };
    r([a, o, s, u, c, h, f, l, p, d], function (t) {
      i(g, t);
    }), t.exports = g;
  }, function (t, e, n) {
    var r = n(683),
        i = n(626),
        a = n(247),
        o = n(609),
        s = n(248),
        u = {
      Graph: n(625),
      Tree: n(689),
      Util: n(26),
      Layouts: n(623),
      G: s,
      Plugins: {},
      Components: {},
      Global: a,
      Shape: r,
      registerNode: r.registerNode,
      registerEdge: r.registerEdge,
      registerGroup: r.registerGroup,
      registerGuide: r.registerGuide,
      registerBehaviour: i.registerBehaviour,
      version: o,
      track: function track(t) {
        a.track = t;
      }
    };
    n(684), t.exports = u;
  }]);
});
},{}],"../node_modules/@antv/g6/build/plugin.layout.dagre.js":[function(require,module,exports) {
var define;
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

!function (n, t) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = t(require("@antv/g6")) : "function" == typeof define && define.amd ? define(["@antv/g6"], t) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports["plugin.layout.dagre"] = t(require("@antv/g6")) : n["plugin.layout.dagre"] = t(n.G6);
}(window, function (n) {
  return function (n) {
    var t = {};

    function e(r) {
      if (t[r]) return t[r].exports;
      var o = t[r] = {
        i: r,
        l: !1,
        exports: {}
      };
      return n[r].call(o.exports, o, o.exports, e), o.l = !0, o.exports;
    }

    return e.m = n, e.c = t, e.d = function (n, t, r) {
      e.o(n, t) || Object.defineProperty(n, t, {
        enumerable: !0,
        get: r
      });
    }, e.r = function (n) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(n, "__esModule", {
        value: !0
      });
    }, e.t = function (n, t) {
      if (1 & t && (n = e(n)), 8 & t) return n;
      if (4 & t && "object" == _typeof(n) && n && n.__esModule) return n;
      var r = Object.create(null);
      if (e.r(r), Object.defineProperty(r, "default", {
        enumerable: !0,
        value: n
      }), 2 & t && "string" != typeof n) for (var o in n) {
        e.d(r, o, function (t) {
          return n[t];
        }.bind(null, o));
      }
      return r;
    }, e.n = function (n) {
      var t = n && n.__esModule ? function () {
        return n.default;
      } : function () {
        return n;
      };
      return e.d(t, "a", t), t;
    }, e.o = function (n, t) {
      return Object.prototype.hasOwnProperty.call(n, t);
    }, e.p = "", e(e.s = 587);
  }([,,, function (t, e) {
    t.exports = n;
  },,,, function (n, t, e) {
    var r;

    try {
      r = {
        cloneDeep: e(472),
        constant: e(103),
        defaults: e(471),
        each: e(218),
        filter: e(215),
        find: e(470),
        flatten: e(188),
        forEach: e(217),
        forIn: e(466),
        has: e(204),
        isUndefined: e(203),
        last: e(465),
        map: e(202),
        mapValues: e(464),
        max: e(463),
        merge: e(461),
        min: e(455),
        minBy: e(454),
        now: e(253),
        pick: e(453),
        range: e(448),
        reduce: e(200),
        sortBy: e(445),
        uniqueId: e(440),
        values: e(195),
        zipObject: e(439)
      };
    } catch (n) {}

    r || (r = window._), n.exports = r;
  },,,, function (n, t) {
    var e = Array.isArray;
    n.exports = e;
  },,,, function (n, t, e) {
    "use strict";

    var r = e(7),
        o = e(22).Graph;

    function i(n, t, e, o) {
      var i;

      do {
        i = r.uniqueId(o);
      } while (n.hasNode(i));

      return e.dummy = t, n.setNode(i, e), i;
    }

    function u(n) {
      return r.max(r.map(n.nodes(), function (t) {
        var e = n.node(t).rank;
        if (!r.isUndefined(e)) return e;
      }));
    }

    n.exports = {
      addDummyNode: i,
      simplify: function simplify(n) {
        var t = new o().setGraph(n.graph());
        return r.forEach(n.nodes(), function (e) {
          t.setNode(e, n.node(e));
        }), r.forEach(n.edges(), function (e) {
          var r = t.edge(e.v, e.w) || {
            weight: 0,
            minlen: 1
          },
              o = n.edge(e);
          t.setEdge(e.v, e.w, {
            weight: r.weight + o.weight,
            minlen: Math.max(r.minlen, o.minlen)
          });
        }), t;
      },
      asNonCompoundGraph: function asNonCompoundGraph(n) {
        var t = new o({
          multigraph: n.isMultigraph()
        }).setGraph(n.graph());
        return r.forEach(n.nodes(), function (e) {
          n.children(e).length || t.setNode(e, n.node(e));
        }), r.forEach(n.edges(), function (e) {
          t.setEdge(e, n.edge(e));
        }), t;
      },
      successorWeights: function successorWeights(n) {
        var t = r.map(n.nodes(), function (t) {
          var e = {};
          return r.forEach(n.outEdges(t), function (t) {
            e[t.w] = (e[t.w] || 0) + n.edge(t).weight;
          }), e;
        });
        return r.zipObject(n.nodes(), t);
      },
      predecessorWeights: function predecessorWeights(n) {
        var t = r.map(n.nodes(), function (t) {
          var e = {};
          return r.forEach(n.inEdges(t), function (t) {
            e[t.v] = (e[t.v] || 0) + n.edge(t).weight;
          }), e;
        });
        return r.zipObject(n.nodes(), t);
      },
      intersectRect: function intersectRect(n, t) {
        var e,
            r,
            o = n.x,
            i = n.y,
            u = t.x - o,
            a = t.y - i,
            c = n.width / 2,
            f = n.height / 2;
        if (!u && !a) throw new Error("Not possible to find intersection inside of the rectangle");
        Math.abs(a) * c > Math.abs(u) * f ? (a < 0 && (f = -f), e = f * u / a, r = f) : (u < 0 && (c = -c), e = c, r = c * a / u);
        return {
          x: o + e,
          y: i + r
        };
      },
      buildLayerMatrix: function buildLayerMatrix(n) {
        var t = r.map(r.range(u(n) + 1), function () {
          return [];
        });
        return r.forEach(n.nodes(), function (e) {
          var o = n.node(e),
              i = o.rank;
          r.isUndefined(i) || (t[i][o.order] = e);
        }), t;
      },
      normalizeRanks: function normalizeRanks(n) {
        var t = r.min(r.map(n.nodes(), function (t) {
          return n.node(t).rank;
        }));
        r.forEach(n.nodes(), function (e) {
          var o = n.node(e);
          r.has(o, "rank") && (o.rank -= t);
        });
      },
      removeEmptyRanks: function removeEmptyRanks(n) {
        var t = r.min(r.map(n.nodes(), function (t) {
          return n.node(t).rank;
        })),
            e = [];
        r.forEach(n.nodes(), function (r) {
          var o = n.node(r).rank - t;
          e[o] || (e[o] = []), e[o].push(r);
        });
        var o = 0,
            i = n.graph().nodeRankFactor;
        r.forEach(e, function (t, e) {
          r.isUndefined(t) && e % i != 0 ? --o : o && r.forEach(t, function (t) {
            n.node(t).rank += o;
          });
        });
      },
      addBorderNode: function addBorderNode(n, t, e, r) {
        var o = {
          width: 0,
          height: 0
        };
        arguments.length >= 4 && (o.rank = e, o.order = r);
        return i(n, "border", o, t);
      },
      maxRank: u,
      partition: function partition(n, t) {
        var e = {
          lhs: [],
          rhs: []
        };
        return r.forEach(n, function (n) {
          t(n) ? e.lhs.push(n) : e.rhs.push(n);
        }), e;
      },
      time: function time(n, t) {
        var e = r.now();

        try {
          return t();
        } finally {
          console.log(n + " time: " + (r.now() - e) + "ms");
        }
      },
      notime: function notime(n, t) {
        return t();
      }
    };
  }, function (n, t) {
    n.exports = function (n) {
      var t = _typeof(n);

      return null != n && ("object" == t || "function" == t);
    };
  },, function (n, t, e) {
    var r;

    try {
      r = {
        clone: e(582),
        constant: e(103),
        each: e(218),
        filter: e(215),
        has: e(204),
        isArray: e(11),
        isEmpty: e(508),
        isFunction: e(57),
        isUndefined: e(203),
        keys: e(33),
        map: e(202),
        reduce: e(200),
        size: e(505),
        transform: e(499),
        union: e(498),
        values: e(195)
      };
    } catch (n) {}

    r || (r = window._), n.exports = r;
  },, function (n, t, e) {
    var r = e(117),
        o = "object" == (typeof self === "undefined" ? "undefined" : _typeof(self)) && self && self.Object === Object && self,
        i = r || o || Function("return this")();
    n.exports = i;
  },, function (n, t, e) {
    var r;

    try {
      r = e(584);
    } catch (n) {}

    r || (r = window.graphlib), n.exports = r;
  }, function (n, t) {
    n.exports = function (n) {
      return null != n && "object" == _typeof(n);
    };
  },,,,, function (n, t, e) {
    var r = e(528),
        o = e(518),
        i = e(36),
        u = e(11),
        a = e(511);

    n.exports = function (n) {
      return "function" == typeof n ? n : null == n ? i : "object" == _typeof(n) ? u(n) ? o(n[0], n[1]) : r(n) : a(n);
    };
  }, function (n, t, e) {
    var r = e(57),
        o = e(109);

    n.exports = function (n) {
      return null != n && o(n.length) && !r(n);
    };
  },,,, function (n, t, e) {
    var r = e(232),
        o = e(107),
        i = e(29);

    n.exports = function (n) {
      return i(n) ? r(n) : o(n);
    };
  }, function (n, t, e) {
    var r = e(38),
        o = e(250),
        i = e(249),
        u = "[object Null]",
        a = "[object Undefined]",
        c = r ? r.toStringTag : void 0;

    n.exports = function (n) {
      return null == n ? void 0 === n ? a : u : c && c in Object(n) ? o(n) : i(n);
    };
  },, function (n, t) {
    n.exports = function (n) {
      return n;
    };
  }, function (n, t, e) {
    var r = e(571),
        o = e(568);

    n.exports = function (n, t) {
      var e = o(n, t);
      return r(e) ? e : void 0;
    };
  }, function (n, t, e) {
    var r = e(20).Symbol;
    n.exports = r;
  }, function (n, t, e) {
    var r = e(34),
        o = e(23),
        i = "[object Symbol]";

    n.exports = function (n) {
      return "symbol" == _typeof(n) || o(n) && r(n) == i;
    };
  }, function (n, t, e) {
    var r = e(543),
        o = e(113),
        i = e(542),
        u = e(223),
        a = e(541),
        c = e(34),
        f = e(234),
        s = f(r),
        d = f(o),
        p = f(i),
        h = f(u),
        v = f(a),
        l = c;
    (r && "[object DataView]" != l(new r(new ArrayBuffer(1))) || o && "[object Map]" != l(new o()) || i && "[object Promise]" != l(i.resolve()) || u && "[object Set]" != l(new u()) || a && "[object WeakMap]" != l(new a())) && (l = function l(n) {
      var t = c(n),
          e = "[object Object]" == t ? n.constructor : void 0,
          r = e ? f(e) : "";
      if (r) switch (r) {
        case s:
          return "[object DataView]";

        case d:
          return "[object Map]";

        case p:
          return "[object Promise]";

        case h:
          return "[object Set]";

        case v:
          return "[object WeakMap]";
      }
      return t;
    }), n.exports = l;
  }, function (n, t, e) {
    var r = e(232),
        o = e(548),
        i = e(29);

    n.exports = function (n) {
      return i(n) ? r(n, !0) : o(n);
    };
  }, function (n, t, e) {
    (function (n) {
      var r = e(20),
          o = e(552),
          i = "object" == _typeof(t) && t && !t.nodeType && t,
          u = i && "object" == _typeof(n) && n && !n.nodeType && n,
          a = u && u.exports === i ? r.Buffer : void 0,
          c = (a ? a.isBuffer : void 0) || o;
      n.exports = c;
    }).call(this, e(110)(n));
  }, function (n, t) {
    n.exports = function (n, t) {
      return n === t || n != n && t != t;
    };
  },,,,,,,,,, function (n, t, e) {
    var r = e(39),
        o = 1 / 0;

    n.exports = function (n) {
      if ("string" == typeof n || r(n)) return n;
      var t = n + "";
      return "0" == t && 1 / n == -o ? "-0" : t;
    };
  }, function (n, t, e) {
    var r = e(551),
        o = e(75),
        i = e(108),
        u = i && i.isTypedArray,
        a = u ? o(u) : r;
    n.exports = a;
  }, function (n, t, e) {
    var r = e(553),
        o = e(23),
        i = Object.prototype,
        u = i.hasOwnProperty,
        a = i.propertyIsEnumerable,
        c = r(function () {
      return arguments;
    }()) ? r : function (n) {
      return o(n) && u.call(n, "callee") && !a.call(n, "callee");
    };
    n.exports = c;
  }, function (n, t, e) {
    var r = e(78),
        o = e(77);

    n.exports = function (n, t, e, i) {
      var u = !e;
      e || (e = {});

      for (var a = -1, c = t.length; ++a < c;) {
        var f = t[a],
            s = i ? i(e[f], n[f], f, e, n) : void 0;
        void 0 === s && (s = n[f]), u ? o(e, f, s) : r(e, f, s);
      }

      return e;
    };
  }, function (n, t, e) {
    var r = e(34),
        o = e(16),
        i = "[object AsyncFunction]",
        u = "[object Function]",
        a = "[object GeneratorFunction]",
        c = "[object Proxy]";

    n.exports = function (n) {
      if (!o(n)) return !1;
      var t = r(n);
      return t == u || t == a || t == i || t == c;
    };
  },,,,,,,,,, function (n, t, e) {
    "use strict";

    var r = e(7);
    n.exports = {
      longestPath: function longestPath(n) {
        var t = {};
        r.forEach(n.sources(), function e(o) {
          var i = n.node(o);
          if (r.has(t, o)) return i.rank;
          t[o] = !0;
          var u = r.min(r.map(n.outEdges(o), function (t) {
            return e(t.w) - n.edge(t).minlen;
          }));
          u !== Number.POSITIVE_INFINITY && void 0 !== u && null !== u || (u = 0);
          return i.rank = u;
        });
      },
      slack: function slack(n, t) {
        return n.node(t.w).rank - n.node(t.v).rank - n.edge(t).minlen;
      }
    };
  }, function (n, t, e) {
    var r = e(43),
        o = e(29),
        i = e(76),
        u = e(16);

    n.exports = function (n, t, e) {
      if (!u(e)) return !1;

      var a = _typeof(t);

      return !!("number" == a ? o(e) && i(t, e.length) : "string" == a && t in e) && r(e[t], n);
    };
  }, function (n, t, e) {
    var r = e(36),
        o = e(199),
        i = e(198);

    n.exports = function (n, t) {
      return i(o(n, t, r), n + "");
    };
  }, function (n, t) {
    n.exports = function (n, t) {
      for (var e = -1, r = null == n ? 0 : n.length, o = Array(r); ++e < r;) {
        o[e] = t(n[e], e, n);
      }

      return o;
    };
  }, function (n, t, e) {
    var r = e(11),
        o = e(98),
        i = e(516),
        u = e(208);

    n.exports = function (n, t) {
      return r(n) ? n : o(n, t) ? [n] : i(u(n));
    };
  }, function (n, t, e) {
    var r = e(102),
        o = e(530)(r);
    n.exports = o;
  }, function (n, t, e) {
    var r = e(231)(Object.getPrototypeOf, Object);
    n.exports = r;
  }, function (n, t) {
    var e = Object.prototype;

    n.exports = function (n) {
      var t = n && n.constructor;
      return n === ("function" == typeof t && t.prototype || e);
    };
  }, function (n, t) {
    n.exports = function (n) {
      return function (t) {
        return n(t);
      };
    };
  }, function (n, t) {
    var e = 9007199254740991,
        r = /^(?:0|[1-9]\d*)$/;

    n.exports = function (n, t) {
      var o = _typeof(n);

      return !!(t = null == t ? e : t) && ("number" == o || "symbol" != o && r.test(n)) && n > -1 && n % 1 == 0 && n < t;
    };
  }, function (n, t, e) {
    var r = e(233);

    n.exports = function (n, t, e) {
      "__proto__" == t && r ? r(n, t, {
        configurable: !0,
        enumerable: !0,
        value: e,
        writable: !0
      }) : n[t] = e;
    };
  }, function (n, t, e) {
    var r = e(77),
        o = e(43),
        i = Object.prototype.hasOwnProperty;

    n.exports = function (n, t, e) {
      var u = n[t];
      i.call(n, t) && o(u, e) && (void 0 !== e || t in n) || r(n, t, e);
    };
  }, function (n, t, e) {
    var r = e(559);

    n.exports = function (n, t) {
      var e = n.__data__;
      return r(t) ? e["string" == typeof t ? "string" : "hash"] : e.map;
    };
  }, function (n, t, e) {
    var r = e(37)(Object, "create");
    n.exports = r;
  }, function (n, t, e) {
    var r = e(43);

    n.exports = function (n, t) {
      for (var e = n.length; e--;) {
        if (r(n[e][0], t)) return e;
      }

      return -1;
    };
  }, function (n, t, e) {
    var r = e(581),
        o = e(580),
        i = e(579),
        u = e(578),
        a = e(577);

    function c(n) {
      var t = -1,
          e = null == n ? 0 : n.length;

      for (this.clear(); ++t < e;) {
        var r = n[t];
        this.set(r[0], r[1]);
      }
    }

    c.prototype.clear = r, c.prototype.delete = o, c.prototype.get = i, c.prototype.has = u, c.prototype.set = a, n.exports = c;
  }, function (n, t, e) {
    var r = e(82),
        o = e(576),
        i = e(575),
        u = e(574),
        a = e(573),
        c = e(572);

    function f(n) {
      var t = this.__data__ = new r(n);
      this.size = t.size;
    }

    f.prototype.clear = o, f.prototype.delete = i, f.prototype.get = u, f.prototype.has = a, f.prototype.set = c, n.exports = f;
  },,,,,,,,,,,,, function (n, t, e) {
    var r = e(39);

    n.exports = function (n, t, e) {
      for (var o = -1, i = n.length; ++o < i;) {
        var u = n[o],
            a = t(u);
        if (null != a && (void 0 === c ? a == a && !r(a) : e(a, c))) var c = a,
            f = u;
      }

      return f;
    };
  }, function (n, t, e) {
    var r = e(105),
        o = e(497);

    n.exports = function n(t, e, i, u, a) {
      var c = -1,
          f = t.length;

      for (i || (i = o), a || (a = []); ++c < f;) {
        var s = t[c];
        e > 0 && i(s) ? e > 1 ? n(s, e - 1, i, u, a) : r(a, s) : u || (a[a.length] = s);
      }

      return a;
    };
  }, function (n, t, e) {
    var r = e(11),
        o = e(39),
        i = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        u = /^\w*$/;

    n.exports = function (n, t) {
      if (r(n)) return !1;

      var e = _typeof(n);

      return !("number" != e && "symbol" != e && "boolean" != e && null != n && !o(n)) || u.test(n) || !i.test(n) || null != t && n in Object(t);
    };
  }, function (n, t, e) {
    var r = e(71),
        o = e(53);

    n.exports = function (n, t) {
      for (var e = 0, i = (t = r(t, n)).length; null != n && e < i;) {
        n = n[o(t[e++])];
      }

      return e && e == i ? n : void 0;
    };
  }, function (n, t) {
    n.exports = function (n) {
      var t = -1,
          e = Array(n.size);
      return n.forEach(function (n) {
        e[++t] = n;
      }), e;
    };
  }, function (n, t, e) {
    var r = e(531)();
    n.exports = r;
  }, function (n, t, e) {
    var r = e(101),
        o = e(33);

    n.exports = function (n, t) {
      return n && r(n, t, o);
    };
  }, function (n, t) {
    n.exports = function (n) {
      return function () {
        return n;
      };
    };
  }, function (n, t, e) {
    var r = e(222);

    n.exports = function (n) {
      var t = new n.constructor(n.byteLength);
      return new r(t).set(new r(n)), t;
    };
  }, function (n, t) {
    n.exports = function (n, t) {
      for (var e = -1, r = t.length, o = n.length; ++e < r;) {
        n[o + e] = t[e];
      }

      return n;
    };
  }, function (n, t, e) {
    var r = e(228),
        o = e(227),
        i = Object.prototype.propertyIsEnumerable,
        u = Object.getOwnPropertySymbols,
        a = u ? function (n) {
      return null == n ? [] : (n = Object(n), r(u(n), function (t) {
        return i.call(n, t);
      }));
    } : o;
    n.exports = a;
  }, function (n, t, e) {
    var r = e(74),
        o = e(550),
        i = Object.prototype.hasOwnProperty;

    n.exports = function (n) {
      if (!r(n)) return o(n);
      var t = [];

      for (var e in Object(n)) {
        i.call(n, e) && "constructor" != e && t.push(e);
      }

      return t;
    };
  }, function (n, t, e) {
    (function (n) {
      var r = e(117),
          o = "object" == _typeof(t) && t && !t.nodeType && t,
          i = o && "object" == _typeof(n) && n && !n.nodeType && n,
          u = i && i.exports === o && r.process,
          a = function () {
        try {
          var n = i && i.require && i.require("util").types;

          return n || u && u.binding && u.binding("util");
        } catch (n) {}
      }();

      n.exports = a;
    }).call(this, e(110)(n));
  }, function (n, t) {
    var e = 9007199254740991;

    n.exports = function (n) {
      return "number" == typeof n && n > -1 && n % 1 == 0 && n <= e;
    };
  }, function (n, t) {
    n.exports = function (n) {
      return n.webpackPolyfill || (n.deprecate = function () {}, n.paths = [], n.children || (n.children = []), Object.defineProperty(n, "loaded", {
        enumerable: !0,
        get: function get() {
          return n.l;
        }
      }), Object.defineProperty(n, "id", {
        enumerable: !0,
        get: function get() {
          return n.i;
        }
      }), n.webpackPolyfill = 1), n;
    };
  }, function (n, t) {
    n.exports = function (n, t) {
      for (var e = -1, r = null == n ? 0 : n.length; ++e < r && !1 !== t(n[e], e, n);) {
        ;
      }

      return n;
    };
  }, function (n, t, e) {
    var r = e(567),
        o = e(560),
        i = e(558),
        u = e(557),
        a = e(556);

    function c(n) {
      var t = -1,
          e = null == n ? 0 : n.length;

      for (this.clear(); ++t < e;) {
        var r = n[t];
        this.set(r[0], r[1]);
      }
    }

    c.prototype.clear = r, c.prototype.delete = o, c.prototype.get = i, c.prototype.has = u, c.prototype.set = a, n.exports = c;
  }, function (n, t, e) {
    var r = e(37)(e(20), "Map");
    n.exports = r;
  }, function (n, t, e) {
    "use strict";

    var r = e(18);
    n.exports = a;
    var o = "\0",
        i = "\0",
        u = "";

    function a(n) {
      this._isDirected = !r.has(n, "directed") || n.directed, this._isMultigraph = !!r.has(n, "multigraph") && n.multigraph, this._isCompound = !!r.has(n, "compound") && n.compound, this._label = void 0, this._defaultNodeLabelFn = r.constant(void 0), this._defaultEdgeLabelFn = r.constant(void 0), this._nodes = {}, this._isCompound && (this._parent = {}, this._children = {}, this._children[i] = {}), this._in = {}, this._preds = {}, this._out = {}, this._sucs = {}, this._edgeObjs = {}, this._edgeLabels = {};
    }

    function c(n, t) {
      n[t] ? n[t]++ : n[t] = 1;
    }

    function f(n, t) {
      --n[t] || delete n[t];
    }

    function s(n, t, e, i) {
      var a = "" + t,
          c = "" + e;

      if (!n && a > c) {
        var f = a;
        a = c, c = f;
      }

      return a + u + c + u + (r.isUndefined(i) ? o : i);
    }

    function d(n, t) {
      return s(n, t.v, t.w, t.name);
    }

    a.prototype._nodeCount = 0, a.prototype._edgeCount = 0, a.prototype.isDirected = function () {
      return this._isDirected;
    }, a.prototype.isMultigraph = function () {
      return this._isMultigraph;
    }, a.prototype.isCompound = function () {
      return this._isCompound;
    }, a.prototype.setGraph = function (n) {
      return this._label = n, this;
    }, a.prototype.graph = function () {
      return this._label;
    }, a.prototype.setDefaultNodeLabel = function (n) {
      return r.isFunction(n) || (n = r.constant(n)), this._defaultNodeLabelFn = n, this;
    }, a.prototype.nodeCount = function () {
      return this._nodeCount;
    }, a.prototype.nodes = function () {
      return r.keys(this._nodes);
    }, a.prototype.sources = function () {
      var n = this;
      return r.filter(this.nodes(), function (t) {
        return r.isEmpty(n._in[t]);
      });
    }, a.prototype.sinks = function () {
      var n = this;
      return r.filter(this.nodes(), function (t) {
        return r.isEmpty(n._out[t]);
      });
    }, a.prototype.setNodes = function (n, t) {
      var e = arguments,
          o = this;
      return r.each(n, function (n) {
        e.length > 1 ? o.setNode(n, t) : o.setNode(n);
      }), this;
    }, a.prototype.setNode = function (n, t) {
      return r.has(this._nodes, n) ? (arguments.length > 1 && (this._nodes[n] = t), this) : (this._nodes[n] = arguments.length > 1 ? t : this._defaultNodeLabelFn(n), this._isCompound && (this._parent[n] = i, this._children[n] = {}, this._children[i][n] = !0), this._in[n] = {}, this._preds[n] = {}, this._out[n] = {}, this._sucs[n] = {}, ++this._nodeCount, this);
    }, a.prototype.node = function (n) {
      return this._nodes[n];
    }, a.prototype.hasNode = function (n) {
      return r.has(this._nodes, n);
    }, a.prototype.removeNode = function (n) {
      var t = this;

      if (r.has(this._nodes, n)) {
        var e = function e(n) {
          t.removeEdge(t._edgeObjs[n]);
        };

        delete this._nodes[n], this._isCompound && (this._removeFromParentsChildList(n), delete this._parent[n], r.each(this.children(n), function (n) {
          t.setParent(n);
        }), delete this._children[n]), r.each(r.keys(this._in[n]), e), delete this._in[n], delete this._preds[n], r.each(r.keys(this._out[n]), e), delete this._out[n], delete this._sucs[n], --this._nodeCount;
      }

      return this;
    }, a.prototype.setParent = function (n, t) {
      if (!this._isCompound) throw new Error("Cannot set parent in a non-compound graph");
      if (r.isUndefined(t)) t = i;else {
        for (var e = t += ""; !r.isUndefined(e); e = this.parent(e)) {
          if (e === n) throw new Error("Setting " + t + " as parent of " + n + " would create a cycle");
        }

        this.setNode(t);
      }
      return this.setNode(n), this._removeFromParentsChildList(n), this._parent[n] = t, this._children[t][n] = !0, this;
    }, a.prototype._removeFromParentsChildList = function (n) {
      delete this._children[this._parent[n]][n];
    }, a.prototype.parent = function (n) {
      if (this._isCompound) {
        var t = this._parent[n];
        if (t !== i) return t;
      }
    }, a.prototype.children = function (n) {
      if (r.isUndefined(n) && (n = i), this._isCompound) {
        var t = this._children[n];
        if (t) return r.keys(t);
      } else {
        if (n === i) return this.nodes();
        if (this.hasNode(n)) return [];
      }
    }, a.prototype.predecessors = function (n) {
      var t = this._preds[n];
      if (t) return r.keys(t);
    }, a.prototype.successors = function (n) {
      var t = this._sucs[n];
      if (t) return r.keys(t);
    }, a.prototype.neighbors = function (n) {
      var t = this.predecessors(n);
      if (t) return r.union(t, this.successors(n));
    }, a.prototype.isLeaf = function (n) {
      return 0 === (this.isDirected() ? this.successors(n) : this.neighbors(n)).length;
    }, a.prototype.filterNodes = function (n) {
      var t = new this.constructor({
        directed: this._isDirected,
        multigraph: this._isMultigraph,
        compound: this._isCompound
      });
      t.setGraph(this.graph());
      var e = this;
      r.each(this._nodes, function (e, r) {
        n(r) && t.setNode(r, e);
      }), r.each(this._edgeObjs, function (n) {
        t.hasNode(n.v) && t.hasNode(n.w) && t.setEdge(n, e.edge(n));
      });
      var o = {};
      return this._isCompound && r.each(t.nodes(), function (n) {
        t.setParent(n, function n(r) {
          var i = e.parent(r);
          return void 0 === i || t.hasNode(i) ? (o[r] = i, i) : i in o ? o[i] : n(i);
        }(n));
      }), t;
    }, a.prototype.setDefaultEdgeLabel = function (n) {
      return r.isFunction(n) || (n = r.constant(n)), this._defaultEdgeLabelFn = n, this;
    }, a.prototype.edgeCount = function () {
      return this._edgeCount;
    }, a.prototype.edges = function () {
      return r.values(this._edgeObjs);
    }, a.prototype.setPath = function (n, t) {
      var e = this,
          o = arguments;
      return r.reduce(n, function (n, r) {
        return o.length > 1 ? e.setEdge(n, r, t) : e.setEdge(n, r), r;
      }), this;
    }, a.prototype.setEdge = function () {
      var n,
          t,
          e,
          o,
          i = !1,
          u = arguments[0];
      "object" == _typeof(u) && null !== u && "v" in u ? (n = u.v, t = u.w, e = u.name, 2 === arguments.length && (o = arguments[1], i = !0)) : (n = u, t = arguments[1], e = arguments[3], arguments.length > 2 && (o = arguments[2], i = !0)), n = "" + n, t = "" + t, r.isUndefined(e) || (e = "" + e);
      var a = s(this._isDirected, n, t, e);
      if (r.has(this._edgeLabels, a)) return i && (this._edgeLabels[a] = o), this;
      if (!r.isUndefined(e) && !this._isMultigraph) throw new Error("Cannot set a named edge when isMultigraph = false");
      this.setNode(n), this.setNode(t), this._edgeLabels[a] = i ? o : this._defaultEdgeLabelFn(n, t, e);

      var f = function (n, t, e, r) {
        var o = "" + t,
            i = "" + e;

        if (!n && o > i) {
          var u = o;
          o = i, i = u;
        }

        var a = {
          v: o,
          w: i
        };
        r && (a.name = r);
        return a;
      }(this._isDirected, n, t, e);

      return n = f.v, t = f.w, Object.freeze(f), this._edgeObjs[a] = f, c(this._preds[t], n), c(this._sucs[n], t), this._in[t][a] = f, this._out[n][a] = f, this._edgeCount++, this;
    }, a.prototype.edge = function (n, t, e) {
      var r = 1 === arguments.length ? d(this._isDirected, arguments[0]) : s(this._isDirected, n, t, e);
      return this._edgeLabels[r];
    }, a.prototype.hasEdge = function (n, t, e) {
      var o = 1 === arguments.length ? d(this._isDirected, arguments[0]) : s(this._isDirected, n, t, e);
      return r.has(this._edgeLabels, o);
    }, a.prototype.removeEdge = function (n, t, e) {
      var r = 1 === arguments.length ? d(this._isDirected, arguments[0]) : s(this._isDirected, n, t, e),
          o = this._edgeObjs[r];
      return o && (n = o.v, t = o.w, delete this._edgeLabels[r], delete this._edgeObjs[r], f(this._preds[t], n), f(this._sucs[n], t), delete this._in[t][r], delete this._out[n][r], this._edgeCount--), this;
    }, a.prototype.inEdges = function (n, t) {
      var e = this._in[n];

      if (e) {
        var o = r.values(e);
        return t ? r.filter(o, function (n) {
          return n.v === t;
        }) : o;
      }
    }, a.prototype.outEdges = function (n, t) {
      var e = this._out[n];

      if (e) {
        var o = r.values(e);
        return t ? r.filter(o, function (n) {
          return n.w === t;
        }) : o;
      }
    }, a.prototype.nodeEdges = function (n, t) {
      var e = this.inEdges(n, t);
      if (e) return e.concat(this.outEdges(n, t));
    };
  },,, function (n, t, e) {
    (function (t) {
      var e = "object" == _typeof(t) && t && t.Object === Object && t;
      n.exports = e;
    }).call(this, e(252));
  },,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, function (n, t, e) {
    "use strict";

    var r = e(7),
        o = e(22).Graph,
        i = e(67).slack;

    function u(n, t) {
      return r.forEach(n.nodes(), function e(o) {
        r.forEach(t.nodeEdges(o), function (r) {
          var u = r.v,
              a = o === u ? r.w : u;
          n.hasNode(a) || i(t, r) || (n.setNode(a, {}), n.setEdge(o, a, {}), e(a));
        });
      }), n.nodeCount();
    }

    function a(n, t) {
      return r.minBy(t.edges(), function (e) {
        if (n.hasNode(e.v) !== n.hasNode(e.w)) return i(t, e);
      });
    }

    function c(n, t, e) {
      r.forEach(n.nodes(), function (n) {
        t.node(n).rank += e;
      });
    }

    n.exports = function (n) {
      var t,
          e,
          r = new o({
        directed: !1
      }),
          f = n.nodes()[0],
          s = n.nodeCount();
      r.setNode(f, {});

      for (; u(r, n) < s;) {
        t = a(r, n), e = r.hasNode(t.v) ? i(n, t) : -i(n, t), c(r, n, e);
      }

      return r;
    };
  }, function (n, t) {
    n.exports = function (n, t) {
      return n < t;
    };
  }, function (n, t) {
    n.exports = function (n, t) {
      if ("__proto__" != t) return n[t];
    };
  }, function (n, t, e) {
    var r = e(77),
        o = e(43);

    n.exports = function (n, t, e) {
      (void 0 === e || o(n[t], e)) && (void 0 !== e || t in n) || r(n, t, e);
    };
  }, function (n, t, e) {
    var r = e(97);

    n.exports = function (n) {
      return null != n && n.length ? r(n, 1) : [];
    };
  }, function (n, t, e) {
    var r = e(251),
        o = 1 / 0,
        i = 1.7976931348623157e308;

    n.exports = function (n) {
      return n ? (n = r(n)) === o || n === -o ? (n < 0 ? -1 : 1) * i : n == n ? n : 0 : 0 === n ? n : 0;
    };
  }, function (n, t, e) {
    var r = e(18);

    n.exports = function (n, t, e) {
      r.isArray(t) || (t = [t]);
      var o = (n.isDirected() ? n.successors : n.neighbors).bind(n),
          i = [],
          u = {};
      return r.each(t, function (t) {
        if (!n.hasNode(t)) throw new Error("Graph does not have node: " + t);
        !function n(t, e, o, i, u, a) {
          r.has(i, e) || (i[e] = !0, o || a.push(e), r.each(u(e), function (e) {
            n(t, e, o, i, u, a);
          }), o && a.push(e));
        }(n, t, "post" === e, u, o, i);
      }), i;
    };
  }, function (n, t, e) {
    var r = e(18);

    function o(n) {
      var t = {},
          e = {},
          o = [];
      if (r.each(n.sinks(), function u(a) {
        if (r.has(e, a)) throw new i();
        r.has(t, a) || (e[a] = !0, t[a] = !0, r.each(n.predecessors(a), u), delete e[a], o.push(a));
      }), r.size(t) !== n.nodeCount()) throw new i();
      return o;
    }

    function i() {}

    n.exports = o, o.CycleException = i, i.prototype = new Error();
  }, function (n, t, e) {
    var r = e(18);

    n.exports = function (n) {
      var t = 0,
          e = [],
          o = {},
          i = [];
      return n.nodes().forEach(function (u) {
        r.has(o, u) || function u(a) {
          var c = o[a] = {
            onStack: !0,
            lowlink: t,
            index: t++
          };

          if (e.push(a), n.successors(a).forEach(function (n) {
            r.has(o, n) ? o[n].onStack && (c.lowlink = Math.min(c.lowlink, o[n].index)) : (u(n), c.lowlink = Math.min(c.lowlink, o[n].lowlink));
          }), c.lowlink === c.index) {
            var f,
                s = [];

            do {
              f = e.pop(), o[f].onStack = !1, s.push(f);
            } while (a !== f);

            i.push(s);
          }
        }(u);
      }), i;
    };
  }, function (n, t, e) {
    var r = e(18);

    function o() {
      this._arr = [], this._keyIndices = {};
    }

    n.exports = o, o.prototype.size = function () {
      return this._arr.length;
    }, o.prototype.keys = function () {
      return this._arr.map(function (n) {
        return n.key;
      });
    }, o.prototype.has = function (n) {
      return r.has(this._keyIndices, n);
    }, o.prototype.priority = function (n) {
      var t = this._keyIndices[n];
      if (void 0 !== t) return this._arr[t].priority;
    }, o.prototype.min = function () {
      if (0 === this.size()) throw new Error("Queue underflow");
      return this._arr[0].key;
    }, o.prototype.add = function (n, t) {
      var e = this._keyIndices;

      if (n = String(n), !r.has(e, n)) {
        var o = this._arr,
            i = o.length;
        return e[n] = i, o.push({
          key: n,
          priority: t
        }), this._decrease(i), !0;
      }

      return !1;
    }, o.prototype.removeMin = function () {
      this._swap(0, this._arr.length - 1);

      var n = this._arr.pop();

      return delete this._keyIndices[n.key], this._heapify(0), n.key;
    }, o.prototype.decrease = function (n, t) {
      var e = this._keyIndices[n];
      if (t > this._arr[e].priority) throw new Error("New priority is greater than current priority. Key: " + n + " Old: " + this._arr[e].priority + " New: " + t);
      this._arr[e].priority = t, this._decrease(e);
    }, o.prototype._heapify = function (n) {
      var t = this._arr,
          e = 2 * n,
          r = e + 1,
          o = n;
      e < t.length && (o = t[e].priority < t[o].priority ? e : o, r < t.length && (o = t[r].priority < t[o].priority ? r : o), o !== n && (this._swap(n, o), this._heapify(o)));
    }, o.prototype._decrease = function (n) {
      for (var t, e = this._arr, r = e[n].priority; 0 !== n && !(e[t = n >> 1].priority < r);) {
        this._swap(n, t), n = t;
      }
    }, o.prototype._swap = function (n, t) {
      var e = this._arr,
          r = this._keyIndices,
          o = e[n],
          i = e[t];
      e[n] = i, e[t] = o, r[i.key] = n, r[o.key] = t;
    };
  }, function (n, t, e) {
    var r = e(18),
        o = e(193);

    n.exports = function (n, t, e, r) {
      return function (n, t, e, r) {
        var i,
            u,
            a = {},
            c = new o(),
            f = function f(n) {
          var t = n.v !== i ? n.v : n.w,
              r = a[t],
              o = e(n),
              f = u.distance + o;
          if (o < 0) throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + n + " Weight: " + o);
          f < r.distance && (r.distance = f, r.predecessor = i, c.decrease(t, f));
        };

        n.nodes().forEach(function (n) {
          var e = n === t ? 0 : Number.POSITIVE_INFINITY;
          a[n] = {
            distance: e
          }, c.add(n, e);
        });

        for (; c.size() > 0 && (i = c.removeMin(), (u = a[i]).distance !== Number.POSITIVE_INFINITY);) {
          r(i).forEach(f);
        }

        return a;
      }(n, String(t), e || i, r || function (t) {
        return n.outEdges(t);
      });
    };

    var i = r.constant(1);
  }, function (n, t, e) {
    var r = e(485),
        o = e(33);

    n.exports = function (n) {
      return null == n ? [] : r(n, o(n));
    };
  }, function (n, t, e) {
    var r = e(29),
        o = e(23);

    n.exports = function (n) {
      return o(n) && r(n);
    };
  }, function (n, t) {
    n.exports = function (n, t, e, r) {
      for (var o = n.length, i = e + (r ? 1 : -1); r ? i-- : ++i < o;) {
        if (t(n[i], i, n)) return i;
      }

      return -1;
    };
  }, function (n, t, e) {
    var r = e(495),
        o = e(494)(r);
    n.exports = o;
  }, function (n, t, e) {
    var r = e(496),
        o = Math.max;

    n.exports = function (n, t, e) {
      return t = o(void 0 === t ? n.length - 1 : t, 0), function () {
        for (var i = arguments, u = -1, a = o(i.length - t, 0), c = Array(a); ++u < a;) {
          c[u] = i[t + u];
        }

        u = -1;

        for (var f = Array(t + 1); ++u < t;) {
          f[u] = i[u];
        }

        return f[t] = e(c), r(n, this, f);
      };
    };
  }, function (n, t, e) {
    var r = e(507),
        o = e(72),
        i = e(28),
        u = e(506),
        a = e(11);

    n.exports = function (n, t, e) {
      var c = a(n) ? r : u,
          f = arguments.length < 3;
      return c(n, i(t, 4), e, f, o);
    };
  }, function (n, t, e) {
    var r = e(72),
        o = e(29);

    n.exports = function (n, t) {
      var e = -1,
          i = o(n) ? Array(n.length) : [];
      return r(n, function (n, r, o) {
        i[++e] = t(n, r, o);
      }), i;
    };
  }, function (n, t, e) {
    var r = e(70),
        o = e(28),
        i = e(201),
        u = e(11);

    n.exports = function (n, t) {
      return (u(n) ? r : i)(n, o(t, 3));
    };
  }, function (n, t) {
    n.exports = function (n) {
      return void 0 === n;
    };
  }, function (n, t, e) {
    var r = e(509),
        o = e(206);

    n.exports = function (n, t) {
      return null != n && o(n, t, r);
    };
  }, function (n, t) {
    n.exports = function (n) {
      return function (t) {
        return null == t ? void 0 : t[n];
      };
    };
  }, function (n, t, e) {
    var r = e(71),
        o = e(55),
        i = e(11),
        u = e(76),
        a = e(109),
        c = e(53);

    n.exports = function (n, t, e) {
      for (var f = -1, s = (t = r(t, n)).length, d = !1; ++f < s;) {
        var p = c(t[f]);
        if (!(d = null != n && e(n, p))) break;
        n = n[p];
      }

      return d || ++f != s ? d : !!(s = null == n ? 0 : n.length) && a(s) && u(p, s) && (i(n) || o(n));
    };
  }, function (n, t, e) {
    var r = e(512),
        o = e(206);

    n.exports = function (n, t) {
      return null != n && o(n, t, r);
    };
  }, function (n, t, e) {
    var r = e(513);

    n.exports = function (n) {
      return null == n ? "" : r(n);
    };
  }, function (n, t) {
    n.exports = function (n, t) {
      return function (e) {
        return null != e && e[n] === t && (void 0 !== t || n in Object(e));
      };
    };
  }, function (n, t, e) {
    var r = e(16);

    n.exports = function (n) {
      return n == n && !r(n);
    };
  }, function (n, t) {
    n.exports = function (n, t) {
      return n.has(t);
    };
  }, function (n, t, e) {
    var r = e(112),
        o = e(525),
        i = e(524);

    function u(n) {
      var t = -1,
          e = null == n ? 0 : n.length;

      for (this.__data__ = new r(); ++t < e;) {
        this.add(n[t]);
      }
    }

    u.prototype.add = u.prototype.push = o, u.prototype.has = i, n.exports = u;
  }, function (n, t, e) {
    var r = e(212),
        o = e(523),
        i = e(211),
        u = 1,
        a = 2;

    n.exports = function (n, t, e, c, f, s) {
      var d = e & u,
          p = n.length,
          h = t.length;
      if (p != h && !(d && h > p)) return !1;
      var v = s.get(n);
      if (v && s.get(t)) return v == t;
      var l = -1,
          g = !0,
          y = e & a ? new r() : void 0;

      for (s.set(n, t), s.set(t, n); ++l < p;) {
        var b = n[l],
            x = t[l];
        if (c) var m = d ? c(x, b, l, t, n, s) : c(b, x, l, n, t, s);

        if (void 0 !== m) {
          if (m) continue;
          g = !1;
          break;
        }

        if (y) {
          if (!o(t, function (n, t) {
            if (!i(y, t) && (b === n || f(b, n, e, c, s))) return y.push(t);
          })) {
            g = !1;
            break;
          }
        } else if (b !== x && !f(b, x, e, c, s)) {
          g = !1;
          break;
        }
      }

      return s.delete(n), s.delete(t), g;
    };
  }, function (n, t, e) {
    var r = e(526),
        o = e(23);

    n.exports = function n(t, e, i, u, a) {
      return t === e || (null == t || null == e || !o(t) && !o(e) ? t != t && e != e : r(t, e, i, u, n, a));
    };
  }, function (n, t, e) {
    var r = e(228),
        o = e(529),
        i = e(28),
        u = e(11);

    n.exports = function (n, t) {
      return (u(n) ? r : o)(n, i(t, 3));
    };
  }, function (n, t, e) {
    var r = e(36);

    n.exports = function (n) {
      return "function" == typeof n ? n : r;
    };
  }, function (n, t, e) {
    var r = e(111),
        o = e(72),
        i = e(216),
        u = e(11);

    n.exports = function (n, t) {
      return (u(n) ? r : o)(n, i(t));
    };
  }, function (n, t, e) {
    n.exports = e(217);
  }, function (n, t, e) {
    var r = e(16),
        o = Object.create,
        i = function () {
      function n() {}

      return function (t) {
        if (!r(t)) return {};
        if (o) return o(t);
        n.prototype = t;
        var e = new n();
        return n.prototype = void 0, e;
      };
    }();

    n.exports = i;
  }, function (n, t, e) {
    var r = e(219),
        o = e(73),
        i = e(74);

    n.exports = function (n) {
      return "function" != typeof n.constructor || i(n) ? {} : r(o(n));
    };
  }, function (n, t, e) {
    var r = e(104);

    n.exports = function (n, t) {
      var e = t ? r(n.buffer) : n.buffer;
      return new n.constructor(e, n.byteOffset, n.length);
    };
  }, function (n, t, e) {
    var r = e(20).Uint8Array;
    n.exports = r;
  }, function (n, t, e) {
    var r = e(37)(e(20), "Set");
    n.exports = r;
  }, function (n, t, e) {
    var r = e(105),
        o = e(11);

    n.exports = function (n, t, e) {
      var i = t(n);
      return o(n) ? i : r(i, e(n));
    };
  }, function (n, t, e) {
    var r = e(224),
        o = e(106),
        i = e(33);

    n.exports = function (n) {
      return r(n, i, o);
    };
  }, function (n, t, e) {
    var r = e(105),
        o = e(73),
        i = e(106),
        u = e(227),
        a = Object.getOwnPropertySymbols ? function (n) {
      for (var t = []; n;) {
        r(t, i(n)), n = o(n);
      }

      return t;
    } : u;
    n.exports = a;
  }, function (n, t) {
    n.exports = function () {
      return [];
    };
  }, function (n, t) {
    n.exports = function (n, t) {
      for (var e = -1, r = null == n ? 0 : n.length, o = 0, i = []; ++e < r;) {
        var u = n[e];
        t(u, e, n) && (i[o++] = u);
      }

      return i;
    };
  }, function (n, t) {
    n.exports = function (n, t) {
      var e = -1,
          r = n.length;

      for (t || (t = Array(r)); ++e < r;) {
        t[e] = n[e];
      }

      return t;
    };
  }, function (n, t, e) {
    (function (n) {
      var r = e(20),
          o = "object" == _typeof(t) && t && !t.nodeType && t,
          i = o && "object" == _typeof(n) && n && !n.nodeType && n,
          u = i && i.exports === o ? r.Buffer : void 0,
          a = u ? u.allocUnsafe : void 0;

      n.exports = function (n, t) {
        if (t) return n.slice();
        var e = n.length,
            r = a ? a(e) : new n.constructor(e);
        return n.copy(r), r;
      };
    }).call(this, e(110)(n));
  }, function (n, t) {
    n.exports = function (n, t) {
      return function (e) {
        return n(t(e));
      };
    };
  }, function (n, t, e) {
    var r = e(554),
        o = e(55),
        i = e(11),
        u = e(42),
        a = e(76),
        c = e(54),
        f = Object.prototype.hasOwnProperty;

    n.exports = function (n, t) {
      var e = i(n),
          s = !e && o(n),
          d = !e && !s && u(n),
          p = !e && !s && !d && c(n),
          h = e || s || d || p,
          v = h ? r(n.length, String) : [],
          l = v.length;

      for (var g in n) {
        !t && !f.call(n, g) || h && ("length" == g || d && ("offset" == g || "parent" == g) || p && ("buffer" == g || "byteLength" == g || "byteOffset" == g) || a(g, l)) || v.push(g);
      }

      return v;
    };
  }, function (n, t, e) {
    var r = e(37),
        o = function () {
      try {
        var n = r(Object, "defineProperty");
        return n({}, "", {}), n;
      } catch (n) {}
    }();

    n.exports = o;
  }, function (n, t) {
    var e = Function.prototype.toString;

    n.exports = function (n) {
      if (null != n) {
        try {
          return e.call(n);
        } catch (n) {}

        try {
          return n + "";
        } catch (n) {}
      }

      return "";
    };
  }, function (n, t, e) {
    var r = e(83),
        o = e(111),
        i = e(78),
        u = e(555),
        a = e(549),
        c = e(230),
        f = e(229),
        s = e(546),
        d = e(545),
        p = e(225),
        h = e(544),
        v = e(40),
        l = e(540),
        g = e(539),
        y = e(220),
        b = e(11),
        x = e(42),
        m = e(535),
        w = e(16),
        _ = e(533),
        E = e(33),
        j = 1,
        k = 2,
        O = 4,
        N = "[object Arguments]",
        I = "[object Function]",
        C = "[object GeneratorFunction]",
        P = "[object Object]",
        M = {};

    M[N] = M["[object Array]"] = M["[object ArrayBuffer]"] = M["[object DataView]"] = M["[object Boolean]"] = M["[object Date]"] = M["[object Float32Array]"] = M["[object Float64Array]"] = M["[object Int8Array]"] = M["[object Int16Array]"] = M["[object Int32Array]"] = M["[object Map]"] = M["[object Number]"] = M[P] = M["[object RegExp]"] = M["[object Set]"] = M["[object String]"] = M["[object Symbol]"] = M["[object Uint8Array]"] = M["[object Uint8ClampedArray]"] = M["[object Uint16Array]"] = M["[object Uint32Array]"] = !0, M["[object Error]"] = M[I] = M["[object WeakMap]"] = !1, n.exports = function n(t, e, S, A, L, T) {
      var z,
          R = e & j,
          F = e & k,
          D = e & O;
      if (S && (z = L ? S(t, A, L, T) : S(t)), void 0 !== z) return z;
      if (!w(t)) return t;
      var U = b(t);

      if (U) {
        if (z = l(t), !R) return f(t, z);
      } else {
        var V = v(t),
            B = V == I || V == C;
        if (x(t)) return c(t, R);

        if (V == P || V == N || B && !L) {
          if (z = F || B ? {} : y(t), !R) return F ? d(t, a(z, t)) : s(t, u(z, t));
        } else {
          if (!M[V]) return L ? t : {};
          z = g(t, V, R);
        }
      }

      T || (T = new r());
      var G = T.get(t);
      if (G) return G;
      if (T.set(t, z), _(t)) return t.forEach(function (r) {
        z.add(n(r, e, S, r, t, T));
      }), z;
      if (m(t)) return t.forEach(function (r, o) {
        z.set(o, n(r, e, S, o, t, T));
      }), z;
      var q = D ? F ? h : p : F ? keysIn : E,
          $ = U ? void 0 : q(t);
      return o($ || t, function (r, o) {
        $ && (r = t[o = r]), i(z, o, n(r, e, S, o, t, T));
      }), z;
    };
  },,,,,,,,,,,,,, function (n, t) {
    var e = Object.prototype.toString;

    n.exports = function (n) {
      return e.call(n);
    };
  }, function (n, t, e) {
    var r = e(38),
        o = Object.prototype,
        i = o.hasOwnProperty,
        u = o.toString,
        a = r ? r.toStringTag : void 0;

    n.exports = function (n) {
      var t = i.call(n, a),
          e = n[a];

      try {
        n[a] = void 0;
        var r = !0;
      } catch (n) {}

      var o = u.call(n);
      return r && (t ? n[a] = e : delete n[a]), o;
    };
  }, function (n, t, e) {
    var r = e(16),
        o = e(39),
        i = NaN,
        u = /^\s+|\s+$/g,
        a = /^[-+]0x[0-9a-f]+$/i,
        c = /^0b[01]+$/i,
        f = /^0o[0-7]+$/i,
        s = parseInt;

    n.exports = function (n) {
      if ("number" == typeof n) return n;
      if (o(n)) return i;

      if (r(n)) {
        var t = "function" == typeof n.valueOf ? n.valueOf() : n;
        n = r(t) ? t + "" : t;
      }

      if ("string" != typeof n) return 0 === n ? n : +n;
      n = n.replace(u, "");
      var e = c.test(n);
      return e || f.test(n) ? s(n.slice(2), e ? 2 : 8) : a.test(n) ? i : +n;
    };
  }, function (n, t) {
    var e;

    e = function () {
      return this;
    }();

    try {
      e = e || Function("return this")() || (0, eval)("this");
    } catch (n) {
      "object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && (e = window);
    }

    n.exports = e;
  }, function (n, t, e) {
    var r = e(20);

    n.exports = function () {
      return r.Date.now();
    };
  },,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, function (n, t) {
    n.exports = "0.8.4";
  }, function (n, t, e) {
    var r = e(7),
        o = e(15),
        i = e(22).Graph;
    n.exports = {
      debugOrdering: function debugOrdering(n) {
        var t = o.buildLayerMatrix(n),
            e = new i({
          compound: !0,
          multigraph: !0
        }).setGraph({});
        return r.forEach(n.nodes(), function (t) {
          e.setNode(t, {
            label: t
          }), e.setParent(t, "layer" + n.node(t).rank);
        }), r.forEach(n.edges(), function (n) {
          e.setEdge(n.v, n.w, {}, n.name);
        }), r.forEach(t, function (n, t) {
          var o = "layer" + t;
          e.setNode(o, {
            rank: "same"
          }), r.reduce(n, function (n, t) {
            return e.setEdge(n, t, {
              style: "invis"
            }), t;
          });
        }), e;
      }
    };
  }, function (n, t, e) {
    "use strict";

    var r = e(7),
        o = e(22).Graph,
        i = e(15);

    function u(n, t) {
      var e = {};
      return r.reduce(t, function (t, o) {
        var i = 0,
            u = 0,
            a = t.length,
            f = r.last(o);
        return r.forEach(o, function (t, s) {
          var d = function (n, t) {
            if (n.node(t).dummy) return r.find(n.predecessors(t), function (t) {
              return n.node(t).dummy;
            });
          }(n, t),
              p = d ? n.node(d).order : a;

          (d || t === f) && (r.forEach(o.slice(u, s + 1), function (t) {
            r.forEach(n.predecessors(t), function (r) {
              var o = n.node(r),
                  u = o.order;
              !(u < i || p < u) || o.dummy && n.node(t).dummy || c(e, r, t);
            });
          }), u = s + 1, i = p);
        }), o;
      }), e;
    }

    function a(n, t) {
      var e = {};

      function o(t, o, i, u, a) {
        var f;
        r.forEach(r.range(o, i), function (o) {
          f = t[o], n.node(f).dummy && r.forEach(n.predecessors(f), function (t) {
            var r = n.node(t);
            r.dummy && (r.order < u || r.order > a) && c(e, t, f);
          });
        });
      }

      return r.reduce(t, function (t, e) {
        var i,
            u = -1,
            a = 0;
        return r.forEach(e, function (r, c) {
          if ("border" === n.node(r).dummy) {
            var f = n.predecessors(r);
            f.length && (i = n.node(f[0]).order, o(e, a, c, u, i), a = c, u = i);
          }

          o(e, a, e.length, i, t.length);
        }), e;
      }), e;
    }

    function c(n, t, e) {
      if (t > e) {
        var r = t;
        t = e, e = r;
      }

      var o = n[t];
      o || (n[t] = o = {}), o[e] = !0;
    }

    function f(n, t, e) {
      if (t > e) {
        var o = t;
        t = e, e = o;
      }

      return r.has(n[t], e);
    }

    function s(n, t, e, o) {
      var i = {},
          u = {},
          a = {};
      return r.forEach(t, function (n) {
        r.forEach(n, function (n, t) {
          i[n] = n, u[n] = n, a[n] = t;
        });
      }), r.forEach(t, function (n) {
        var t = -1;
        r.forEach(n, function (n) {
          var c = o(n);
          if (c.length) for (var s = ((c = r.sortBy(c, function (n) {
            return a[n];
          })).length - 1) / 2, d = Math.floor(s), p = Math.ceil(s); d <= p; ++d) {
            var h = c[d];
            u[n] === n && t < a[h] && !f(e, n, h) && (u[h] = n, u[n] = i[n] = i[h], t = a[h]);
          }
        });
      }), {
        root: i,
        align: u
      };
    }

    function d(n, t, e, i, u) {
      var a = {},
          c = function (n, t, e, i) {
        var u = new o(),
            a = n.graph(),
            c = function (n, t, e) {
          return function (o, i, u) {
            var a,
                c = o.node(i),
                f = o.node(u),
                s = 0;
            if (s += c.width / 2, r.has(c, "labelpos")) switch (c.labelpos.toLowerCase()) {
              case "l":
                a = -c.width / 2;
                break;

              case "r":
                a = c.width / 2;
            }
            if (a && (s += e ? a : -a), a = 0, s += (c.dummy ? t : n) / 2, s += (f.dummy ? t : n) / 2, s += f.width / 2, r.has(f, "labelpos")) switch (f.labelpos.toLowerCase()) {
              case "l":
                a = f.width / 2;
                break;

              case "r":
                a = -f.width / 2;
            }
            return a && (s += e ? a : -a), a = 0, s;
          };
        }(a.nodesep, a.edgesep, i);

        return r.forEach(t, function (t) {
          var o;
          r.forEach(t, function (t) {
            var r = e[t];

            if (u.setNode(r), o) {
              var i = e[o],
                  a = u.edge(i, r);
              u.setEdge(i, r, Math.max(c(n, t, o), a || 0));
            }

            o = t;
          });
        }), u;
      }(n, t, e, u),
          f = u ? "borderLeft" : "borderRight";

      function s(n, t) {
        for (var e = c.nodes(), r = e.pop(), o = {}; r;) {
          o[r] ? n(r) : (o[r] = !0, e.push(r), e = e.concat(t(r))), r = e.pop();
        }
      }

      return s(function (n) {
        a[n] = c.inEdges(n).reduce(function (n, t) {
          return Math.max(n, a[t.v] + c.edge(t));
        }, 0);
      }, c.predecessors.bind(c)), s(function (t) {
        var e = c.outEdges(t).reduce(function (n, t) {
          return Math.min(n, a[t.w] - c.edge(t));
        }, Number.POSITIVE_INFINITY),
            r = n.node(t);
        e !== Number.POSITIVE_INFINITY && r.borderType !== f && (a[t] = Math.max(a[t], e));
      }, c.successors.bind(c)), r.forEach(i, function (n) {
        a[n] = a[e[n]];
      }), a;
    }

    function p(n, t) {
      return r.minBy(r.values(t), function (t) {
        var e = Number.NEGATIVE_INFINITY,
            o = Number.POSITIVE_INFINITY;
        return r.forIn(t, function (t, r) {
          var i = function (n, t) {
            return n.node(t).width;
          }(n, r) / 2;

          e = Math.max(t + i, e), o = Math.min(t - i, o);
        }), e - o;
      });
    }

    function h(n, t) {
      var e = r.values(t),
          o = r.min(e),
          i = r.max(e);
      r.forEach(["u", "d"], function (e) {
        r.forEach(["l", "r"], function (u) {
          var a,
              c = e + u,
              f = n[c];

          if (f !== t) {
            var s = r.values(f);
            (a = "l" === u ? o - r.min(s) : i - r.max(s)) && (n[c] = r.mapValues(f, function (n) {
              return n + a;
            }));
          }
        });
      });
    }

    function v(n, t) {
      return r.mapValues(n.ul, function (e, o) {
        if (t) return n[t.toLowerCase()][o];
        var i = r.sortBy(r.map(n, o));
        return (i[1] + i[2]) / 2;
      });
    }

    n.exports = {
      positionX: function positionX(n) {
        var t,
            e = i.buildLayerMatrix(n),
            o = r.merge(u(n, e), a(n, e)),
            c = {};
        r.forEach(["u", "d"], function (i) {
          t = "u" === i ? e : r.values(e).reverse(), r.forEach(["l", "r"], function (e) {
            "r" === e && (t = r.map(t, function (n) {
              return r.values(n).reverse();
            }));
            var u = ("u" === i ? n.predecessors : n.successors).bind(n),
                a = s(n, t, o, u),
                f = d(n, t, a.root, a.align, "r" === e);
            "r" === e && (f = r.mapValues(f, function (n) {
              return -n;
            })), c[i + e] = f;
          });
        });
        var f = p(n, c);
        return h(c, f), v(c, n.graph().align);
      },
      findType1Conflicts: u,
      findType2Conflicts: a,
      addConflict: c,
      hasConflict: f,
      verticalAlignment: s,
      horizontalCompaction: d,
      alignCoordinates: h,
      findSmallestWidthAlignment: p,
      balance: v
    };
  }, function (n, t, e) {
    "use strict";

    var r = e(7),
        o = e(15),
        i = e(417).positionX;

    n.exports = function (n) {
      (function (n) {
        var t = o.buildLayerMatrix(n),
            e = n.graph().ranksep,
            i = 0;
        r.forEach(t, function (t) {
          var o = r.max(r.map(t, function (t) {
            return n.node(t).height;
          }));
          r.forEach(t, function (t) {
            n.node(t).y = i + o / 2;
          }), i += o + e;
        });
      })(n = o.asNonCompoundGraph(n)), r.forEach(i(n), function (t, e) {
        n.node(e).x = t;
      });
    };
  }, function (n, t, e) {
    var r = e(7);

    n.exports = function (n, t, e) {
      var o,
          i = {};
      r.forEach(e, function (e) {
        for (var r, u, a = n.parent(e); a;) {
          if ((r = n.parent(a)) ? (u = i[r], i[r] = a) : (u = o, o = a), u && u !== a) return void t.setEdge(u, a);
          a = r;
        }
      });
    };
  }, function (n, t, e) {
    var r = e(7),
        o = e(22).Graph;

    n.exports = function (n, t, e) {
      var i = function (n) {
        var t;

        for (; n.hasNode(t = r.uniqueId("_root"));) {
          ;
        }

        return t;
      }(n),
          u = new o({
        compound: !0
      }).setGraph({
        root: i
      }).setDefaultNodeLabel(function (t) {
        return n.node(t);
      });

      return r.forEach(n.nodes(), function (o) {
        var a = n.node(o),
            c = n.parent(o);
        (a.rank === t || a.minRank <= t && t <= a.maxRank) && (u.setNode(o), u.setParent(o, c || i), r.forEach(n[e](o), function (t) {
          var e = t.v === o ? t.w : t.v,
              i = u.edge(e, o),
              a = r.isUndefined(i) ? 0 : i.weight;
          u.setEdge(e, o, {
            weight: n.edge(t).weight + a
          });
        }), r.has(a, "minRank") && u.setNode(o, {
          borderLeft: a.borderLeft[t],
          borderRight: a.borderRight[t]
        }));
      }), u;
    };
  }, function (n, t, e) {
    var r = e(7),
        o = e(15);

    function i(n, t, e) {
      for (var o; t.length && (o = r.last(t)).i <= e;) {
        t.pop(), n.push(o.vs), e++;
      }

      return e;
    }

    n.exports = function (n, t) {
      var e = o.partition(n, function (n) {
        return r.has(n, "barycenter");
      }),
          u = e.lhs,
          a = r.sortBy(e.rhs, function (n) {
        return -n.i;
      }),
          c = [],
          f = 0,
          s = 0,
          d = 0;
      u.sort(function (n) {
        return function (t, e) {
          return t.barycenter < e.barycenter ? -1 : t.barycenter > e.barycenter ? 1 : n ? e.i - t.i : t.i - e.i;
        };
      }(!!t)), d = i(c, a, d), r.forEach(u, function (n) {
        d += n.vs.length, c.push(n.vs), f += n.barycenter * n.weight, s += n.weight, d = i(c, a, d);
      });
      var p = {
        vs: r.flatten(c, !0)
      };
      s && (p.barycenter = f / s, p.weight = s);
      return p;
    };
  }, function (n, t, e) {
    "use strict";

    var r = e(7);

    n.exports = function (n, t) {
      var e = {};
      return r.forEach(n, function (n, t) {
        var o = e[n.v] = {
          indegree: 0,
          in: [],
          out: [],
          vs: [n.v],
          i: t
        };
        r.isUndefined(n.barycenter) || (o.barycenter = n.barycenter, o.weight = n.weight);
      }), r.forEach(t.edges(), function (n) {
        var t = e[n.v],
            o = e[n.w];
        r.isUndefined(t) || r.isUndefined(o) || (o.indegree++, t.out.push(e[n.w]));
      }), function (n) {
        var t = [];

        function e(n) {
          return function (t) {
            t.merged || (r.isUndefined(t.barycenter) || r.isUndefined(n.barycenter) || t.barycenter >= n.barycenter) && function (n, t) {
              var e = 0,
                  r = 0;
              n.weight && (e += n.barycenter * n.weight, r += n.weight), t.weight && (e += t.barycenter * t.weight, r += t.weight), n.vs = t.vs.concat(n.vs), n.barycenter = e / r, n.weight = r, n.i = Math.min(t.i, n.i), t.merged = !0;
            }(n, t);
          };
        }

        function o(t) {
          return function (e) {
            e.in.push(t), 0 == --e.indegree && n.push(e);
          };
        }

        for (; n.length;) {
          var i = n.pop();
          t.push(i), r.forEach(i.in.reverse(), e(i)), r.forEach(i.out, o(i));
        }

        return r.map(r.filter(t, function (n) {
          return !n.merged;
        }), function (n) {
          return r.pick(n, ["vs", "i", "barycenter", "weight"]);
        });
      }(r.filter(e, function (n) {
        return !n.indegree;
      }));
    };
  }, function (n, t, e) {
    var r = e(7);

    n.exports = function (n, t) {
      return r.map(t, function (t) {
        var e = n.inEdges(t);

        if (e.length) {
          var o = r.reduce(e, function (t, e) {
            var r = n.edge(e),
                o = n.node(e.v);
            return {
              sum: t.sum + r.weight * o.order,
              weight: t.weight + r.weight
            };
          }, {
            sum: 0,
            weight: 0
          });
          return {
            v: t,
            barycenter: o.sum / o.weight,
            weight: o.weight
          };
        }

        return {
          v: t
        };
      });
    };
  }, function (n, t, e) {
    var r = e(7),
        o = e(423),
        i = e(422),
        u = e(421);

    n.exports = function n(t, e, a, c) {
      var f = t.children(e),
          s = t.node(e),
          d = s ? s.borderLeft : void 0,
          p = s ? s.borderRight : void 0,
          h = {};
      d && (f = r.filter(f, function (n) {
        return n !== d && n !== p;
      }));
      var v = o(t, f);
      r.forEach(v, function (e) {
        if (t.children(e.v).length) {
          var o = n(t, e.v, a, c);
          h[e.v] = o, r.has(o, "barycenter") && function (n, t) {
            r.isUndefined(n.barycenter) ? (n.barycenter = t.barycenter, n.weight = t.weight) : (n.barycenter = (n.barycenter * n.weight + t.barycenter * t.weight) / (n.weight + t.weight), n.weight += t.weight);
          }(e, o);
        }
      });
      var l = i(v, a);
      !function (n, t) {
        r.forEach(n, function (n) {
          n.vs = r.flatten(n.vs.map(function (n) {
            return t[n] ? t[n].vs : n;
          }), !0);
        });
      }(l, h);
      var g = u(l, c);

      if (d && (g.vs = r.flatten([d, g.vs, p], !0), t.predecessors(d).length)) {
        var y = t.node(t.predecessors(d)[0]),
            b = t.node(t.predecessors(p)[0]);
        r.has(g, "barycenter") || (g.barycenter = 0, g.weight = 0), g.barycenter = (g.barycenter * g.weight + y.order + b.order) / (g.weight + 2), g.weight += 2;
      }

      return g;
    };
  }, function (n, t, e) {
    "use strict";

    var r = e(7);

    function o(n, t, e) {
      for (var o = r.zipObject(e, r.map(e, function (n, t) {
        return t;
      })), i = r.flatten(r.map(t, function (t) {
        return r.sortBy(r.map(n.outEdges(t), function (t) {
          return {
            pos: o[t.w],
            weight: n.edge(t).weight
          };
        }), "pos");
      }), !0), u = 1; u < e.length;) {
        u <<= 1;
      }

      var a = 2 * u - 1;
      u -= 1;
      var c = r.map(new Array(a), function () {
        return 0;
      }),
          f = 0;
      return r.forEach(i.forEach(function (n) {
        var t = n.pos + u;
        c[t] += n.weight;

        for (var e = 0; t > 0;) {
          t % 2 && (e += c[t + 1]), c[t = t - 1 >> 1] += n.weight;
        }

        f += n.weight * e;
      })), f;
    }

    n.exports = function (n, t) {
      for (var e = 0, r = 1; r < t.length; ++r) {
        e += o(n, t[r - 1], t[r]);
      }

      return e;
    };
  }, function (n, t, e) {
    "use strict";

    var r = e(7);

    n.exports = function (n) {
      var t = {},
          e = r.filter(n.nodes(), function (t) {
        return !n.children(t).length;
      }),
          o = r.max(r.map(e, function (t) {
        return n.node(t).rank;
      })),
          i = r.map(r.range(o + 1), function () {
        return [];
      });
      var u = r.sortBy(e, function (t) {
        return n.node(t).rank;
      });
      return r.forEach(u, function e(o) {
        if (!r.has(t, o)) {
          t[o] = !0;
          var u = n.node(o);
          i[u.rank].push(o), r.forEach(n.successors(o), e);
        }
      }), i;
    };
  }, function (n, t, e) {
    "use strict";

    var r = e(7),
        o = e(426),
        i = e(425),
        u = e(424),
        a = e(420),
        c = e(419),
        f = e(22).Graph,
        s = e(15);

    function d(n, t, e) {
      return r.map(t, function (t) {
        return a(n, t, e);
      });
    }

    function p(n, t) {
      var e = new f();
      r.forEach(n, function (n) {
        var o = n.graph().root,
            i = u(n, o, e, t);
        r.forEach(i.vs, function (t, e) {
          n.node(t).order = e;
        }), c(n, e, i.vs);
      });
    }

    function h(n, t) {
      r.forEach(t, function (t) {
        r.forEach(t, function (t, e) {
          n.node(t).order = e;
        });
      });
    }

    n.exports = function (n) {
      var t = s.maxRank(n),
          e = d(n, r.range(1, t + 1), "inEdges"),
          u = d(n, r.range(t - 1, -1, -1), "outEdges"),
          a = o(n);
      h(n, a);

      for (var c, f = Number.POSITIVE_INFINITY, v = 0, l = 0; l < 4; ++v, ++l) {
        p(v % 2 ? e : u, v % 4 >= 2), a = s.buildLayerMatrix(n);
        var g = i(n, a);
        g < f && (l = 0, c = r.cloneDeep(a), f = g);
      }

      h(n, c);
    };
  }, function (n, t, e) {
    "use strict";

    var r = e(7);

    function o(n) {
      r.forEach(n.nodes(), function (t) {
        i(n.node(t));
      }), r.forEach(n.edges(), function (t) {
        i(n.edge(t));
      });
    }

    function i(n) {
      var t = n.width;
      n.width = n.height, n.height = t;
    }

    function u(n) {
      n.y = -n.y;
    }

    function a(n) {
      var t = n.x;
      n.x = n.y, n.y = t;
    }

    n.exports = {
      adjust: function adjust(n) {
        var t = n.graph().rankdir.toLowerCase();
        "lr" !== t && "rl" !== t || o(n);
      },
      undo: function undo(n) {
        var t = n.graph().rankdir.toLowerCase();
        "bt" !== t && "rl" !== t || function (n) {
          r.forEach(n.nodes(), function (t) {
            u(n.node(t));
          }), r.forEach(n.edges(), function (t) {
            var e = n.edge(t);
            r.forEach(e.points, u), r.has(e, "y") && u(e);
          });
        }(n);
        "lr" !== t && "rl" !== t || (!function (n) {
          r.forEach(n.nodes(), function (t) {
            a(n.node(t));
          }), r.forEach(n.edges(), function (t) {
            var e = n.edge(t);
            r.forEach(e.points, a), r.has(e, "x") && a(e);
          });
        }(n), o(n));
      }
    };
  }, function (n, t, e) {
    var r = e(7),
        o = e(15);

    function i(n, t, e, r, i, u) {
      var a = {
        width: 0,
        height: 0,
        rank: u,
        borderType: t
      },
          c = i[t][u - 1],
          f = o.addDummyNode(n, "border", a, e);
      i[t][u] = f, n.setParent(f, r), c && n.setEdge(c, f, {
        weight: 1
      });
    }

    n.exports = function (n) {
      r.forEach(n.children(), function t(e) {
        var o = n.children(e),
            u = n.node(e);
        o.length && r.forEach(o, t);

        if (r.has(u, "minRank")) {
          u.borderLeft = [], u.borderRight = [];

          for (var a = u.minRank, c = u.maxRank + 1; a < c; ++a) {
            i(n, "borderLeft", "_bl", e, u, a), i(n, "borderRight", "_br", e, u, a);
          }
        }
      });
    };
  }, function (n, t, e) {
    var r = e(7),
        o = e(15);
    n.exports = {
      run: function run(n) {
        var t = o.addDummyNode(n, "root", {}, "_root"),
            e = function (n) {
          var t = {};
          return r.forEach(n.children(), function (e) {
            !function e(o, i) {
              var u = n.children(o);
              u && u.length && r.forEach(u, function (n) {
                e(n, i + 1);
              }), t[o] = i;
            }(e, 1);
          }), t;
        }(n),
            i = r.max(r.values(e)) - 1,
            u = 2 * i + 1;

        n.graph().nestingRoot = t, r.forEach(n.edges(), function (t) {
          n.edge(t).minlen *= u;
        });

        var a = function (n) {
          return r.reduce(n.edges(), function (t, e) {
            return t + n.edge(e).weight;
          }, 0);
        }(n) + 1;

        r.forEach(n.children(), function (c) {
          !function n(t, e, i, u, a, c, f) {
            var s = t.children(f);
            if (!s.length) return void (f !== e && t.setEdge(e, f, {
              weight: 0,
              minlen: i
            }));
            var d = o.addBorderNode(t, "_bt"),
                p = o.addBorderNode(t, "_bb"),
                h = t.node(f);
            t.setParent(d, f);
            h.borderTop = d;
            t.setParent(p, f);
            h.borderBottom = p;
            r.forEach(s, function (r) {
              n(t, e, i, u, a, c, r);
              var o = t.node(r),
                  s = o.borderTop ? o.borderTop : r,
                  h = o.borderBottom ? o.borderBottom : r,
                  v = o.borderTop ? u : 2 * u,
                  l = s !== h ? 1 : a - c[f] + 1;
              t.setEdge(d, s, {
                weight: v,
                minlen: l,
                nestingEdge: !0
              }), t.setEdge(h, p, {
                weight: v,
                minlen: l,
                nestingEdge: !0
              });
            });
            t.parent(f) || t.setEdge(e, d, {
              weight: 0,
              minlen: a + c[f]
            });
          }(n, t, u, a, i, e, c);
        }), n.graph().nodeRankFactor = u;
      },
      cleanup: function cleanup(n) {
        var t = n.graph();
        n.removeNode(t.nestingRoot), delete t.nestingRoot, r.forEach(n.edges(), function (t) {
          var e = n.edge(t);
          e.nestingEdge && n.removeEdge(t);
        });
      }
    };
  }, function (n, t, e) {
    var r = e(7);

    n.exports = function (n) {
      var t = function (n) {
        var t = {},
            e = 0;
        return r.forEach(n.children(), function o(i) {
          var u = e;
          r.forEach(n.children(i), o), t[i] = {
            low: u,
            lim: e++
          };
        }), t;
      }(n);

      r.forEach(n.graph().dummyChains, function (e) {
        for (var r = n.node(e), o = r.edgeObj, i = function (n, t, e, r) {
          var o,
              i,
              u = [],
              a = [],
              c = Math.min(t[e].low, t[r].low),
              f = Math.max(t[e].lim, t[r].lim);
          o = e;

          do {
            o = n.parent(o), u.push(o);
          } while (o && (t[o].low > c || f > t[o].lim));

          i = o, o = r;

          for (; (o = n.parent(o)) !== i;) {
            a.push(o);
          }

          return {
            path: u.concat(a.reverse()),
            lca: i
          };
        }(n, t, o.v, o.w), u = i.path, a = i.lca, c = 0, f = u[c], s = !0; e !== o.w;) {
          if (r = n.node(e), s) {
            for (; (f = u[c]) !== a && n.node(f).maxRank < r.rank;) {
              c++;
            }

            f === a && (s = !1);
          }

          if (!s) {
            for (; c < u.length - 1 && n.node(f = u[c + 1]).minRank <= r.rank;) {
              c++;
            }

            f = u[c];
          }

          n.setParent(e, f), e = n.successors(e)[0];
        }
      });
    };
  }, function (n, t, e) {
    "use strict";

    var r = e(7),
        o = e(184),
        i = e(67).slack,
        u = e(67).longestPath,
        a = e(22).alg.preorder,
        c = e(22).alg.postorder,
        f = e(15).simplify;

    function s(n) {
      n = f(n), u(n);
      var t,
          e = o(n);

      for (h(e), d(e, n); t = v(e);) {
        g(e, n, t, l(e, n, t));
      }
    }

    function d(n, t) {
      var e = c(n, n.nodes());
      e = e.slice(0, e.length - 1), r.forEach(e, function (e) {
        !function (n, t, e) {
          var r = n.node(e).parent;
          n.edge(e, r).cutvalue = p(n, t, e);
        }(n, t, e);
      });
    }

    function p(n, t, e) {
      var o = n.node(e).parent,
          i = !0,
          u = t.edge(e, o),
          a = 0;
      return u || (i = !1, u = t.edge(o, e)), a = u.weight, r.forEach(t.nodeEdges(e), function (r) {
        var u = r.v === e,
            c = u ? r.w : r.v;

        if (c !== o) {
          var f = u === i,
              s = t.edge(r).weight;

          if (a += f ? s : -s, function (n, t, e) {
            return n.hasEdge(t, e);
          }(n, e, c)) {
            var d = n.edge(e, c).cutvalue;
            a += f ? -d : d;
          }
        }
      }), a;
    }

    function h(n, t) {
      arguments.length < 2 && (t = n.nodes()[0]), function n(t, e, o, i, u) {
        var a = o,
            c = t.node(i);
        e[i] = !0;
        r.forEach(t.neighbors(i), function (u) {
          r.has(e, u) || (o = n(t, e, o, u, i));
        });
        c.low = a;
        c.lim = o++;
        u ? c.parent = u : delete c.parent;
        return o;
      }(n, {}, 1, t);
    }

    function v(n) {
      return r.find(n.edges(), function (t) {
        return n.edge(t).cutvalue < 0;
      });
    }

    function l(n, t, e) {
      var o = e.v,
          u = e.w;
      t.hasEdge(o, u) || (o = e.w, u = e.v);
      var a = n.node(o),
          c = n.node(u),
          f = a,
          s = !1;
      a.lim > c.lim && (f = c, s = !0);
      var d = r.filter(t.edges(), function (t) {
        return s === y(n, n.node(t.v), f) && s !== y(n, n.node(t.w), f);
      });
      return r.minBy(d, function (n) {
        return i(t, n);
      });
    }

    function g(n, t, e, o) {
      var i = e.v,
          u = e.w;
      n.removeEdge(i, u), n.setEdge(o.v, o.w, {}), h(n), d(n, t), function (n, t) {
        var e = r.find(n.nodes(), function (n) {
          return !t.node(n).parent;
        }),
            o = a(n, e);
        o = o.slice(1), r.forEach(o, function (e) {
          var r = n.node(e).parent,
              o = t.edge(e, r),
              i = !1;
          o || (o = t.edge(r, e), i = !0), t.node(e).rank = t.node(r).rank + (i ? o.minlen : -o.minlen);
        });
      }(n, t);
    }

    function y(n, t, e) {
      return e.low <= t.lim && t.lim <= e.lim;
    }

    n.exports = s, s.initLowLimValues = h, s.initCutValues = d, s.calcCutValue = p, s.leaveEdge = v, s.enterEdge = l, s.exchangeEdges = g;
  }, function (n, t, e) {
    "use strict";

    var r = e(67).longestPath,
        o = e(184),
        i = e(432);

    n.exports = function (n) {
      switch (n.graph().ranker) {
        case "network-simplex":
          a(n);
          break;

        case "tight-tree":
          !function (n) {
            r(n), o(n);
          }(n);
          break;

        case "longest-path":
          u(n);
          break;

        default:
          a(n);
      }
    };

    var u = r;

    function a(n) {
      i(n);
    }
  }, function (n, t, e) {
    "use strict";

    var r = e(7),
        o = e(15);
    n.exports = {
      run: function run(n) {
        n.graph().dummyChains = [], r.forEach(n.edges(), function (t) {
          !function (n, t) {
            var e,
                r,
                i,
                u = t.v,
                a = n.node(u).rank,
                c = t.w,
                f = n.node(c).rank,
                s = t.name,
                d = n.edge(t),
                p = d.labelRank;
            if (f === a + 1) return;

            for (n.removeEdge(t), i = 0, ++a; a < f; ++i, ++a) {
              d.points = [], r = {
                width: 0,
                height: 0,
                edgeLabel: d,
                edgeObj: t,
                rank: a
              }, e = o.addDummyNode(n, "edge", r, "_d"), a === p && (r.width = d.width, r.height = d.height, r.dummy = "edge-label", r.labelpos = d.labelpos), n.setEdge(u, e, {
                weight: d.weight
              }, s), 0 === i && n.graph().dummyChains.push(e), u = e;
            }

            n.setEdge(u, c, {
              weight: d.weight
            }, s);
          }(n, t);
        });
      },
      undo: function undo(n) {
        r.forEach(n.graph().dummyChains, function (t) {
          var e,
              r = n.node(t),
              o = r.edgeLabel;

          for (n.setEdge(r.edgeObj, o); r.dummy;) {
            e = n.successors(t)[0], n.removeNode(t), o.points.push({
              x: r.x,
              y: r.y
            }), "edge-label" === r.dummy && (o.x = r.x, o.y = r.y, o.width = r.width, o.height = r.height), t = e, r = n.node(t);
          }
        });
      }
    };
  }, function (n, t) {
    function e() {
      var n = {};
      n._next = n._prev = n, this._sentinel = n;
    }

    function r(n) {
      n._prev._next = n._next, n._next._prev = n._prev, delete n._next, delete n._prev;
    }

    function o(n, t) {
      if ("_next" !== n && "_prev" !== n) return t;
    }

    n.exports = e, e.prototype.dequeue = function () {
      var n = this._sentinel,
          t = n._prev;
      if (t !== n) return r(t), t;
    }, e.prototype.enqueue = function (n) {
      var t = this._sentinel;
      n._prev && n._next && r(n), n._next = t._next, t._next._prev = n, t._next = n, n._prev = t;
    }, e.prototype.toString = function () {
      for (var n = [], t = this._sentinel, e = t._prev; e !== t;) {
        n.push(JSON.stringify(e, o)), e = e._prev;
      }

      return "[" + n.join(", ") + "]";
    };
  }, function (n, t, e) {
    var r = e(7),
        o = e(22).Graph,
        i = e(435);

    n.exports = function (n, t) {
      if (n.nodeCount() <= 1) return [];

      var e = function (n, t) {
        var e = new o(),
            u = 0,
            a = 0;
        r.forEach(n.nodes(), function (n) {
          e.setNode(n, {
            v: n,
            in: 0,
            out: 0
          });
        }), r.forEach(n.edges(), function (n) {
          var r = e.edge(n.v, n.w) || 0,
              o = t(n),
              i = r + o;
          e.setEdge(n.v, n.w, i), a = Math.max(a, e.node(n.v).out += o), u = Math.max(u, e.node(n.w).in += o);
        });
        var f = r.range(a + u + 3).map(function () {
          return new i();
        }),
            s = u + 1;
        return r.forEach(e.nodes(), function (n) {
          c(f, s, e.node(n));
        }), {
          graph: e,
          buckets: f,
          zeroIdx: s
        };
      }(n, t || u),
          f = function (n, t, e) {
        var r,
            o = [],
            i = t[t.length - 1],
            u = t[0];

        for (; n.nodeCount();) {
          for (; r = u.dequeue();) {
            a(n, t, e, r);
          }

          for (; r = i.dequeue();) {
            a(n, t, e, r);
          }

          if (n.nodeCount()) for (var c = t.length - 2; c > 0; --c) {
            if (r = t[c].dequeue()) {
              o = o.concat(a(n, t, e, r, !0));
              break;
            }
          }
        }

        return o;
      }(e.graph, e.buckets, e.zeroIdx);

      return r.flatten(r.map(f, function (t) {
        return n.outEdges(t.v, t.w);
      }), !0);
    };

    var u = r.constant(1);

    function a(n, t, e, o, i) {
      var u = i ? [] : void 0;
      return r.forEach(n.inEdges(o.v), function (r) {
        var o = n.edge(r),
            a = n.node(r.v);
        i && u.push({
          v: r.v,
          w: r.w
        }), a.out -= o, c(t, e, a);
      }), r.forEach(n.outEdges(o.v), function (r) {
        var o = n.edge(r),
            i = r.w,
            u = n.node(i);
        u.in -= o, c(t, e, u);
      }), n.removeNode(o.v), u;
    }

    function c(n, t, e) {
      e.out ? e.in ? n[e.out - e.in + t].enqueue(e) : n[n.length - 1].enqueue(e) : n[0].enqueue(e);
    }
  }, function (n, t, e) {
    "use strict";

    var r = e(7),
        o = e(436);
    n.exports = {
      run: function run(n) {
        var t = "greedy" === n.graph().acyclicer ? o(n, function (n) {
          return function (t) {
            return n.edge(t).weight;
          };
        }(n)) : function (n) {
          var t = [],
              e = {},
              o = {};
          return r.forEach(n.nodes(), function i(u) {
            r.has(o, u) || (o[u] = !0, e[u] = !0, r.forEach(n.outEdges(u), function (n) {
              r.has(e, n.w) ? t.push(n) : i(n.w);
            }), delete e[u]);
          }), t;
        }(n);
        r.forEach(t, function (t) {
          var e = n.edge(t);
          n.removeEdge(t), e.forwardName = t.name, e.reversed = !0, n.setEdge(t.w, t.v, e, r.uniqueId("rev"));
        });
      },
      undo: function undo(n) {
        r.forEach(n.edges(), function (t) {
          var e = n.edge(t);

          if (e.reversed) {
            n.removeEdge(t);
            var r = e.forwardName;
            delete e.reversed, delete e.forwardName, n.setEdge(t.w, t.v, e, r);
          }
        });
      }
    };
  }, function (n, t) {
    n.exports = function (n, t, e) {
      for (var r = -1, o = n.length, i = t.length, u = {}; ++r < o;) {
        var a = r < i ? t[r] : void 0;
        e(u, n[r], a);
      }

      return u;
    };
  }, function (n, t, e) {
    var r = e(78),
        o = e(438);

    n.exports = function (n, t) {
      return o(n || [], t || [], r);
    };
  }, function (n, t, e) {
    var r = e(208),
        o = 0;

    n.exports = function (n) {
      var t = ++o;
      return r(n) + t;
    };
  }, function (n, t, e) {
    var r = e(39);

    n.exports = function (n, t) {
      if (n !== t) {
        var e = void 0 !== n,
            o = null === n,
            i = n == n,
            u = r(n),
            a = void 0 !== t,
            c = null === t,
            f = t == t,
            s = r(t);
        if (!c && !s && !u && n > t || u && a && f && !c && !s || o && a && f || !e && f || !i) return 1;
        if (!o && !u && !s && n < t || s && e && i && !o && !u || c && e && i || !a && i || !f) return -1;
      }

      return 0;
    };
  }, function (n, t, e) {
    var r = e(441);

    n.exports = function (n, t, e) {
      for (var o = -1, i = n.criteria, u = t.criteria, a = i.length, c = e.length; ++o < a;) {
        var f = r(i[o], u[o]);
        if (f) return o >= c ? f : f * ("desc" == e[o] ? -1 : 1);
      }

      return n.index - t.index;
    };
  }, function (n, t) {
    n.exports = function (n, t) {
      var e = n.length;

      for (n.sort(t); e--;) {
        n[e] = n[e].value;
      }

      return n;
    };
  }, function (n, t, e) {
    var r = e(70),
        o = e(28),
        i = e(201),
        u = e(443),
        a = e(75),
        c = e(442),
        f = e(36);

    n.exports = function (n, t, e) {
      var s = -1;
      t = r(t.length ? t : [f], a(o));
      var d = i(n, function (n, e, o) {
        return {
          criteria: r(t, function (t) {
            return t(n);
          }),
          index: ++s,
          value: n
        };
      });
      return u(d, function (n, t) {
        return c(n, t, e);
      });
    };
  }, function (n, t, e) {
    var r = e(97),
        o = e(444),
        i = e(69),
        u = e(68),
        a = i(function (n, t) {
      if (null == n) return [];
      var e = t.length;
      return e > 1 && u(n, t[0], t[1]) ? t = [] : e > 2 && u(t[0], t[1], t[2]) && (t = [t[0]]), o(n, r(t, 1), []);
    });
    n.exports = a;
  }, function (n, t) {
    var e = Math.ceil,
        r = Math.max;

    n.exports = function (n, t, o, i) {
      for (var u = -1, a = r(e((t - n) / (o || 1)), 0), c = Array(a); a--;) {
        c[i ? a : ++u] = n, n += o;
      }

      return c;
    };
  }, function (n, t, e) {
    var r = e(446),
        o = e(68),
        i = e(189);

    n.exports = function (n) {
      return function (t, e, u) {
        return u && "number" != typeof u && o(t, e, u) && (e = u = void 0), t = i(t), void 0 === e ? (e = t, t = 0) : e = i(e), u = void 0 === u ? t < e ? 1 : -1 : i(u), r(t, e, u, n);
      };
    };
  }, function (n, t, e) {
    var r = e(447)();
    n.exports = r;
  }, function (n, t, e) {
    var r = e(188),
        o = e(199),
        i = e(198);

    n.exports = function (n) {
      return i(o(n, void 0, r), n + "");
    };
  }, function (n, t, e) {
    var r = e(78),
        o = e(71),
        i = e(76),
        u = e(16),
        a = e(53);

    n.exports = function (n, t, e, c) {
      if (!u(n)) return n;

      for (var f = -1, s = (t = o(t, n)).length, d = s - 1, p = n; null != p && ++f < s;) {
        var h = a(t[f]),
            v = e;

        if (f != d) {
          var l = p[h];
          void 0 === (v = c ? c(l, h, p) : void 0) && (v = u(l) ? l : i(t[f + 1]) ? [] : {});
        }

        r(p, h, v), p = p[h];
      }

      return n;
    };
  }, function (n, t, e) {
    var r = e(99),
        o = e(450),
        i = e(71);

    n.exports = function (n, t, e) {
      for (var u = -1, a = t.length, c = {}; ++u < a;) {
        var f = t[u],
            s = r(n, f);
        e(s, f) && o(c, i(f, n), s);
      }

      return c;
    };
  }, function (n, t, e) {
    var r = e(451),
        o = e(207);

    n.exports = function (n, t) {
      return r(n, t, function (t, e) {
        return o(n, e);
      });
    };
  }, function (n, t, e) {
    var r = e(452),
        o = e(449)(function (n, t) {
      return null == n ? {} : r(n, t);
    });
    n.exports = o;
  }, function (n, t, e) {
    var r = e(96),
        o = e(28),
        i = e(185);

    n.exports = function (n, t) {
      return n && n.length ? r(n, o(t, 2), i) : void 0;
    };
  }, function (n, t, e) {
    var r = e(96),
        o = e(185),
        i = e(36);

    n.exports = function (n) {
      return n && n.length ? r(n, i, o) : void 0;
    };
  }, function (n, t, e) {
    var r = e(69),
        o = e(68);

    n.exports = function (n) {
      return r(function (t, e) {
        var r = -1,
            i = e.length,
            u = i > 1 ? e[i - 1] : void 0,
            a = i > 2 ? e[2] : void 0;

        for (u = n.length > 3 && "function" == typeof u ? (i--, u) : void 0, a && o(e[0], e[1], a) && (u = i < 3 ? void 0 : u, i = 1), t = Object(t); ++r < i;) {
          var c = e[r];
          c && n(t, c, r, u);
        }

        return t;
      });
    };
  }, function (n, t, e) {
    var r = e(56),
        o = e(41);

    n.exports = function (n) {
      return r(n, o(n));
    };
  }, function (n, t, e) {
    var r = e(34),
        o = e(73),
        i = e(23),
        u = "[object Object]",
        a = Function.prototype,
        c = Object.prototype,
        f = a.toString,
        s = c.hasOwnProperty,
        d = f.call(Object);

    n.exports = function (n) {
      if (!i(n) || r(n) != u) return !1;
      var t = o(n);
      if (null === t) return !0;
      var e = s.call(t, "constructor") && t.constructor;
      return "function" == typeof e && e instanceof e && f.call(e) == d;
    };
  }, function (n, t, e) {
    var r = e(187),
        o = e(230),
        i = e(221),
        u = e(229),
        a = e(220),
        c = e(55),
        f = e(11),
        s = e(196),
        d = e(42),
        p = e(57),
        h = e(16),
        v = e(458),
        l = e(54),
        g = e(186),
        y = e(457);

    n.exports = function (n, t, e, b, x, m, w) {
      var _ = g(n, e),
          E = g(t, e),
          j = w.get(E);

      if (j) r(n, e, j);else {
        var k = m ? m(_, E, e + "", n, t, w) : void 0,
            O = void 0 === k;

        if (O) {
          var N = f(E),
              I = !N && d(E),
              C = !N && !I && l(E);
          k = E, N || I || C ? f(_) ? k = _ : s(_) ? k = u(_) : I ? (O = !1, k = o(E, !0)) : C ? (O = !1, k = i(E, !0)) : k = [] : v(E) || c(E) ? (k = _, c(_) ? k = y(_) : h(_) && !p(_) || (k = a(E))) : O = !1;
        }

        O && (w.set(E, k), x(k, E, b, m, w), w.delete(E)), r(n, e, k);
      }
    };
  }, function (n, t, e) {
    var r = e(83),
        o = e(187),
        i = e(101),
        u = e(459),
        a = e(16),
        c = e(41),
        f = e(186);

    n.exports = function n(t, e, s, d, p) {
      t !== e && i(e, function (i, c) {
        if (a(i)) p || (p = new r()), u(t, e, c, s, n, d, p);else {
          var h = d ? d(f(t, c), i, c + "", t, e, p) : void 0;
          void 0 === h && (h = i), o(t, c, h);
        }
      }, c);
    };
  }, function (n, t, e) {
    var r = e(460),
        o = e(456)(function (n, t, e) {
      r(n, t, e);
    });
    n.exports = o;
  }, function (n, t) {
    n.exports = function (n, t) {
      return n > t;
    };
  }, function (n, t, e) {
    var r = e(96),
        o = e(462),
        i = e(36);

    n.exports = function (n) {
      return n && n.length ? r(n, i, o) : void 0;
    };
  }, function (n, t, e) {
    var r = e(77),
        o = e(102),
        i = e(28);

    n.exports = function (n, t) {
      var e = {};
      return t = i(t, 3), o(n, function (n, o, i) {
        r(e, o, t(n, o, i));
      }), e;
    };
  }, function (n, t) {
    n.exports = function (n) {
      var t = null == n ? 0 : n.length;
      return t ? n[t - 1] : void 0;
    };
  }, function (n, t, e) {
    var r = e(101),
        o = e(216),
        i = e(41);

    n.exports = function (n, t) {
      return null == n ? n : r(n, o(t), i);
    };
  }, function (n, t, e) {
    var r = e(189);

    n.exports = function (n) {
      var t = r(n),
          e = t % 1;
      return t == t ? e ? t - e : t : 0;
    };
  }, function (n, t, e) {
    var r = e(197),
        o = e(28),
        i = e(467),
        u = Math.max;

    n.exports = function (n, t, e) {
      var a = null == n ? 0 : n.length;
      if (!a) return -1;
      var c = null == e ? 0 : i(e);
      return c < 0 && (c = u(a + c, 0)), r(n, o(t, 3), c);
    };
  }, function (n, t, e) {
    var r = e(28),
        o = e(29),
        i = e(33);

    n.exports = function (n) {
      return function (t, e, u) {
        var a = Object(t);

        if (!o(t)) {
          var c = r(e, 3);
          t = i(t), e = function e(n) {
            return c(a[n], n, a);
          };
        }

        var f = n(t, e, u);
        return f > -1 ? a[c ? t[f] : f] : void 0;
      };
    };
  }, function (n, t, e) {
    var r = e(469)(e(468));
    n.exports = r;
  }, function (n, t, e) {
    var r = e(69),
        o = e(43),
        i = e(68),
        u = e(41),
        a = Object.prototype,
        c = a.hasOwnProperty,
        f = r(function (n, t) {
      n = Object(n);
      var e = -1,
          r = t.length,
          f = r > 2 ? t[2] : void 0;

      for (f && i(t[0], t[1], f) && (r = 1); ++e < r;) {
        for (var s = t[e], d = u(s), p = -1, h = d.length; ++p < h;) {
          var v = d[p],
              l = n[v];
          (void 0 === l || o(l, a[v]) && !c.call(n, v)) && (n[v] = s[v]);
        }
      }

      return n;
    });
    n.exports = f;
  }, function (n, t, e) {
    var r = e(235),
        o = 1,
        i = 4;

    n.exports = function (n) {
      return r(n, o | i);
    };
  }, function (n, t, e) {
    "use strict";

    var r = e(7),
        o = e(437),
        i = e(434),
        u = e(433),
        a = e(15).normalizeRanks,
        c = e(431),
        f = e(15).removeEmptyRanks,
        s = e(430),
        d = e(429),
        p = e(428),
        h = e(427),
        v = e(418),
        l = e(15),
        g = e(22).Graph;

    n.exports = function (n, t) {
      var e = t && t.debugTiming ? l.time : l.notime;
      e("layout", function () {
        var t = e("  buildLayoutGraph", function () {
          return function (n) {
            var t = new g({
              multigraph: !0,
              compound: !0
            }),
                e = O(n.graph());
            return t.setGraph(r.merge({}, b, k(e, y), r.pick(e, x))), r.forEach(n.nodes(), function (e) {
              var o = O(n.node(e));
              t.setNode(e, r.defaults(k(o, m), w)), t.setParent(e, n.parent(e));
            }), r.forEach(n.edges(), function (e) {
              var o = O(n.edge(e));
              t.setEdge(e, r.merge({}, E, k(o, _), r.pick(o, j)));
            }), t;
          }(n);
        });
        e("  runLayout", function () {
          !function (n, t) {
            t("    makeSpaceForEdgeLabels", function () {
              !function (n) {
                var t = n.graph();
                t.ranksep /= 2, r.forEach(n.edges(), function (e) {
                  var r = n.edge(e);
                  r.minlen *= 2, "c" !== r.labelpos.toLowerCase() && ("TB" === t.rankdir || "BT" === t.rankdir ? r.width += r.labeloffset : r.height += r.labeloffset);
                });
              }(n);
            }), t("    removeSelfEdges", function () {
              !function (n) {
                r.forEach(n.edges(), function (t) {
                  if (t.v === t.w) {
                    var e = n.node(t.v);
                    e.selfEdges || (e.selfEdges = []), e.selfEdges.push({
                      e: t,
                      label: n.edge(t)
                    }), n.removeEdge(t);
                  }
                });
              }(n);
            }), t("    acyclic", function () {
              o.run(n);
            }), t("    nestingGraph.run", function () {
              s.run(n);
            }), t("    rank", function () {
              u(l.asNonCompoundGraph(n));
            }), t("    injectEdgeLabelProxies", function () {
              !function (n) {
                r.forEach(n.edges(), function (t) {
                  var e = n.edge(t);

                  if (e.width && e.height) {
                    var r = n.node(t.v),
                        o = n.node(t.w),
                        i = {
                      rank: (o.rank - r.rank) / 2 + r.rank,
                      e: t
                    };
                    l.addDummyNode(n, "edge-proxy", i, "_ep");
                  }
                });
              }(n);
            }), t("    removeEmptyRanks", function () {
              f(n);
            }), t("    nestingGraph.cleanup", function () {
              s.cleanup(n);
            }), t("    normalizeRanks", function () {
              a(n);
            }), t("    assignRankMinMax", function () {
              !function (n) {
                var t = 0;
                r.forEach(n.nodes(), function (e) {
                  var o = n.node(e);
                  o.borderTop && (o.minRank = n.node(o.borderTop).rank, o.maxRank = n.node(o.borderBottom).rank, t = r.max(t, o.maxRank));
                }), n.graph().maxRank = t;
              }(n);
            }), t("    removeEdgeLabelProxies", function () {
              !function (n) {
                r.forEach(n.nodes(), function (t) {
                  var e = n.node(t);
                  "edge-proxy" === e.dummy && (n.edge(e.e).labelRank = e.rank, n.removeNode(t));
                });
              }(n);
            }), t("    normalize.run", function () {
              i.run(n);
            }), t("    parentDummyChains", function () {
              c(n);
            }), t("    addBorderSegments", function () {
              d(n);
            }), t("    order", function () {
              h(n);
            }), t("    insertSelfEdges", function () {
              !function (n) {
                var t = l.buildLayerMatrix(n);
                r.forEach(t, function (t) {
                  var e = 0;
                  r.forEach(t, function (t, o) {
                    var i = n.node(t);
                    i.order = o + e, r.forEach(i.selfEdges, function (t) {
                      l.addDummyNode(n, "selfedge", {
                        width: t.label.width,
                        height: t.label.height,
                        rank: i.rank,
                        order: o + ++e,
                        e: t.e,
                        label: t.label
                      }, "_se");
                    }), delete i.selfEdges;
                  });
                });
              }(n);
            }), t("    adjustCoordinateSystem", function () {
              p.adjust(n);
            }), t("    position", function () {
              v(n);
            }), t("    positionSelfEdges", function () {
              !function (n) {
                r.forEach(n.nodes(), function (t) {
                  var e = n.node(t);

                  if ("selfedge" === e.dummy) {
                    var r = n.node(e.e.v),
                        o = r.x + r.width / 2,
                        i = r.y,
                        u = e.x - o,
                        a = r.height / 2;
                    n.setEdge(e.e, e.label), n.removeNode(t), e.label.points = [{
                      x: o + 2 * u / 3,
                      y: i - a
                    }, {
                      x: o + 5 * u / 6,
                      y: i - a
                    }, {
                      x: o + u,
                      y: i
                    }, {
                      x: o + 5 * u / 6,
                      y: i + a
                    }, {
                      x: o + 2 * u / 3,
                      y: i + a
                    }], e.label.x = e.x, e.label.y = e.y;
                  }
                });
              }(n);
            }), t("    removeBorderNodes", function () {
              !function (n) {
                r.forEach(n.nodes(), function (t) {
                  if (n.children(t).length) {
                    var e = n.node(t),
                        o = n.node(e.borderTop),
                        i = n.node(e.borderBottom),
                        u = n.node(r.last(e.borderLeft)),
                        a = n.node(r.last(e.borderRight));
                    e.width = Math.abs(a.x - u.x), e.height = Math.abs(i.y - o.y), e.x = u.x + e.width / 2, e.y = o.y + e.height / 2;
                  }
                }), r.forEach(n.nodes(), function (t) {
                  "border" === n.node(t).dummy && n.removeNode(t);
                });
              }(n);
            }), t("    normalize.undo", function () {
              i.undo(n);
            }), t("    fixupEdgeLabelCoords", function () {
              !function (n) {
                r.forEach(n.edges(), function (t) {
                  var e = n.edge(t);
                  if (r.has(e, "x")) switch ("l" !== e.labelpos && "r" !== e.labelpos || (e.width -= e.labeloffset), e.labelpos) {
                    case "l":
                      e.x -= e.width / 2 + e.labeloffset;
                      break;

                    case "r":
                      e.x += e.width / 2 + e.labeloffset;
                  }
                });
              }(n);
            }), t("    undoCoordinateSystem", function () {
              p.undo(n);
            }), t("    translateGraph", function () {
              !function (n) {
                var t = Number.POSITIVE_INFINITY,
                    e = 0,
                    o = Number.POSITIVE_INFINITY,
                    i = 0,
                    u = n.graph(),
                    a = u.marginx || 0,
                    c = u.marginy || 0;

                function f(n) {
                  var r = n.x,
                      u = n.y,
                      a = n.width,
                      c = n.height;
                  t = Math.min(t, r - a / 2), e = Math.max(e, r + a / 2), o = Math.min(o, u - c / 2), i = Math.max(i, u + c / 2);
                }

                r.forEach(n.nodes(), function (t) {
                  f(n.node(t));
                }), r.forEach(n.edges(), function (t) {
                  var e = n.edge(t);
                  r.has(e, "x") && f(e);
                }), t -= a, o -= c, r.forEach(n.nodes(), function (e) {
                  var r = n.node(e);
                  r.x -= t, r.y -= o;
                }), r.forEach(n.edges(), function (e) {
                  var i = n.edge(e);
                  r.forEach(i.points, function (n) {
                    n.x -= t, n.y -= o;
                  }), r.has(i, "x") && (i.x -= t), r.has(i, "y") && (i.y -= o);
                }), u.width = e - t + a, u.height = i - o + c;
              }(n);
            }), t("    assignNodeIntersects", function () {
              !function (n) {
                r.forEach(n.edges(), function (t) {
                  var e,
                      r,
                      o = n.edge(t),
                      i = n.node(t.v),
                      u = n.node(t.w);
                  o.points ? (e = o.points[0], r = o.points[o.points.length - 1]) : (o.points = [], e = u, r = i), o.points.unshift(l.intersectRect(i, e)), o.points.push(l.intersectRect(u, r));
                });
              }(n);
            }), t("    reversePoints", function () {
              !function (n) {
                r.forEach(n.edges(), function (t) {
                  var e = n.edge(t);
                  e.reversed && e.points.reverse();
                });
              }(n);
            }), t("    acyclic.undo", function () {
              o.undo(n);
            });
          }(t, e);
        }), e("  updateInputGraph", function () {
          !function (n, t) {
            r.forEach(n.nodes(), function (e) {
              var r = n.node(e),
                  o = t.node(e);
              r && (r.x = o.x, r.y = o.y, t.children(e).length && (r.width = o.width, r.height = o.height));
            }), r.forEach(n.edges(), function (e) {
              var o = n.edge(e),
                  i = t.edge(e);
              o.points = i.points, r.has(i, "x") && (o.x = i.x, o.y = i.y);
            }), n.graph().width = t.graph().width, n.graph().height = t.graph().height;
          }(n, t);
        });
      });
    };

    var y = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"],
        b = {
      ranksep: 50,
      edgesep: 20,
      nodesep: 50,
      rankdir: "tb"
    },
        x = ["acyclicer", "ranker", "rankdir", "align"],
        m = ["width", "height"],
        w = {
      width: 0,
      height: 0
    },
        _ = ["minlen", "weight", "width", "height", "labeloffset"],
        E = {
      minlen: 1,
      weight: 1,
      width: 0,
      height: 0,
      labeloffset: 10,
      labelpos: "r"
    },
        j = ["labelpos"];

    function k(n, t) {
      return r.mapValues(r.pick(n, t), Number);
    }

    function O(n) {
      var t = {};
      return r.forEach(n, function (n, e) {
        t[e.toLowerCase()] = n;
      }), t;
    }
  }, function (n, t, e) {
    var r = e(18),
        o = e(114),
        i = e(193);

    n.exports = function (n, t) {
      var e,
          u = new o(),
          a = {},
          c = new i();

      function f(n) {
        var r = n.v === e ? n.w : n.v,
            o = c.priority(r);

        if (void 0 !== o) {
          var i = t(n);
          i < o && (a[r] = e, c.decrease(r, i));
        }
      }

      if (0 === n.nodeCount()) return u;
      r.each(n.nodes(), function (n) {
        c.add(n, Number.POSITIVE_INFINITY), u.setNode(n);
      }), c.decrease(n.nodes()[0], 0);
      var s = !1;

      for (; c.size() > 0;) {
        if (e = c.removeMin(), r.has(a, e)) u.setEdge(e, a[e]);else {
          if (s) throw new Error("Input graph is not connected: " + n);
          s = !0;
        }
        n.nodeEdges(e).forEach(f);
      }

      return u;
    };
  }, function (n, t, e) {
    var r = e(190);

    n.exports = function (n, t) {
      return r(n, t, "pre");
    };
  }, function (n, t, e) {
    var r = e(190);

    n.exports = function (n, t) {
      return r(n, t, "post");
    };
  }, function (n, t, e) {
    var r = e(191);

    n.exports = function (n) {
      try {
        r(n);
      } catch (n) {
        if (n instanceof r.CycleException) return !1;
        throw n;
      }

      return !0;
    };
  }, function (n, t, e) {
    var r = e(18);

    n.exports = function (n, t, e) {
      return function (n, t, e) {
        var r = {},
            o = n.nodes();
        return o.forEach(function (n) {
          r[n] = {}, r[n][n] = {
            distance: 0
          }, o.forEach(function (t) {
            n !== t && (r[n][t] = {
              distance: Number.POSITIVE_INFINITY
            });
          }), e(n).forEach(function (e) {
            var o = e.v === n ? e.w : e.v,
                i = t(e);
            r[n][o] = {
              distance: i,
              predecessor: n
            };
          });
        }), o.forEach(function (n) {
          var t = r[n];
          o.forEach(function (e) {
            var i = r[e];
            o.forEach(function (e) {
              var r = i[n],
                  o = t[e],
                  u = i[e],
                  a = r.distance + o.distance;
              a < u.distance && (u.distance = a, u.predecessor = o.predecessor);
            });
          });
        }), r;
      }(n, t || o, e || function (t) {
        return n.outEdges(t);
      });
    };

    var o = r.constant(1);
  }, function (n, t, e) {
    var r = e(18),
        o = e(192);

    n.exports = function (n) {
      return r.filter(o(n), function (t) {
        return t.length > 1 || 1 === t.length && n.hasEdge(t[0], t[0]);
      });
    };
  }, function (n, t, e) {
    var r = e(194),
        o = e(18);

    n.exports = function (n, t, e) {
      return o.transform(n.nodes(), function (o, i) {
        o[i] = r(n, i, t, e);
      }, {});
    };
  }, function (n, t, e) {
    var r = e(18);

    n.exports = function (n) {
      var t,
          e = {},
          o = [];

      function i(o) {
        r.has(e, o) || (e[o] = !0, t.push(o), r.each(n.successors(o), i), r.each(n.predecessors(o), i));
      }

      return r.each(n.nodes(), function (n) {
        t = [], i(n), t.length && o.push(t);
      }), o;
    };
  }, function (n, t, e) {
    n.exports = {
      components: e(481),
      dijkstra: e(194),
      dijkstraAll: e(480),
      findCycles: e(479),
      floydWarshall: e(478),
      isAcyclic: e(477),
      postorder: e(476),
      preorder: e(475),
      prim: e(474),
      tarjan: e(192),
      topsort: e(191)
    };
  }, function (n, t, e) {
    var r = e(18),
        o = e(114);
    n.exports = {
      write: function write(n) {
        var t = {
          options: {
            directed: n.isDirected(),
            multigraph: n.isMultigraph(),
            compound: n.isCompound()
          },
          nodes: function (n) {
            return r.map(n.nodes(), function (t) {
              var e = n.node(t),
                  o = n.parent(t),
                  i = {
                v: t
              };
              return r.isUndefined(e) || (i.value = e), r.isUndefined(o) || (i.parent = o), i;
            });
          }(n),
          edges: function (n) {
            return r.map(n.edges(), function (t) {
              var e = n.edge(t),
                  o = {
                v: t.v,
                w: t.w
              };
              return r.isUndefined(t.name) || (o.name = t.name), r.isUndefined(e) || (o.value = e), o;
            });
          }(n)
        };
        r.isUndefined(n.graph()) || (t.value = r.clone(n.graph()));
        return t;
      },
      read: function read(n) {
        var t = new o(n.options).setGraph(n.value);
        return r.each(n.nodes, function (n) {
          t.setNode(n.v, n.value), n.parent && t.setParent(n.v, n.parent);
        }), r.each(n.edges, function (n) {
          t.setEdge({
            v: n.v,
            w: n.w,
            name: n.name
          }, n.value);
        }), t;
      }
    };
  }, function (n, t) {
    n.exports = "2.1.7";
  }, function (n, t, e) {
    var r = e(70);

    n.exports = function (n, t) {
      return r(t, function (t) {
        return n[t];
      });
    };
  }, function (n, t) {
    n.exports = function () {};
  }, function (n, t, e) {
    var r = e(223),
        o = e(486),
        i = e(100),
        u = r && 1 / i(new r([, -0]))[1] == 1 / 0 ? function (n) {
      return new r(n);
    } : o;
    n.exports = u;
  }, function (n, t) {
    n.exports = function (n, t, e) {
      for (var r = -1, o = null == n ? 0 : n.length; ++r < o;) {
        if (e(t, n[r])) return !0;
      }

      return !1;
    };
  }, function (n, t) {
    n.exports = function (n, t, e) {
      for (var r = e - 1, o = n.length; ++r < o;) {
        if (n[r] === t) return r;
      }

      return -1;
    };
  }, function (n, t) {
    n.exports = function (n) {
      return n != n;
    };
  }, function (n, t, e) {
    var r = e(197),
        o = e(490),
        i = e(489);

    n.exports = function (n, t, e) {
      return t == t ? i(n, t, e) : r(n, o, e);
    };
  }, function (n, t, e) {
    var r = e(491);

    n.exports = function (n, t) {
      return !(null == n || !n.length) && r(n, t, 0) > -1;
    };
  }, function (n, t, e) {
    var r = e(212),
        o = e(492),
        i = e(488),
        u = e(211),
        a = e(487),
        c = e(100),
        f = 200;

    n.exports = function (n, t, e) {
      var s = -1,
          d = o,
          p = n.length,
          h = !0,
          v = [],
          l = v;
      if (e) h = !1, d = i;else if (p >= f) {
        var g = t ? null : a(n);
        if (g) return c(g);
        h = !1, d = u, l = new r();
      } else l = t ? [] : v;

      n: for (; ++s < p;) {
        var y = n[s],
            b = t ? t(y) : y;

        if (y = e || 0 !== y ? y : 0, h && b == b) {
          for (var x = l.length; x--;) {
            if (l[x] === b) continue n;
          }

          t && l.push(b), v.push(y);
        } else d(l, b, e) || (l !== v && l.push(b), v.push(y));
      }

      return v;
    };
  }, function (n, t) {
    var e = 800,
        r = 16,
        o = Date.now;

    n.exports = function (n) {
      var t = 0,
          i = 0;
      return function () {
        var u = o(),
            a = r - (u - i);

        if (i = u, a > 0) {
          if (++t >= e) return arguments[0];
        } else t = 0;

        return n.apply(void 0, arguments);
      };
    };
  }, function (n, t, e) {
    var r = e(103),
        o = e(233),
        i = e(36),
        u = o ? function (n, t) {
      return o(n, "toString", {
        configurable: !0,
        enumerable: !1,
        value: r(t),
        writable: !0
      });
    } : i;
    n.exports = u;
  }, function (n, t) {
    n.exports = function (n, t, e) {
      switch (e.length) {
        case 0:
          return n.call(t);

        case 1:
          return n.call(t, e[0]);

        case 2:
          return n.call(t, e[0], e[1]);

        case 3:
          return n.call(t, e[0], e[1], e[2]);
      }

      return n.apply(t, e);
    };
  }, function (n, t, e) {
    var r = e(38),
        o = e(55),
        i = e(11),
        u = r ? r.isConcatSpreadable : void 0;

    n.exports = function (n) {
      return i(n) || o(n) || !!(u && n && n[u]);
    };
  }, function (n, t, e) {
    var r = e(97),
        o = e(69),
        i = e(493),
        u = e(196),
        a = o(function (n) {
      return i(r(n, 1, u, !0));
    });
    n.exports = a;
  }, function (n, t, e) {
    var r = e(111),
        o = e(219),
        i = e(102),
        u = e(28),
        a = e(73),
        c = e(11),
        f = e(42),
        s = e(57),
        d = e(16),
        p = e(54);

    n.exports = function (n, t, e) {
      var h = c(n),
          v = h || f(n) || p(n);

      if (t = u(t, 4), null == e) {
        var l = n && n.constructor;
        e = v ? h ? new l() : [] : d(n) && s(l) ? o(a(n)) : {};
      }

      return (v ? r : i)(n, function (n, r, o) {
        return t(e, n, r, o);
      }), e;
    };
  }, function (n, t) {
    var e = "[\\ud800-\\udfff]",
        r = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",
        o = "\\ud83c[\\udffb-\\udfff]",
        i = "[^\\ud800-\\udfff]",
        u = "(?:\\ud83c[\\udde6-\\uddff]){2}",
        a = "[\\ud800-\\udbff][\\udc00-\\udfff]",
        c = "(?:" + r + "|" + o + ")" + "?",
        f = "[\\ufe0e\\ufe0f]?" + c + ("(?:\\u200d(?:" + [i, u, a].join("|") + ")[\\ufe0e\\ufe0f]?" + c + ")*"),
        s = "(?:" + [i + r + "?", r, u, a, e].join("|") + ")",
        d = RegExp(o + "(?=" + o + ")|" + s + f, "g");

    n.exports = function (n) {
      for (var t = d.lastIndex = 0; d.test(n);) {
        ++t;
      }

      return t;
    };
  }, function (n, t) {
    var e = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");

    n.exports = function (n) {
      return e.test(n);
    };
  }, function (n, t, e) {
    var r = e(205)("length");
    n.exports = r;
  }, function (n, t, e) {
    var r = e(502),
        o = e(501),
        i = e(500);

    n.exports = function (n) {
      return o(n) ? i(n) : r(n);
    };
  }, function (n, t, e) {
    var r = e(34),
        o = e(11),
        i = e(23),
        u = "[object String]";

    n.exports = function (n) {
      return "string" == typeof n || !o(n) && i(n) && r(n) == u;
    };
  }, function (n, t, e) {
    var r = e(107),
        o = e(40),
        i = e(29),
        u = e(504),
        a = e(503),
        c = "[object Map]",
        f = "[object Set]";

    n.exports = function (n) {
      if (null == n) return 0;
      if (i(n)) return u(n) ? a(n) : n.length;
      var t = o(n);
      return t == c || t == f ? n.size : r(n).length;
    };
  }, function (n, t) {
    n.exports = function (n, t, e, r, o) {
      return o(n, function (n, o, i) {
        e = r ? (r = !1, n) : t(e, n, o, i);
      }), e;
    };
  }, function (n, t) {
    n.exports = function (n, t, e, r) {
      var o = -1,
          i = null == n ? 0 : n.length;

      for (r && i && (e = n[++o]); ++o < i;) {
        e = t(e, n[o], o, n);
      }

      return e;
    };
  }, function (n, t, e) {
    var r = e(107),
        o = e(40),
        i = e(55),
        u = e(11),
        a = e(29),
        c = e(42),
        f = e(74),
        s = e(54),
        d = "[object Map]",
        p = "[object Set]",
        h = Object.prototype.hasOwnProperty;

    n.exports = function (n) {
      if (null == n) return !0;
      if (a(n) && (u(n) || "string" == typeof n || "function" == typeof n.splice || c(n) || s(n) || i(n))) return !n.length;
      var t = o(n);
      if (t == d || t == p) return !n.size;
      if (f(n)) return !r(n).length;

      for (var e in n) {
        if (h.call(n, e)) return !1;
      }

      return !0;
    };
  }, function (n, t) {
    var e = Object.prototype.hasOwnProperty;

    n.exports = function (n, t) {
      return null != n && e.call(n, t);
    };
  }, function (n, t, e) {
    var r = e(99);

    n.exports = function (n) {
      return function (t) {
        return r(t, n);
      };
    };
  }, function (n, t, e) {
    var r = e(205),
        o = e(510),
        i = e(98),
        u = e(53);

    n.exports = function (n) {
      return i(n) ? r(u(n)) : o(n);
    };
  }, function (n, t) {
    n.exports = function (n, t) {
      return null != n && t in Object(n);
    };
  }, function (n, t, e) {
    var r = e(38),
        o = e(70),
        i = e(11),
        u = e(39),
        a = 1 / 0,
        c = r ? r.prototype : void 0,
        f = c ? c.toString : void 0;

    n.exports = function n(t) {
      if ("string" == typeof t) return t;
      if (i(t)) return o(t, n) + "";
      if (u(t)) return f ? f.call(t) : "";
      var e = t + "";
      return "0" == e && 1 / t == -a ? "-0" : e;
    };
  }, function (n, t, e) {
    var r = e(112),
        o = "Expected a function";

    function i(n, t) {
      if ("function" != typeof n || null != t && "function" != typeof t) throw new TypeError(o);

      var e = function e() {
        var r = arguments,
            o = t ? t.apply(this, r) : r[0],
            i = e.cache;
        if (i.has(o)) return i.get(o);
        var u = n.apply(this, r);
        return e.cache = i.set(o, u) || i, u;
      };

      return e.cache = new (i.Cache || r)(), e;
    }

    i.Cache = r, n.exports = i;
  }, function (n, t, e) {
    var r = e(514),
        o = 500;

    n.exports = function (n) {
      var t = r(n, function (n) {
        return e.size === o && e.clear(), n;
      }),
          e = t.cache;
      return t;
    };
  }, function (n, t, e) {
    var r = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
        o = /\\(\\)?/g,
        i = e(515)(function (n) {
      var t = [];
      return 46 === n.charCodeAt(0) && t.push(""), n.replace(r, function (n, e, r, i) {
        t.push(r ? i.replace(o, "$1") : e || n);
      }), t;
    });
    n.exports = i;
  }, function (n, t, e) {
    var r = e(99);

    n.exports = function (n, t, e) {
      var o = null == n ? void 0 : r(n, t);
      return void 0 === o ? e : o;
    };
  }, function (n, t, e) {
    var r = e(214),
        o = e(517),
        i = e(207),
        u = e(98),
        a = e(210),
        c = e(209),
        f = e(53),
        s = 1,
        d = 2;

    n.exports = function (n, t) {
      return u(n) && a(t) ? c(f(n), t) : function (e) {
        var u = o(e, n);
        return void 0 === u && u === t ? i(e, n) : r(t, u, s | d);
      };
    };
  }, function (n, t, e) {
    var r = e(210),
        o = e(33);

    n.exports = function (n) {
      for (var t = o(n), e = t.length; e--;) {
        var i = t[e],
            u = n[i];
        t[e] = [i, u, r(u)];
      }

      return t;
    };
  }, function (n, t, e) {
    var r = e(225),
        o = 1,
        i = Object.prototype.hasOwnProperty;

    n.exports = function (n, t, e, u, a, c) {
      var f = e & o,
          s = r(n),
          d = s.length;
      if (d != r(t).length && !f) return !1;

      for (var p = d; p--;) {
        var h = s[p];
        if (!(f ? h in t : i.call(t, h))) return !1;
      }

      var v = c.get(n);
      if (v && c.get(t)) return v == t;
      var l = !0;
      c.set(n, t), c.set(t, n);

      for (var g = f; ++p < d;) {
        var y = n[h = s[p]],
            b = t[h];
        if (u) var x = f ? u(b, y, h, t, n, c) : u(y, b, h, n, t, c);

        if (!(void 0 === x ? y === b || a(y, b, e, u, c) : x)) {
          l = !1;
          break;
        }

        g || (g = "constructor" == h);
      }

      if (l && !g) {
        var m = n.constructor,
            w = t.constructor;
        m != w && "constructor" in n && "constructor" in t && !("function" == typeof m && m instanceof m && "function" == typeof w && w instanceof w) && (l = !1);
      }

      return c.delete(n), c.delete(t), l;
    };
  }, function (n, t) {
    n.exports = function (n) {
      var t = -1,
          e = Array(n.size);
      return n.forEach(function (n, r) {
        e[++t] = [r, n];
      }), e;
    };
  }, function (n, t, e) {
    var r = e(38),
        o = e(222),
        i = e(43),
        u = e(213),
        a = e(521),
        c = e(100),
        f = 1,
        s = 2,
        d = "[object Boolean]",
        p = "[object Date]",
        h = "[object Error]",
        v = "[object Map]",
        l = "[object Number]",
        g = "[object RegExp]",
        y = "[object Set]",
        b = "[object String]",
        x = "[object Symbol]",
        m = "[object ArrayBuffer]",
        w = "[object DataView]",
        _ = r ? r.prototype : void 0,
        E = _ ? _.valueOf : void 0;

    n.exports = function (n, t, e, r, _, j, k) {
      switch (e) {
        case w:
          if (n.byteLength != t.byteLength || n.byteOffset != t.byteOffset) return !1;
          n = n.buffer, t = t.buffer;

        case m:
          return !(n.byteLength != t.byteLength || !j(new o(n), new o(t)));

        case d:
        case p:
        case l:
          return i(+n, +t);

        case h:
          return n.name == t.name && n.message == t.message;

        case g:
        case b:
          return n == t + "";

        case v:
          var O = a;

        case y:
          var N = r & f;
          if (O || (O = c), n.size != t.size && !N) return !1;
          var I = k.get(n);
          if (I) return I == t;
          r |= s, k.set(n, t);
          var C = u(O(n), O(t), r, _, j, k);
          return k.delete(n), C;

        case x:
          if (E) return E.call(n) == E.call(t);
      }

      return !1;
    };
  }, function (n, t) {
    n.exports = function (n, t) {
      for (var e = -1, r = null == n ? 0 : n.length; ++e < r;) {
        if (t(n[e], e, n)) return !0;
      }

      return !1;
    };
  }, function (n, t) {
    n.exports = function (n) {
      return this.__data__.has(n);
    };
  }, function (n, t) {
    var e = "__lodash_hash_undefined__";

    n.exports = function (n) {
      return this.__data__.set(n, e), this;
    };
  }, function (n, t, e) {
    var r = e(83),
        o = e(213),
        i = e(522),
        u = e(520),
        a = e(40),
        c = e(11),
        f = e(42),
        s = e(54),
        d = 1,
        p = "[object Arguments]",
        h = "[object Array]",
        v = "[object Object]",
        l = Object.prototype.hasOwnProperty;

    n.exports = function (n, t, e, g, y, b) {
      var x = c(n),
          m = c(t),
          w = x ? h : a(n),
          _ = m ? h : a(t),
          E = (w = w == p ? v : w) == v,
          j = (_ = _ == p ? v : _) == v,
          k = w == _;

      if (k && f(n)) {
        if (!f(t)) return !1;
        x = !0, E = !1;
      }

      if (k && !E) return b || (b = new r()), x || s(n) ? o(n, t, e, g, y, b) : i(n, t, w, e, g, y, b);

      if (!(e & d)) {
        var O = E && l.call(n, "__wrapped__"),
            N = j && l.call(t, "__wrapped__");

        if (O || N) {
          var I = O ? n.value() : n,
              C = N ? t.value() : t;
          return b || (b = new r()), y(I, C, e, g, b);
        }
      }

      return !!k && (b || (b = new r()), u(n, t, e, g, y, b));
    };
  }, function (n, t, e) {
    var r = e(83),
        o = e(214),
        i = 1,
        u = 2;

    n.exports = function (n, t, e, a) {
      var c = e.length,
          f = c,
          s = !a;
      if (null == n) return !f;

      for (n = Object(n); c--;) {
        var d = e[c];
        if (s && d[2] ? d[1] !== n[d[0]] : !(d[0] in n)) return !1;
      }

      for (; ++c < f;) {
        var p = (d = e[c])[0],
            h = n[p],
            v = d[1];

        if (s && d[2]) {
          if (void 0 === h && !(p in n)) return !1;
        } else {
          var l = new r();
          if (a) var g = a(h, v, p, n, t, l);
          if (!(void 0 === g ? o(v, h, i | u, a, l) : g)) return !1;
        }
      }

      return !0;
    };
  }, function (n, t, e) {
    var r = e(527),
        o = e(519),
        i = e(209);

    n.exports = function (n) {
      var t = o(n);
      return 1 == t.length && t[0][2] ? i(t[0][0], t[0][1]) : function (e) {
        return e === n || r(e, n, t);
      };
    };
  }, function (n, t, e) {
    var r = e(72);

    n.exports = function (n, t) {
      var e = [];
      return r(n, function (n, r, o) {
        t(n, r, o) && e.push(n);
      }), e;
    };
  }, function (n, t, e) {
    var r = e(29);

    n.exports = function (n, t) {
      return function (e, o) {
        if (null == e) return e;
        if (!r(e)) return n(e, o);

        for (var i = e.length, u = t ? i : -1, a = Object(e); (t ? u-- : ++u < i) && !1 !== o(a[u], u, a);) {
          ;
        }

        return e;
      };
    };
  }, function (n, t) {
    n.exports = function (n) {
      return function (t, e, r) {
        for (var o = -1, i = Object(t), u = r(t), a = u.length; a--;) {
          var c = u[n ? a : ++o];
          if (!1 === e(i[c], c, i)) break;
        }

        return t;
      };
    };
  }, function (n, t, e) {
    var r = e(40),
        o = e(23),
        i = "[object Set]";

    n.exports = function (n) {
      return o(n) && r(n) == i;
    };
  }, function (n, t, e) {
    var r = e(532),
        o = e(75),
        i = e(108),
        u = i && i.isSet,
        a = u ? o(u) : r;
    n.exports = a;
  }, function (n, t, e) {
    var r = e(40),
        o = e(23),
        i = "[object Map]";

    n.exports = function (n) {
      return o(n) && r(n) == i;
    };
  }, function (n, t, e) {
    var r = e(534),
        o = e(75),
        i = e(108),
        u = i && i.isMap,
        a = u ? o(u) : r;
    n.exports = a;
  }, function (n, t, e) {
    var r = e(38),
        o = r ? r.prototype : void 0,
        i = o ? o.valueOf : void 0;

    n.exports = function (n) {
      return i ? Object(i.call(n)) : {};
    };
  }, function (n, t) {
    var e = /\w*$/;

    n.exports = function (n) {
      var t = new n.constructor(n.source, e.exec(n));
      return t.lastIndex = n.lastIndex, t;
    };
  }, function (n, t, e) {
    var r = e(104);

    n.exports = function (n, t) {
      var e = t ? r(n.buffer) : n.buffer;
      return new n.constructor(e, n.byteOffset, n.byteLength);
    };
  }, function (n, t, e) {
    var r = e(104),
        o = e(538),
        i = e(537),
        u = e(536),
        a = e(221),
        c = "[object Boolean]",
        f = "[object Date]",
        s = "[object Map]",
        d = "[object Number]",
        p = "[object RegExp]",
        h = "[object Set]",
        v = "[object String]",
        l = "[object Symbol]",
        g = "[object ArrayBuffer]",
        y = "[object DataView]",
        b = "[object Float32Array]",
        x = "[object Float64Array]",
        m = "[object Int8Array]",
        w = "[object Int16Array]",
        _ = "[object Int32Array]",
        E = "[object Uint8Array]",
        j = "[object Uint8ClampedArray]",
        k = "[object Uint16Array]",
        O = "[object Uint32Array]";

    n.exports = function (n, t, e) {
      var N = n.constructor;

      switch (t) {
        case g:
          return r(n);

        case c:
        case f:
          return new N(+n);

        case y:
          return o(n, e);

        case b:
        case x:
        case m:
        case w:
        case _:
        case E:
        case j:
        case k:
        case O:
          return a(n, e);

        case s:
          return new N();

        case d:
        case v:
          return new N(n);

        case p:
          return i(n);

        case h:
          return new N();

        case l:
          return u(n);
      }
    };
  }, function (n, t) {
    var e = Object.prototype.hasOwnProperty;

    n.exports = function (n) {
      var t = n.length,
          r = new n.constructor(t);
      return t && "string" == typeof n[0] && e.call(n, "index") && (r.index = n.index, r.input = n.input), r;
    };
  }, function (n, t, e) {
    var r = e(37)(e(20), "WeakMap");
    n.exports = r;
  }, function (n, t, e) {
    var r = e(37)(e(20), "Promise");
    n.exports = r;
  }, function (n, t, e) {
    var r = e(37)(e(20), "DataView");
    n.exports = r;
  }, function (n, t, e) {
    var r = e(224),
        o = e(226),
        i = e(41);

    n.exports = function (n) {
      return r(n, i, o);
    };
  }, function (n, t, e) {
    var r = e(56),
        o = e(226);

    n.exports = function (n, t) {
      return r(n, o(n), t);
    };
  }, function (n, t, e) {
    var r = e(56),
        o = e(106);

    n.exports = function (n, t) {
      return r(n, o(n), t);
    };
  }, function (n, t) {
    n.exports = function (n) {
      var t = [];
      if (null != n) for (var e in Object(n)) {
        t.push(e);
      }
      return t;
    };
  }, function (n, t, e) {
    var r = e(16),
        o = e(74),
        i = e(547),
        u = Object.prototype.hasOwnProperty;

    n.exports = function (n) {
      if (!r(n)) return i(n);
      var t = o(n),
          e = [];

      for (var a in n) {
        ("constructor" != a || !t && u.call(n, a)) && e.push(a);
      }

      return e;
    };
  }, function (n, t, e) {
    var r = e(56),
        o = e(41);

    n.exports = function (n, t) {
      return n && r(t, o(t), n);
    };
  }, function (n, t, e) {
    var r = e(231)(Object.keys, Object);
    n.exports = r;
  }, function (n, t, e) {
    var r = e(34),
        o = e(109),
        i = e(23),
        u = {};
    u["[object Float32Array]"] = u["[object Float64Array]"] = u["[object Int8Array]"] = u["[object Int16Array]"] = u["[object Int32Array]"] = u["[object Uint8Array]"] = u["[object Uint8ClampedArray]"] = u["[object Uint16Array]"] = u["[object Uint32Array]"] = !0, u["[object Arguments]"] = u["[object Array]"] = u["[object ArrayBuffer]"] = u["[object Boolean]"] = u["[object DataView]"] = u["[object Date]"] = u["[object Error]"] = u["[object Function]"] = u["[object Map]"] = u["[object Number]"] = u["[object Object]"] = u["[object RegExp]"] = u["[object Set]"] = u["[object String]"] = u["[object WeakMap]"] = !1, n.exports = function (n) {
      return i(n) && o(n.length) && !!u[r(n)];
    };
  }, function (n, t) {
    n.exports = function () {
      return !1;
    };
  }, function (n, t, e) {
    var r = e(34),
        o = e(23),
        i = "[object Arguments]";

    n.exports = function (n) {
      return o(n) && r(n) == i;
    };
  }, function (n, t) {
    n.exports = function (n, t) {
      for (var e = -1, r = Array(n); ++e < n;) {
        r[e] = t(e);
      }

      return r;
    };
  }, function (n, t, e) {
    var r = e(56),
        o = e(33);

    n.exports = function (n, t) {
      return n && r(t, o(t), n);
    };
  }, function (n, t, e) {
    var r = e(79);

    n.exports = function (n, t) {
      var e = r(this, n),
          o = e.size;
      return e.set(n, t), this.size += e.size == o ? 0 : 1, this;
    };
  }, function (n, t, e) {
    var r = e(79);

    n.exports = function (n) {
      return r(this, n).has(n);
    };
  }, function (n, t, e) {
    var r = e(79);

    n.exports = function (n) {
      return r(this, n).get(n);
    };
  }, function (n, t) {
    n.exports = function (n) {
      var t = _typeof(n);

      return "string" == t || "number" == t || "symbol" == t || "boolean" == t ? "__proto__" !== n : null === n;
    };
  }, function (n, t, e) {
    var r = e(79);

    n.exports = function (n) {
      var t = r(this, n).delete(n);
      return this.size -= t ? 1 : 0, t;
    };
  }, function (n, t, e) {
    var r = e(80),
        o = "__lodash_hash_undefined__";

    n.exports = function (n, t) {
      var e = this.__data__;
      return this.size += this.has(n) ? 0 : 1, e[n] = r && void 0 === t ? o : t, this;
    };
  }, function (n, t, e) {
    var r = e(80),
        o = Object.prototype.hasOwnProperty;

    n.exports = function (n) {
      var t = this.__data__;
      return r ? void 0 !== t[n] : o.call(t, n);
    };
  }, function (n, t, e) {
    var r = e(80),
        o = "__lodash_hash_undefined__",
        i = Object.prototype.hasOwnProperty;

    n.exports = function (n) {
      var t = this.__data__;

      if (r) {
        var e = t[n];
        return e === o ? void 0 : e;
      }

      return i.call(t, n) ? t[n] : void 0;
    };
  }, function (n, t) {
    n.exports = function (n) {
      var t = this.has(n) && delete this.__data__[n];
      return this.size -= t ? 1 : 0, t;
    };
  }, function (n, t, e) {
    var r = e(80);

    n.exports = function () {
      this.__data__ = r ? r(null) : {}, this.size = 0;
    };
  }, function (n, t, e) {
    var r = e(565),
        o = e(564),
        i = e(563),
        u = e(562),
        a = e(561);

    function c(n) {
      var t = -1,
          e = null == n ? 0 : n.length;

      for (this.clear(); ++t < e;) {
        var r = n[t];
        this.set(r[0], r[1]);
      }
    }

    c.prototype.clear = r, c.prototype.delete = o, c.prototype.get = i, c.prototype.has = u, c.prototype.set = a, n.exports = c;
  }, function (n, t, e) {
    var r = e(566),
        o = e(82),
        i = e(113);

    n.exports = function () {
      this.size = 0, this.__data__ = {
        hash: new r(),
        map: new (i || o)(),
        string: new r()
      };
    };
  }, function (n, t) {
    n.exports = function (n, t) {
      return null == n ? void 0 : n[t];
    };
  }, function (n, t, e) {
    var r = e(20)["__core-js_shared__"];
    n.exports = r;
  }, function (n, t, e) {
    var r = e(569),
        o = function () {
      var n = /[^.]+$/.exec(r && r.keys && r.keys.IE_PROTO || "");
      return n ? "Symbol(src)_1." + n : "";
    }();

    n.exports = function (n) {
      return !!o && o in n;
    };
  }, function (n, t, e) {
    var r = e(57),
        o = e(570),
        i = e(16),
        u = e(234),
        a = /^\[object .+?Constructor\]$/,
        c = Function.prototype,
        f = Object.prototype,
        s = c.toString,
        d = f.hasOwnProperty,
        p = RegExp("^" + s.call(d).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

    n.exports = function (n) {
      return !(!i(n) || o(n)) && (r(n) ? p : a).test(u(n));
    };
  }, function (n, t, e) {
    var r = e(82),
        o = e(113),
        i = e(112),
        u = 200;

    n.exports = function (n, t) {
      var e = this.__data__;

      if (e instanceof r) {
        var a = e.__data__;
        if (!o || a.length < u - 1) return a.push([n, t]), this.size = ++e.size, this;
        e = this.__data__ = new i(a);
      }

      return e.set(n, t), this.size = e.size, this;
    };
  }, function (n, t) {
    n.exports = function (n) {
      return this.__data__.has(n);
    };
  }, function (n, t) {
    n.exports = function (n) {
      return this.__data__.get(n);
    };
  }, function (n, t) {
    n.exports = function (n) {
      var t = this.__data__,
          e = t.delete(n);
      return this.size = t.size, e;
    };
  }, function (n, t, e) {
    var r = e(82);

    n.exports = function () {
      this.__data__ = new r(), this.size = 0;
    };
  }, function (n, t, e) {
    var r = e(81);

    n.exports = function (n, t) {
      var e = this.__data__,
          o = r(e, n);
      return o < 0 ? (++this.size, e.push([n, t])) : e[o][1] = t, this;
    };
  }, function (n, t, e) {
    var r = e(81);

    n.exports = function (n) {
      return r(this.__data__, n) > -1;
    };
  }, function (n, t, e) {
    var r = e(81);

    n.exports = function (n) {
      var t = this.__data__,
          e = r(t, n);
      return e < 0 ? void 0 : t[e][1];
    };
  }, function (n, t, e) {
    var r = e(81),
        o = Array.prototype.splice;

    n.exports = function (n) {
      var t = this.__data__,
          e = r(t, n);
      return !(e < 0 || (e == t.length - 1 ? t.pop() : o.call(t, e, 1), --this.size, 0));
    };
  }, function (n, t) {
    n.exports = function () {
      this.__data__ = [], this.size = 0;
    };
  }, function (n, t, e) {
    var r = e(235),
        o = 4;

    n.exports = function (n) {
      return r(n, o);
    };
  }, function (n, t, e) {
    n.exports = {
      Graph: e(114),
      version: e(484)
    };
  }, function (n, t, e) {
    var r = e(583);
    n.exports = {
      Graph: r.Graph,
      json: e(483),
      alg: e(482),
      version: r.version
    };
  }, function (n, t, e) {
    n.exports = {
      graphlib: e(22),
      layout: e(473),
      debug: e(416),
      util: {
        time: e(15).time,
        notime: e(15).notime
      },
      version: e(415)
    };
  }, function (n, t, e) {
    var r = e(3),
        o = e(585),
        i = r.Util,
        u = function () {
      function n(n) {
        i.mix(this, {
          rankdir: "TB",
          align: void 0,
          nodesep: 50,
          edgesep: 10,
          ranksep: 50,
          marginx: 0,
          marginy: 0,
          acyclicer: void 0,
          useEdgeControlPoint: !0,
          ranker: "network-simplex",
          callback: null
        }, n);
      }

      var t = n.prototype;
      return t.getValue = function (n) {
        var t = this[n];
        return i.isFunction(t) ? t() : t;
      }, t.execute = function () {
        var n = this.nodes,
            t = this.edges,
            e = {},
            r = new o.graphlib.Graph(),
            i = this.useEdgeControlPoint;
        r.setGraph({
          rankdir: this.getValue("rankdir"),
          align: this.getValue("align"),
          nodesep: this.getValue("nodesep"),
          edgesep: this.getValue("edgesep"),
          ranksep: this.getValue("ranksep"),
          marginx: this.getValue("marginx"),
          marginy: this.getValue("marginy"),
          acyclicer: this.getValue("acyclicer"),
          ranker: this.getValue("ranker")
        }), r.setDefaultEdgeLabel(function () {
          return {};
        }), n.forEach(function (n) {
          r.setNode(n.id, {
            width: n.width,
            height: n.height
          }), e[n.id] = n;
        }), t.forEach(function (n) {
          r.setEdge(n.source, n.target);
        }), o.layout(r), r.nodes().forEach(function (n) {
          var t = r.node(n);
          e[n].x = t.x, e[n].y = t.y;
        }), r.edges().forEach(function (n, e) {
          var o = r.edge(n);
          i && (t[e].controlPoints = o.points.slice(1, o.points.length - 1));
        });
      }, n;
    }();

    n.exports = u;
  }, function (n, t, e) {
    var r = e(3),
        o = e(586);
    r.Layouts.Dagre = o;

    var i = function () {
      function n(n) {
        this.options = n;
      }

      return n.prototype.init = function () {
        var n = this,
            t = this.graph;
        t.on("beforeinit", function () {
          var e = new o(n.options);
          t.set("layout", e);
        });
      }, n;
    }();

    r.Plugins["layout.dagre"] = i, n.exports = i;
  }]);
});
},{"@antv/g6":"../node_modules/@antv/g6/build/g6.js"}],"../node_modules/@antv/g6/build/plugin.behaviour.analysis.js":[function(require,module,exports) {
var define;
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

!function (e, n) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = n(require("@antv/g6")) : "function" == typeof define && define.amd ? define(["@antv/g6"], n) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports["plugin.behaviour.analysis"] = n(require("@antv/g6")) : e["plugin.behaviour.analysis"] = n(e.G6);
}(window, function (e) {
  return function (e) {
    var n = {};

    function t(o) {
      if (n[o]) return n[o].exports;
      var r = n[o] = {
        i: o,
        l: !1,
        exports: {}
      };
      return e[o].call(r.exports, r, r.exports, t), r.l = !0, r.exports;
    }

    return t.m = e, t.c = n, t.d = function (e, n, o) {
      t.o(e, n) || Object.defineProperty(e, n, {
        enumerable: !0,
        get: o
      });
    }, t.r = function (e) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(e, "__esModule", {
        value: !0
      });
    }, t.t = function (e, n) {
      if (1 & n && (e = t(e)), 8 & n) return e;
      if (4 & n && "object" == _typeof(e) && e && e.__esModule) return e;
      var o = Object.create(null);
      if (t.r(o), Object.defineProperty(o, "default", {
        enumerable: !0,
        value: e
      }), 2 & n && "string" != typeof e) for (var r in e) {
        t.d(o, r, function (n) {
          return e[n];
        }.bind(null, r));
      }
      return o;
    }, t.n = function (e) {
      var n = e && e.__esModule ? function () {
        return e.default;
      } : function () {
        return e;
      };
      return t.d(n, "a", n), n;
    }, t.o = function (e, n) {
      return Object.prototype.hasOwnProperty.call(e, n);
    }, t.p = "", t(t.s = 127);
  }({
    127: function _(e, n, t) {
      var o = t(3),
          r = o.Util;

      function u(e, n, t) {
        var o;

        function r() {
          o = void 0, e.css({
            cursor: "-webkit-grab"
          }), e.setCapture(!0);
        }

        void 0 === n && (n = "left"), void 0 === t && (t = !1), "right" === n && e.behaviourOn("contextmenu", function (e) {
          e.domEvent.preventDefault();
        }), e.behaviourOn("mousedown", function (e) {
          ("left" === n && 0 === e.domEvent.button || "right" === n && 2 === e.domEvent.button) && (t && e.shape || (o = {
            x: e.domX,
            y: e.domY
          }));
        }), e.behaviourOn("canvas:mouseenter", function () {
          e.css({
            cursor: "-webkit-grab"
          });
        }), e.behaviourOn("dragstart", function () {
          o && (e.setCapture(!1), e.css({
            cursor: "-webkit-grabbing"
          }));
        }), e.behaviourOn("drag", function (n) {
          o && (e.translate(n.domX - o.x, n.domY - o.y), o = {
            x: n.domX,
            y: n.domY
          });
        }), e.behaviourOn("dragend", function () {
          r();
        }), e.behaviourOn("canvas:mouseleave", function () {
          r();
        });
      }

      o.registerBehaviour("panCanvas", u), o.registerBehaviour("rightPanCanvas", function (e) {
        u(e, "right");
      }), o.registerBehaviour("panBlank", function (e) {
        u(e, "left", !0);
      }), o.registerBehaviour("rightPanBlank", function (e) {
        u(e, "right", !0);
      }), o.registerBehaviour("panNode", function (e) {
        var n, t, o;
        e.behaviourOn("node:mouseenter", function () {
          e.css({
            cursor: "move"
          });
        }), e.behaviourOn("node:mouseleave", function () {
          e.css({
            cursor: "default"
          });
        }), e.behaviourOn("node:dragstart", function (r) {
          var u = r.item,
              i = r.x,
              a = r.y;
          e.css({
            cursor: "move"
          });
          var c = u.getModel();
          n = u, t = c.x - i, o = c.y - a;
        }), e.behaviourOn("node:drag", function (r) {
          e.preventAnimate(function () {
            e.update(n, {
              x: r.x + t,
              y: r.y + o
            });
          });
        }), e.behaviourOn("node:dragend", function () {
          n = void 0;
        }), e.behaviourOn("canvas:mouseleave", function () {
          n = void 0;
        });
      }), o.registerBehaviour("wheelZoom", function (e) {
        var n;
        e.behaviourOn("wheel", function (e) {
          e.domEvent.preventDefault();
        }), e.behaviourOn("wheel", r.throttle(function (t) {
          var o = t.domEvent.wheelDelta;

          if (Math.abs(o) > 10) {
            var r = e.getMatrix()[0];
            o > 0 ? e.zoom({
              x: t.x,
              y: t.y
            }, 1.05 * r) : e.zoom({
              x: t.x,
              y: t.y
            }, r * (1 / 1.05));
          }

          n && clearTimeout(n), n = setTimeout(function () {
            n = void 0;
          }, 50);
        }, 16));
      }), e.exports = !0;
    },
    3: function _(n, t) {
      n.exports = e;
    }
  });
});
},{"@antv/g6":"../node_modules/@antv/g6/build/g6.js"}],"../node_modules/@antv/g6/build/plugin.edge.polyline.js":[function(require,module,exports) {
var define;
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

!function (n, t) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = t(require("@antv/g6")) : "function" == typeof define && define.amd ? define(["@antv/g6"], t) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports["plugin.edge.polyline"] = t(require("@antv/g6")) : n["plugin.edge.polyline"] = t(n.G6);
}(window, function (n) {
  return function (n) {
    var t = {};

    function e(r) {
      if (t[r]) return t[r].exports;
      var i = t[r] = {
        i: r,
        l: !1,
        exports: {}
      };
      return n[r].call(i.exports, i, i.exports, e), i.l = !0, i.exports;
    }

    return e.m = n, e.c = t, e.d = function (n, t, r) {
      e.o(n, t) || Object.defineProperty(n, t, {
        enumerable: !0,
        get: r
      });
    }, e.r = function (n) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(n, "__esModule", {
        value: !0
      });
    }, e.t = function (n, t) {
      if (1 & t && (n = e(n)), 8 & t) return n;
      if (4 & t && "object" == _typeof(n) && n && n.__esModule) return n;
      var r = Object.create(null);
      if (e.r(r), Object.defineProperty(r, "default", {
        enumerable: !0,
        value: n
      }), 2 & t && "string" != typeof n) for (var i in n) {
        e.d(r, i, function (t) {
          return n[t];
        }.bind(null, i));
      }
      return r;
    }, e.n = function (n) {
      var t = n && n.__esModule ? function () {
        return n.default;
      } : function () {
        return n;
      };
      return e.d(t, "a", t), t;
    }, e.o = function (n, t) {
      return Object.prototype.hasOwnProperty.call(n, t);
    }, e.p = "", e(e.s = 592);
  }({
    3: function _(t, e) {
      t.exports = n;
    },
    592: function _(n, t, e) {
      var r = e(3),
          i = r.Util;

      function o(n, t) {
        var e = Math.min(n.minX, t.minX),
            r = Math.min(n.minY, t.minY),
            i = Math.max(n.maxX, t.maxX),
            o = Math.max(n.maxY, t.maxY);
        return {
          centerX: (e + i) / 2,
          centerY: (r + o) / 2,
          minX: e,
          minY: r,
          maxX: i,
          maxY: o,
          height: o - r,
          width: i - e
        };
      }

      function u(n, t) {
        return 2 * Math.abs(n.centerX - t.centerX) < n.width + t.width && 2 * Math.abs(n.centerY - t.centerY) < n.height + t.height;
      }

      function a(n) {
        var t = n.x,
            e = n.y;
        return {
          centerX: t,
          centerY: e,
          minX: t,
          minY: e,
          maxX: t,
          maxY: e,
          height: 0,
          width: 0
        };
      }

      function f(n, t) {
        return 0 === n.width && 0 === n.height ? n : {
          centerX: n.centerX,
          centerY: n.centerY,
          minX: n.minX - t,
          minY: n.minY - t,
          maxX: n.maxX + t,
          maxY: n.maxY + t,
          height: n.height + 2 * t,
          width: n.width + 2 * t
        };
      }

      function c(n, t) {
        return function (n, t) {
          var e = Math.abs(n.x - t.centerX),
              r = Math.abs(n.y - t.centerY);
          return e / t.width > r / t.height;
        }(t, n) ? {
          x: t.x > n.centerX ? n.maxX : n.minX,
          y: t.y
        } : {
          x: t.x,
          y: t.y > n.centerY ? n.maxY : n.minY
        };
      }

      function x(n) {
        var t = n.minX,
            e = n.minY,
            r = n.maxX,
            i = n.maxY;
        return [{
          x: t,
          y: e
        }, {
          x: r,
          y: e
        }, {
          x: r,
          y: i
        }, {
          x: t,
          y: i
        }];
      }

      function y(n, t) {
        var e = n.x,
            r = n.y;
        return e < t.minX || e > t.maxX || r < t.minY || r > t.maxY;
      }

      function h(n, t, e, r) {
        var i = t.x - n.x,
            o = t.y - n.y,
            u = r.x - e.x,
            a = r.y - e.y,
            f = (-o * (n.x - e.x) + i * (n.y - e.y)) / (-u * o + i * a),
            c = (u * (n.y - e.y) - a * (n.x - e.x)) / (-u * o + i * a);
        return f >= 0 && f <= 1 && c >= 0 && c <= 1;
      }

      function m(n, t, e) {
        if (e.width === e.height === 0) return !1;
        var r = x(e),
            i = r[0],
            o = r[1],
            u = r[2],
            a = r[3];
        return h(n, t, i, o) || h(n, t, i, a) || h(n, t, o, u) || h(n, t, u, a);
      }

      function d(n) {
        return n = function (n) {
          for (var t = [n[0]], e = 1; e < n.length; e++) {
            var r = n[e],
                i = n[e + 1],
                o = n[e - 1];
            i && o && (i.x === r.x && o.x === r.x || i.y === r.y && o.y === r.y) || t.push(r);
          }

          return t;
        }(n = p(n));
      }

      function s(n, t) {
        return [n, {
          x: n.x,
          y: t.y
        }, t];
      }

      function p(n) {
        var t = [],
            e = {};
        return n.forEach(function (n) {
          var t = n.id = n.x + "-" + n.y;
          e[t] = n;
        }), i.each(e, function (n) {
          t.push(n);
        }), t;
      }

      function l(n, t) {
        return Math.abs(n.x - t.x) + Math.abs(n.y - t.y);
      }

      function v(n, t, e, r, i) {
        return l(n, t) + l(n, e) + function (n, t) {
          var e = 0;
          return t.forEach(function (t) {
            t && (n.x === t.x && (e += -2), n.y === t.y && (e += -2));
          }), e;
        }(n, [t, e, r, i]);
      }

      function g(n, t, e, r, i, o, u) {
        var a = [],
            f = [t],
            c = {},
            x = {},
            y = {};
        x[t.id] = 0, y[t.id] = v(t, e, t);
        var h = {};
        n.forEach(function (n) {
          h[n.id] = n;
        });

        for (var d = function d() {
          var d = void 0,
              s = 1 / 0;

          if (f.forEach(function (n) {
            y[n.id] < s && (s = y[n.id], d = n);
          }), d === e) {
            var g = [];
            return function n(t, e, r, i, o) {
              void 0 === o && (o = 0), t.unshift(e[i]), r[i] && r[i] !== i && o <= 100 && n(t, e, r, r[i], o + 1);
            }(g, h, c, e.id), {
              v: g
            };
          }

          !function (n, t) {
            var e = n.indexOf(t);
            e > -1 && n.splice(e, 1);
          }(f, d), a.push(d), function (n, t, e, r) {
            var i = [];
            return n.forEach(function (n) {
              n !== t && (n.x !== t.x && n.y !== t.y || m(n, t, e) || m(n, t, r) || i.push(n));
            }), p(i);
          }(n, d, r, i).forEach(function (n) {
            if (-1 === a.indexOf(n)) {
              -1 === f.indexOf(n) && f.push(n);
              var r = y[d.id] + l(d, n);
              x[n.id] && r >= x[n.id] || (c[n.id] = d.id, x[n.id] = r, y[n.id] = x[n.id] + v(n, e, t, o, u));
            }
          });
        }; f.length;) {
          var s = d();
          if ("object" == _typeof(s)) return s.v;
        }

        return console.error("cannot find path: ", n, t, e), [t, e];
      }

      function b(n, t, e, r, i) {
        var h = e && e.bbox ? e.bbox : a(n),
            m = r && r.bbox ? r.bbox : a(t);
        if (u(h, m)) return d(s(n, t));
        var l = f(h, i),
            v = f(m, i);
        if (u(l, v)) return d(s(n, t));

        var b = c(l, n),
            X = c(v, t),
            Y = function (n) {
          void 0 === n && (n = []);
          var t = [],
              e = [];
          n.forEach(function (n) {
            t.push(n.x), e.push(n.y);
          });
          var r = Math.min.apply(Math, t),
              i = Math.max.apply(Math, t),
              o = Math.min.apply(Math, e),
              u = Math.max.apply(Math, e);
          return {
            centerX: (r + i) / 2,
            centerY: (o + u) / 2,
            maxX: i,
            maxY: u,
            minX: r,
            minY: o,
            height: u - o,
            width: i - r
          };
        }([b, X]),
            M = (o(l, v), o(l, Y)),
            P = o(v, Y),
            w = [];

        w = (w = w.concat(x(M))).concat(x(P));
        var E = {
          x: (n.x + t.x) / 2,
          y: (n.y + t.y) / 2
        };
        [Y, M, P].forEach(function (n) {
          w = w.concat(function (n, t) {
            return function (n, t) {
              return t < n.minX || t > n.maxX ? [] : [{
                x: t,
                y: n.minY
              }, {
                x: t,
                y: n.maxY
              }];
            }(n, t.x).concat(function (n, t) {
              return t < n.minY || t > n.maxY ? [] : [{
                x: n.minX,
                y: t
              }, {
                x: n.maxX,
                y: t
              }];
            }(n, t.y));
          }(n, E).filter(function (n) {
            return y(n, l) && y(n, v);
          }));
        }), [{
          x: b.x,
          y: X.y
        }, {
          x: X.x,
          y: b.y
        }].forEach(function (n) {
          y(n, l) && y(n, v) && w.push(n);
        }), w.unshift(b), w.push(X);
        var j = g(w = p(w), b, X, h, m, n, t);
        return j.unshift(n), j.push(t), d(j);
      }

      function X(n, t) {
        var e = [],
            r = n[0];
        return e.push(["M", r.x, r.y]), n.forEach(function (r, i) {
          var o = n[i + 1],
              u = n[i + 2];
          if (o && u) {
            if (function (n, t, e) {
              return !(n.x === t.x === e.x || n.y === t.y === e.y);
            }(r, o, u)) {
              var a = function (n, t, e, r) {
                var i = l(n, t),
                    o = l(e, t);
                return i < r && (r = i), o < r && (r = o), [{
                  x: t.x - r / i * (t.x - n.x),
                  y: t.y - r / i * (t.y - n.y)
                }, {
                  x: t.x - r / o * (t.x - e.x),
                  y: t.y - r / o * (t.y - e.y)
                }];
              }(r, o, u, t),
                  f = a[0],
                  c = a[1];

              e.push(["L", f.x, f.y]), e.push(["Q", o.x, o.y, c.x, c.y]), e.push(["L", c.x, c.y]);
            } else e.push(["L", o.x, o.y]);
          } else o && e.push(["L", o.x, o.y]);
        }), e;
      }

      r.registerEdge("polyline", {
        offset: 10,
        getPath: function getPath(n) {
          var t = n.getPoints(),
              e = n.getSource(),
              r = n.getTarget();
          return this.getPathByPoints(t, e, r);
        },
        getPathByPoints: function getPathByPoints(n, t, e) {
          var r = b(n[0], n[n.length - 1], t, e, this.offset);
          return i.pointsToPolygon(r);
        }
      }), r.registerEdge("polyline-round", {
        borderRadius: 9,
        getPathByPoints: function getPathByPoints(n, t, e) {
          return X(d(b(n[0], n[n.length - 1], t, e, this.offset)), this.borderRadius);
        }
      }, "polyline"), n.exports = !0;
    }
  });
});
},{"@antv/g6":"../node_modules/@antv/g6/build/g6.js"}],"test.js":[function(require,module,exports) {
"use strict";

var _parse = _interopRequireDefault(require("../src/parse"));

var _g = _interopRequireDefault(require("@antv/g6"));

require("@antv/g6/build/plugin.layout.dagre");

require("@antv/g6/build/plugin.behaviour.analysis");

require("@antv/g6/build/plugin.edge.polyline");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { if (i % 2) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } else { Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i])); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

_g.default.registerNode('rect', {
  getPath: function getPath(item) {
    var width = 100;
    var height = 40;
    return _g.default.Util.getRectPath(-width / 2, -height / 2, width, height, 10);
  }
});

var graph = new _g.default.Graph({
  container: 'root',
  fitView: 'cc',
  height: window.innerHeight / 2,
  defaultIntersectBox: 'rect',
  modes: {
    default: ['panCanvas', 'wheelZoom']
  }
});
graph.node({
  shape: 'rect',
  label: function label(model) {
    var r = model.label || model.id || '';
    return r.split(',').join('\n');
  },
  style: function style(e) {
    return {
      stroke: '#66ccff',
      fill: e.color,
      fillOpacity: 0.45,
      lineWidth: 2
    };
  }
});
graph.edge({
  style: {
    endArrow: true
  },
  shape: 'polyline'
});
window.graph = graph;
document.getElementById('draw').addEventListener('click', function () {
  var str = document.getElementById('str').value;
  var data = (0, _parse.default)(str);

  if (data) {
    _g.default.registerGroup('custom', {
      draw: function draw(item) {
        var group = item.getGraphicGroup();
        var childrenBox = item.getChildrenBBox();
        group.addShape('text', {
          attrs: {
            x: childrenBox.x,
            y: childrenBox.y,
            text: '这是一个群组',
            fill: 'red'
          }
        });
        return group.addShape('rect', {
          attrs: _objectSpread({}, childrenBox, {
            stroke: 'red'
          })
        });
      }
    });

    graph.read(data);
  }
});
},{"../src/parse":"../src/parse.js","@antv/g6":"../node_modules/@antv/g6/build/g6.js","@antv/g6/build/plugin.layout.dagre":"../node_modules/@antv/g6/build/plugin.layout.dagre.js","@antv/g6/build/plugin.behaviour.analysis":"../node_modules/@antv/g6/build/plugin.behaviour.analysis.js","@antv/g6/build/plugin.edge.polyline":"../node_modules/@antv/g6/build/plugin.edge.polyline.js"}],"../../../.nvm/versions/node/v12.6.0/lib/node_modules/parcel/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "57813" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else {
        window.location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["../../../.nvm/versions/node/v12.6.0/lib/node_modules/parcel/src/builtins/hmr-runtime.js","test.js"], null)
//# sourceMappingURL=/test.js.map